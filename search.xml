<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1. Two Sum</title>
    <url>/2020/05/30/1-Two-Sum/</url>
    <content><![CDATA[<p>hashmap O(n) time O(n) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            x = target - num</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">return</span> [d[x], i]</span><br><span class="line">            d[num] = i</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            x = target - nums[i]</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">return</span> [d[x], i]</span><br><span class="line">            d[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (m.count(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;m[x], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hm.<span class="built_in">find</span>(target - nums[i]); <span class="comment">// 为了解决数组中有相同数的问题，在每次插新数之前先进行查找，查找无果之后再插数，这样只需要扫描一遍即可</span></span><br><span class="line">            <span class="keyword">if</span> (it != hm.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="built_in">min</span>(it-&gt;second, i), <span class="built_in">max</span>(it-&gt;second, i)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hm[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
        <tag>Hash table</tag>
      </tags>
  </entry>
  <entry>
    <title>11. Container With Most Water</title>
    <url>/2020/05/30/11-Container-With-Most-Water/</url>
    <content><![CDATA[<p>two pointers O(n)<br>这道题和maximum square不一样<br>思路和trapping most water类似，都是维护左右两个指针从外往里找短板，当前最大面积更新后，短板必须要更新成更长的板</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        l, r, res = <span class="number">0</span>, len(height) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mn = min(height[l], height[r])</span><br><span class="line">            res = max(res, mn * (r - l))</span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> height[l] &lt;= mn:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> height[r] &lt;= mn:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mn = <span class="built_in">min</span>(<span class="built_in">height</span>[l], <span class="built_in">height</span>[r]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, mn * (r - l));</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">height</span>[l] &lt;= mn) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">height</span>[r] &lt;= mn) &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>10. Regular Expression Matching</title>
    <url>/2020/05/30/10-Regular-Expression-Matching/</url>
    <content><![CDATA[<p>O(mn) time O(m+n) space<br>只有p[n - 1]为*那种情况才有可能需要向两个方向递归（其他单向递归的时间复杂度不会超过这个），一个方向m层，另外一个方向n层，对于每一层都有可能向另外一个方向递归，所以时间复杂度是O(mn)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        m, n = len(s), len(p)</span><br><span class="line">        f = [[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            f[<span class="number">0</span>][i] = (p[i - <span class="number">1</span>] == <span class="string">'*'</span>) <span class="keyword">and</span> f[<span class="number">0</span>][i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">2</span>] <span class="keyword">or</span> (f[i - <span class="number">1</span>][j] <span class="keyword">and</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] <span class="keyword">or</span> p[j - <span class="number">2</span>] == <span class="string">'.'</span>))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] <span class="keyword">and</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">return</span> f[m][n]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isMatch(s, s.length(), p, p.length()); <span class="comment">// 从后往前分析</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> m, <span class="keyword">const</span> <span class="built_in">string</span> &amp;p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 两个空串肯定匹配</span></span><br><span class="line">        <span class="keyword">if</span> (m != <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果s不空p空肯定不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> &amp;&amp; n != <span class="number">0</span>) <span class="keyword">return</span> p[n - <span class="number">1</span>] == <span class="string">'*'</span> &amp;&amp; isMatch(s, m, p, n - <span class="number">2</span>); <span class="comment">// 如果s空p不空，则只有可能p是类似a*a*a*这样的</span></span><br><span class="line">        <span class="keyword">if</span> (p[n - <span class="number">1</span>] == <span class="string">'*'</span>) <span class="keyword">return</span> (s[m - <span class="number">1</span>] == p[n - <span class="number">2</span>] || p[n - <span class="number">2</span>] == <span class="string">'.'</span>) &amp;&amp; isMatch(s, m - <span class="number">1</span>, p, n) || isMatch(s, m, p, n - <span class="number">2</span>); <span class="comment">// 如果p以*结尾，则(1)要不s[m - 1]跟p[n - 2]匹配（包括p[n - 2]是.的情况）并且s[0:m-1)和p[0:n)匹配（这里之所以是p[0:n)不是p[0:n-2)是因为s[0:m-1)未必能跟p[0:n-2)匹配但是有可能跟p[0:n)匹配，比如s是xxxzz，p是xxxz*，xxx跟xxxz不匹配但是xxxz*可以跟xxxz匹配，所以这里要用整个p去尝试匹配s[0:m-1)）(2)要不s[0:m)跟p[0:n - 2)匹配</span></span><br><span class="line">        <span class="keyword">return</span> (s[m - <span class="number">1</span>] == p[n - <span class="number">1</span>] || p[n - <span class="number">1</span>] == <span class="string">'.'</span>) &amp;&amp; isMatch(s, m - <span class="number">1</span>, p, n - <span class="number">1</span>); <span class="comment">// 如果p不以*结尾，则s[m - 1]跟p[n - 1]匹配（或者p[n - 1]为.）并且s[0:m-1)跟p[0:n-1)匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp O(mn) time O(mn) space<br>这道题中”a*”的意思是若干个a</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">f</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            f[<span class="number">0</span>][j] = (p[j - <span class="number">1</span>] == <span class="string">'*'</span>) &amp;&amp; f[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">2</span>] || f[i - <span class="number">1</span>][j] &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">'.'</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">'.'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), m = p.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m + <span class="number">1</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 两个空串肯定匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>]; <span class="comment">// 前一个字符p[j - 2]相当于循环节，所以要继承前前个结果，即循环节之前的匹配结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">// 如果字符相同或者正则字符是.直接继承之前两个串的匹配结果</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>] || (dp[i - <span class="number">1</span>][j] &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">'.'</span>)); <span class="comment">// 因为p[j - 2]是循环节，所以要检查前前个结果dp[i][j - 2]，即循环节之前的匹配结果；另外，如果之前的字符串s[0:i-2]已经和p[0:j-1]匹配，即dp[i - 1][j]为true，那么就要看当前字符是否和正则字符（循环节p[j-2]）匹配；这里一定要考虑清楚逻辑！！用OR是对的，ifelse可能出问题</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>String match</tag>
      </tags>
  </entry>
  <entry>
    <title>13. Roman to Integer</title>
    <url>/2020/05/31/13-Roman-to-Integer/</url>
    <content><![CDATA[<p>O(n)<br>一般罗马数字都是从大到小排列，如果发现当前数字小于下一个，如IV，则减去当前数字，即-1 + 5 = 4</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'I'</span>: <span class="number">1</span>, <span class="string">'V'</span>: <span class="number">5</span>, <span class="string">'X'</span>: <span class="number">10</span>, <span class="string">'L'</span>: <span class="number">50</span>, <span class="string">'C'</span>: <span class="number">100</span>, <span class="string">'D'</span>: <span class="number">500</span>, <span class="string">'M'</span>: <span class="number">1000</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> d[s[i - <span class="number">1</span>]] &lt; d[s[i]]:</span><br><span class="line">                res -= d[s[i - <span class="number">1</span>]] * <span class="number">2</span></span><br><span class="line">            res += d[s[i]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'I'</span>: <span class="number">1</span>, <span class="string">'V'</span>: <span class="number">5</span>, <span class="string">'X'</span>: <span class="number">10</span>, <span class="string">'L'</span>: <span class="number">50</span>, <span class="string">'C'</span>: <span class="number">100</span>, <span class="string">'D'</span>: <span class="number">500</span>, <span class="string">'M'</span>: <span class="number">1000</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        res, n = <span class="number">0</span>, len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &lt; n <span class="keyword">and</span> d[s[i]] &lt; d[s[i + <span class="number">1</span>]]:</span><br><span class="line">                res -= d[s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += d[s[i]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">'I'</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'V'</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'X'</span>, <span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'L'</span>, <span class="number">50</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'C'</span>, <span class="number">100</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'D'</span>, <span class="number">500</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'M'</span>, <span class="number">1000</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; m[s[i]] &lt; m[s[i + <span class="number">1</span>]]) &#123;</span><br><span class="line">                res -= m[s[i]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += m[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">'I'</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'V'</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'X'</span>, <span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'L'</span>, <span class="number">50</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'C'</span>, <span class="number">100</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'D'</span>, <span class="number">500</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'M'</span>, <span class="number">1000</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; m[s[i]] &gt; m[s[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">                res -= m[s[i - <span class="number">1</span>]] * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += m[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Integer</tag>
        <tag>Roman</tag>
      </tags>
  </entry>
  <entry>
    <title>12. Integer to Roman</title>
    <url>/2020/05/30/12-Integer-to-Roman/</url>
    <content><![CDATA[<p>O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M = [<span class="string">''</span>, <span class="string">'M'</span>, <span class="string">'MM'</span>, <span class="string">'MMM'</span>]</span><br><span class="line">C = [<span class="string">''</span>, <span class="string">'C'</span>, <span class="string">'CC'</span>, <span class="string">'CCC'</span>, <span class="string">'CD'</span>, <span class="string">'D'</span>, <span class="string">'DC'</span>, <span class="string">'DCC'</span>, <span class="string">'DCCC'</span>, <span class="string">'CM'</span>]</span><br><span class="line">X = [<span class="string">''</span>, <span class="string">'X'</span>, <span class="string">'XX'</span>, <span class="string">'XXX'</span>, <span class="string">'XL'</span>, <span class="string">'L'</span>, <span class="string">'LX'</span>, <span class="string">'LXX'</span>, <span class="string">'LXXX'</span>, <span class="string">'XC'</span>]</span><br><span class="line">I = [<span class="string">''</span>, <span class="string">'I'</span>, <span class="string">'II'</span>, <span class="string">'III'</span>, <span class="string">'IV'</span>, <span class="string">'V'</span>, <span class="string">'VI'</span>, <span class="string">'VII'</span>, <span class="string">'VIII'</span>, <span class="string">'IX'</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> M[num // <span class="number">1000</span>] + C[num % <span class="number">1000</span> // <span class="number">100</span>] + X[num % <span class="number">100</span> // <span class="number">10</span>] + I[num % <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> M[] = &#123;<span class="string">""</span>, <span class="string">"M"</span>, <span class="string">"MM"</span>, <span class="string">"MMM"</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> C[] = &#123;<span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> X[] = &#123;<span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> I[] = &#123;<span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> M[num / <span class="number">1000</span>] + C[num % <span class="number">1000</span> / <span class="number">100</span>] + X[num % <span class="number">100</span> / <span class="number">10</span>] + I[num % <span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Integer</tag>
        <tag>Roman</tag>
      </tags>
  </entry>
  <entry>
    <title>14. Longest Common Prefix</title>
    <url>/2020/05/31/14-Longest-Common-Prefix/</url>
    <content><![CDATA[<p>O(mn) time<br>vertical scan</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> zip(*strs):</span><br><span class="line">            <span class="keyword">if</span> len(set(x)) != <span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">            res += x[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> zip(*strs):</span><br><span class="line">            <span class="keyword">if</span> all(c == x[<span class="number">0</span>] <span class="keyword">for</span> c <span class="keyword">in</span> x):</span><br><span class="line">                res += x[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>horizontal scan<br>循环依次检查即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs: <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        res = strs[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(strs)):</span><br><span class="line">            res = self.resolve(res, strs[i])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">resolve</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(min(len(A), len(B))):</span><br><span class="line">            <span class="keyword">if</span> A[i] != B[i]: <span class="keyword">break</span></span><br><span class="line">            res += A[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>trie</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = &#123;&#125;</span><br><span class="line">        self.is_end = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> p.children:</span><br><span class="line">                p.children[c] = TrieNode()</span><br><span class="line">            p = p.children[c]</span><br><span class="line">        p.is_end = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''first approach'''</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">while</span> len(p.children) == <span class="number">1</span>:</span><br><span class="line">            k, v = list(p.children.items())[<span class="number">0</span>]</span><br><span class="line">            res += k</span><br><span class="line">            p = v</span><br><span class="line">            <span class="keyword">if</span> p.is_end: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''second approach'''</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">while</span> len(p.children) == <span class="number">1</span>:</span><br><span class="line">            res += list(p.children.keys())[<span class="number">0</span>]</span><br><span class="line">            p = list(p.children.values())[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> p.is_end: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''third approach'''</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">while</span> len(p.children) == <span class="number">1</span>:</span><br><span class="line">            res += next(iter(p.children))</span><br><span class="line">            p = next(iter(p.children.values()))</span><br><span class="line">            <span class="keyword">if</span> p.is_end: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">            self.add(s)</span><br><span class="line">        <span class="keyword">return</span> self.search()</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.empty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> n = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">string</span> res = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n &amp;&amp; !res.empty(); ++i) &#123;</span><br><span class="line">            res = helper(res, strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;p, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">min</span>(p.length(), s.length());</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; p[i] == s[i]; ++i) &#123;</span><br><span class="line">            res += p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>trie</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt; children;</span><br><span class="line">        <span class="keyword">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    TrieNode *root = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : strs) &#123;</span><br><span class="line">            add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !p-&gt;isEnd &amp;&amp; p-&gt;children.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;&amp;[c, n] = *<span class="built_in">begin</span>(p-&gt;children);</span><br><span class="line">            res += c;</span><br><span class="line">            p = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children.count(c)) &#123;</span><br><span class="line">                p-&gt;children[c] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(mnlogn) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.empty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        sort(<span class="built_in">begin</span>(strs), <span class="built_in">end</span>(strs));</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">min</span>(strs.front().length(), strs.back().length());</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; strs.front()[i] == strs.back()[i]; ++i) &#123;</span><br><span class="line">            res += strs.front()[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 3Sum</title>
    <url>/2020/05/31/15-3Sum/</url>
    <content><![CDATA[<p>two pointers O(n<sup>2</sup>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i - <span class="number">1</span>] == nums[i]: <span class="keyword">continue</span></span><br><span class="line">            t = -nums[i]</span><br><span class="line">            l, r = i + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                s = nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> s == t:</span><br><span class="line">                    res.append([nums[i], nums[l], nums[r]])</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l - <span class="number">1</span>] == nums[l]: l += <span class="number">1</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]: r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &lt; t:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l - <span class="number">1</span>] == nums[l]: l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]: r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">long</span> t = -(<span class="keyword">long</span>)nums[i];</span><br><span class="line">            <span class="keyword">int</span> l = i + <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">long</span> s = (<span class="keyword">long</span>)nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">                    res.push_back(&#123;nums[i], nums[l], nums[r]&#125;);</span><br><span class="line">                    <span class="keyword">do</span> &#123; ++l; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">do</span> &#123; --r; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; t) &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123; ++l; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123; --r; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>17. Letter Combinations of a Phone Number</title>
    <url>/2020/05/31/17-Letter-Combinations-of-a-Phone-Number/</url>
    <content><![CDATA[<p>iterative O(3<sup>n</sup>) time</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = [<span class="string">''</span>, <span class="string">''</span>, <span class="string">'abc'</span>, <span class="string">'def'</span>, <span class="string">'ghi'</span>, <span class="string">'jkl'</span>, <span class="string">'mno'</span>, <span class="string">'pqrs'</span>, <span class="string">'tuv'</span>, <span class="string">'wxyz'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools <span class="keyword">as</span> it</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: <span class="keyword">return</span> []</span><br><span class="line">        chars = [m[int(d)] <span class="keyword">for</span> d <span class="keyword">in</span> digits]</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">''</span>.join(p) <span class="keyword">for</span> p <span class="keyword">in</span> it.product(*chars)]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = [<span class="string">''</span>, <span class="string">''</span>, <span class="string">'abc'</span>, <span class="string">'def'</span>, <span class="string">'ghi'</span>, <span class="string">'jkl'</span>, <span class="string">'mno'</span>, <span class="string">'pqrs'</span>, <span class="string">'tuv'</span>, <span class="string">'wxyz'</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> res, d : [s + c <span class="keyword">for</span> s <span class="keyword">in</span> res <span class="keyword">for</span> c <span class="keyword">in</span> m[d]], map(int, digits), [<span class="string">''</span>])</span><br></pre></td></tr></table></figure>
<p>用这个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = [<span class="string">''</span>, <span class="string">''</span>, <span class="string">'abc'</span>, <span class="string">'def'</span>, <span class="string">'ghi'</span>, <span class="string">'jkl'</span>, <span class="string">'mno'</span>, <span class="string">'pqrs'</span>, <span class="string">'tuv'</span>, <span class="string">'wxyz'</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: <span class="keyword">return</span> []</span><br><span class="line">        res = [<span class="string">''</span>]</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> map(int, digits):</span><br><span class="line">            res = [s + c <span class="keyword">for</span> s <span class="keyword">in</span> res <span class="keyword">for</span> c <span class="keyword">in</span> m[d]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = [<span class="string">''</span>, <span class="string">''</span>, <span class="string">'abc'</span>, <span class="string">'def'</span>, <span class="string">'ghi'</span>, <span class="string">'jkl'</span>, <span class="string">'mno'</span>, <span class="string">'pqrs'</span>, <span class="string">'tuv'</span>, <span class="string">'wxyz'</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: <span class="keyword">return</span> []</span><br><span class="line">        res = [<span class="string">''</span>]</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> digits:</span><br><span class="line">            t = []</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> res:</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> m[int(d)]:</span><br><span class="line">                    t.append(s + c)</span><br><span class="line">            res = t</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>dfs</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = [<span class="string">''</span>, <span class="string">''</span>, <span class="string">'abc'</span>, <span class="string">'def'</span>, <span class="string">'ghi'</span>, <span class="string">'jkl'</span>, <span class="string">'mno'</span>, <span class="string">'pqrs'</span>, <span class="string">'tuv'</span>, <span class="string">'wxyz'</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> len(digits) == <span class="number">1</span>: <span class="keyword">return</span> list(m[int(digits)])</span><br><span class="line">        res = self.letterCombinations(digits[: <span class="number">-1</span>]) <span class="comment"># 前边的结果已经出来了，只需要计算当前的最后一个字符即可</span></span><br><span class="line">        <span class="keyword">return</span> [s + c <span class="keyword">for</span> s <span class="keyword">in</span> res <span class="keyword">for</span> c <span class="keyword">in</span> m[int(digits[<span class="number">-1</span>])]]</span><br></pre></td></tr></table></figure>
<p>iterative</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> m[] = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param digits: A digital string</span></span><br><span class="line"><span class="comment">     * @return: all posible letter combinations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> &amp;digits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (digits.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        res.push_back(<span class="string">""</span>); <span class="comment">// 一定要放一个空串！！！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> d : digits) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : res) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c : m[d - <span class="string">'0'</span>]) &#123;</span><br><span class="line">                    t.push_back(s + c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.swap(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>recursive O(3^n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> m[] = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param digits: A digital string</span></span><br><span class="line"><span class="comment">     * @return: all posible letter combinations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> &amp;digits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (digits.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        dfs(<span class="string">""</span>, digits, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">string</span> &amp;d, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == d.length()) &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : m[d[s.length()] - <span class="string">'0'</span>]) &#123;</span><br><span class="line">            dfs(s + c, d, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Brute force</tag>
        <tag>Depth first search</tag>
        <tag>Combination</tag>
      </tags>
  </entry>
  <entry>
    <title>16. 3Sum Closest</title>
    <url>/2020/05/31/16-3Sum-Closest/</url>
    <content><![CDATA[<p>two pointers O(n<sup>2</sup>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n, d, res = len(nums), float(<span class="string">'inf'</span>), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i - <span class="number">1</span>] == nums[i]: <span class="keyword">continue</span></span><br><span class="line">            l, r, t = i + <span class="number">1</span>, n - <span class="number">1</span>, target - nums[i]</span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                s = nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> abs(s - t) &lt; d:</span><br><span class="line">                    d, res = abs(s - t), s + nums[i]</span><br><span class="line">                <span class="keyword">if</span> s &lt; t:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l - <span class="number">1</span>] == nums[l]:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &gt; t:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> diff = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i + <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(sum - t) &lt; diff) &#123;</span><br><span class="line">                    diff = <span class="built_in">abs</span>(sum - t);</span><br><span class="line">                    res = nums[i] + sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum == t) &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; t) &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123; ++l; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123; --r; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">do</span> &#123; ++i; &#125; <span class="keyword">while</span> (i &lt; n &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>18. 4Sum</title>
    <url>/2020/05/31/18-4Sum/</url>
    <content><![CDATA[<p>左右夹逼O(n<sup>3</sup>) time O(1) space<br>kSum的复杂度下界是O(n^(k-1))</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        n, res = len(nums), []</span><br><span class="line">        <span class="comment"># mx = nums[-1]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># if nums[i] + 3 * mx &lt; target: continue</span></span><br><span class="line">            <span class="comment"># if 4 * nums[i] &gt; target: break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i - <span class="number">1</span>] == nums[i]: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># if nums[i] + nums[j] + 2 * mx &lt; target: continue</span></span><br><span class="line">                <span class="comment"># if nums[i] + 3 * nums[j] &gt; target: break</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j - <span class="number">1</span>] == nums[j]: <span class="keyword">continue</span></span><br><span class="line">                l, r, t = j + <span class="number">1</span>, n - <span class="number">1</span>, target - nums[i] - nums[j]</span><br><span class="line">                <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                    s = nums[l] + nums[r]</span><br><span class="line">                    <span class="keyword">if</span> s == t:</span><br><span class="line">                        res.append([nums[i], nums[j], nums[l], nums[r]])</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l - <span class="number">1</span>] == nums[l]: l += <span class="number">1</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]: r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> s &lt; t:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l - <span class="number">1</span>] == nums[l]: l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]: r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 注意跳过重复的数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 注意跳过重复的数</span></span><br><span class="line">                <span class="keyword">int</span> l = j + <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> t = target - nums[i] - nums[j];</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                    <span class="keyword">int</span> s = nums[l] + nums[r];</span><br><span class="line">                    <span class="keyword">if</span> (s &lt; t) &#123;</span><br><span class="line">                        <span class="keyword">do</span> &#123; ++l; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="number">1</span>]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; t) &#123;</span><br><span class="line">                        <span class="keyword">do</span> &#123; --r; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="number">1</span>]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.push_back(&#123;nums[i], nums[j], nums[l], nums[r]&#125;);</span><br><span class="line">                        <span class="keyword">do</span> &#123; ++l; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="number">1</span>]);</span><br><span class="line">                        <span class="keyword">do</span> &#123; --r; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>19. Remove Nth Node From End of List</title>
    <url>/2020/05/31/19-Remove-Nth-Node-From-End-of-List/</url>
    <content><![CDATA[<p>O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(next = head)</span><br><span class="line">        slow, fast = dummy, head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            fast = fast.next</span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            slow, fast = slow.next, fast.next</span><br><span class="line">        slow.next = slow.next.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy_head = <span class="number">0</span>;</span><br><span class="line">        dummy_head.next = head;</span><br><span class="line">        <span class="keyword">auto</span> fast = head, slow = &amp;dummy_head; <span class="comment">// slow指向head的前一个，这样最后slow指向要删的node的前一个，方便删除，比如[1]删倒数第1</span></span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy_head = <span class="number">0</span>;</span><br><span class="line">        dummy_head.next = head;</span><br><span class="line">        <span class="keyword">auto</span> fast = head, slow = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (--n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="function">ListNode <span class="title">dummy_head</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy_head.next = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span> &amp;&amp; fast) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) <span class="keyword">return</span> head; <span class="comment">// 要考虑链表长度不足n</span></span><br><span class="line">        ListNode *slow = head, *prev = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev-&gt;next = slow-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">front</span><span class="params">(head)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">behind</span><span class="params">(&amp;head)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (front) &#123;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (--n &lt; <span class="number">0</span>)</span><br><span class="line">                behind = &amp;(*behind)-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">to_be_deleted</span><span class="params">(*behind)</span></span>;</span><br><span class="line">        *behind = (*behind)-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> to_be_deleted;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
        <tag>Hare and tortoise</tag>
      </tags>
  </entry>
  <entry>
    <title>2. Add Two Numbers</title>
    <url>/2020/05/30/2-Add-Two-Numbers/</url>
    <content><![CDATA[<p>O(max(m, n)) time</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        tail = dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> c:</span><br><span class="line">            a = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            b = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            l1 = l1.next <span class="keyword">if</span> l1 <span class="keyword">else</span> l1</span><br><span class="line">            l2 = l2.next <span class="keyword">if</span> l2 <span class="keyword">else</span> l2</span><br><span class="line">            c, s = divmod(a + b + c, <span class="number">10</span>)</span><br><span class="line">            tail.next = ListNode(s)</span><br><span class="line">            tail = tail.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        tail = dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> c != <span class="number">0</span>:</span><br><span class="line">            a = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            b = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            l1 = l1.next <span class="keyword">if</span> l1 <span class="keyword">else</span> l1</span><br><span class="line">            l2 = l2.next <span class="keyword">if</span> l2 <span class="keyword">else</span> l2</span><br><span class="line">            s = a + b + c</span><br><span class="line">            tail.next = ListNode(s % <span class="number">10</span>)</span><br><span class="line">            tail = tail.next</span><br><span class="line">            c = s // <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        ListNode dummy_head(0), *tail = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> b = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">            <span class="keyword">int</span> s = a + b + c;</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> ListNode(s % <span class="number">10</span>);</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            c = s / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        ListNode *n1 = l1, *n2 = l2, dummy_head(<span class="number">-1</span>), *t = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">while</span> (n1 || n2 || c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            a = n1 ? n1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            b = n2 ? n2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> s = a + b + c;</span><br><span class="line">            t-&gt;next = <span class="keyword">new</span> ListNode(s % <span class="number">10</span>);</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">            c = s / <span class="number">10</span>;</span><br><span class="line">            n1 = n1 ? n1-&gt;next : n1;</span><br><span class="line">            n2 = n2 ? n2-&gt;next : n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>20. Valid Parentheses</title>
    <url>/2020/05/31/20-Valid-Parentheses/</url>
    <content><![CDATA[<p>stack O(n) time O(n) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">')'</span>: <span class="string">'('</span>, <span class="string">'&#125;'</span>: <span class="string">'&#123;'</span>, <span class="string">']'</span>: <span class="string">'['</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stk <span class="keyword">or</span> d[c] != stk[<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stk.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stk += c <span class="comment"># 注意这里c是一个字符所以可以用+=</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stk</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; m = &#123;&#123;<span class="string">')'</span>, <span class="string">'('</span>&#125;, &#123;<span class="string">'&#125;'</span>, <span class="string">'&#123;'</span>&#125;, &#123;<span class="string">']'</span>, <span class="string">'['</span>&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.count(c)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stk.empty() &amp;&amp; stk.back() == m[c]) &#123;</span><br><span class="line">                    stk.pop_back();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; hm&#123;&#123;<span class="string">')'</span>, <span class="string">'('</span>&#125;, &#123;<span class="string">'&#125;'</span>, <span class="string">'&#123;'</span>&#125;, &#123;<span class="string">']'</span>, <span class="string">'['</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hm.count(c)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stk.empty() || stk.top() != hm[c]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.empty(); <span class="comment">// 注意最后要判空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>22. Generate Parentheses</title>
    <url>/2020/05/31/22-Generate-Parentheses/</url>
    <content><![CDATA[<p>backtracking O(2<sup>n</sup>) time<br>思路是只要左括号比右括号多就是合法的！！！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(s, l, r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> l &lt; <span class="number">0</span> <span class="keyword">or</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> l &gt; r: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">and</span> <span class="keyword">not</span> r:</span><br><span class="line">                res.append(s) <span class="comment"># 注意这里不能用res += s因为s是Iterable会逐个追加，想整体追加要用append</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            gen(s + <span class="string">'('</span>, l - <span class="number">1</span>, r) <span class="comment"># 这里底层内存需要进行字符串复制，但是没办法，Python字符串literal不能修改，也不提供StringBuilder</span></span><br><span class="line">            gen(s + <span class="string">')'</span>, l, r - <span class="number">1</span>)</span><br><span class="line">        gen(<span class="string">''</span>, n, n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        dfs(s, n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nl &lt; <span class="number">0</span> || nr &lt; <span class="number">0</span> || nl &gt; nr) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (nl == <span class="number">0</span> &amp;&amp; nr == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(s += <span class="string">'('</span>, nl - <span class="number">1</span>, nr);</span><br><span class="line">        s.pop_back();</span><br><span class="line">        dfs(s += <span class="string">')'</span>, nl, nr - <span class="number">1</span>);</span><br><span class="line">        s.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        nl = nr = n;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        dfs(s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nl == <span class="number">0</span> &amp;&amp; nr == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nl == <span class="number">0</span>) &#123;</span><br><span class="line">            --nr;</span><br><span class="line">            dfs(s += <span class="string">')'</span>);</span><br><span class="line">            ++nr;</span><br><span class="line">            s.pop_back();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nl == nr) &#123;</span><br><span class="line">            --nl;</span><br><span class="line">            dfs(s += <span class="string">'('</span>);</span><br><span class="line">            ++nl;</span><br><span class="line">            s.pop_back();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --nl;</span><br><span class="line">            dfs(s += <span class="string">'('</span>);</span><br><span class="line">            ++nl;</span><br><span class="line">            s.pop_back();</span><br><span class="line">            --nr;</span><br><span class="line">            dfs(s += <span class="string">')'</span>);</span><br><span class="line">            ++nr;</span><br><span class="line">            s.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nl, nr;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果需要轴对称</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        dfs(s, n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nl &lt; <span class="number">0</span> || nr &lt; <span class="number">0</span> || nl &gt; nr) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (nl + nr == n) &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">                    res.back() += <span class="string">')'</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.back() += <span class="string">'('</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(s += <span class="string">'('</span>, nl - <span class="number">1</span>, nr);</span><br><span class="line">        s.pop_back();</span><br><span class="line">        dfs(s += <span class="string">')'</span>, nl, nr - <span class="number">1</span>);</span><br><span class="line">        s.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>24. Swap Nodes in Pairs</title>
    <url>/2020/05/31/24-Swap-Nodes-in-Pairs/</url>
    <content><![CDATA[<p>recursive O(n) time O(n) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        curr = head.next</span><br><span class="line">        succ = self.swapPairs(curr.next)</span><br><span class="line">        curr.next = head</span><br><span class="line">        head.next = succ</span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> next = head-&gt;next, ret = swapPairs(next-&gt;next);</span><br><span class="line">        next-&gt;next = head;</span><br><span class="line">        head-&gt;next = ret;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>iterative O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(next=head)</span><br><span class="line">        prev, curr = dummy, head</span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">and</span> curr.next:</span><br><span class="line">            succ = curr.next</span><br><span class="line">            curr.next = succ.next</span><br><span class="line">            succ.next = prev.next</span><br><span class="line">            prev.next = succ</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = curr.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy_head(0), *prev = &amp;dummy_head, *curr = head;</span><br><span class="line">        dummy_head.next = curr;</span><br><span class="line">        <span class="keyword">while</span> (curr &amp;&amp; curr-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> succ = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = succ-&gt;next;</span><br><span class="line">            succ-&gt;next = prev-&gt;next;</span><br><span class="line">            prev-&gt;next = succ;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>23. Merge k Sorted Lists</title>
    <url>/2020/05/31/23-Merge-k-Sorted-Lists/</url>
    <content><![CDATA[<p>归并 两两inplace merge O(nlogk) k是lists数 n是所有node数 O(1) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(a, b)</span>:</span></span><br><span class="line">            tail = dummy = ListNode()</span><br><span class="line">            <span class="keyword">while</span> a <span class="keyword">and</span> b:</span><br><span class="line">                <span class="keyword">if</span> a.val &lt; b.val:</span><br><span class="line">                    tail.next = a</span><br><span class="line">                    a = a.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tail.next = b</span><br><span class="line">                    b = b.next</span><br><span class="line">                tail = tail.next</span><br><span class="line">            tail.next = a <span class="keyword">if</span> a <span class="keyword">else</span> b</span><br><span class="line">            <span class="keyword">return</span> dummy.next</span><br><span class="line">        step, n = <span class="number">1</span>, len(lists)</span><br><span class="line">        <span class="keyword">while</span> step &lt; n:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n, step &lt;&lt; <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i + step &gt;= n: <span class="keyword">break</span></span><br><span class="line">                lists[i] = merge(lists[i], lists[i + step])</span><br><span class="line">            step &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> merge = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;</span><br><span class="line">            ListNode dummy_head(<span class="number">0</span>), *tail = &amp;dummy_head;</span><br><span class="line">            <span class="keyword">while</span> (a &amp;&amp; b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a-&gt;val &lt; b-&gt;val) &#123;</span><br><span class="line">                    tail-&gt;next = a;</span><br><span class="line">                    a = a-&gt;next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tail-&gt;next = b;</span><br><span class="line">                    b = b-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail-&gt;next = a ? a : b;</span><br><span class="line">            <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = lists.<span class="built_in">size</span>(), <span class="built_in">step</span> = <span class="number">1</span>; <span class="built_in">step</span> &lt; n; <span class="built_in">step</span> &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="built_in">step</span> &lt; n; i += (<span class="built_in">step</span> &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">                lists[i] = merge(lists[i], lists[i + <span class="built_in">step</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = lists.<span class="built_in">size</span>(), <span class="built_in">step</span> = <span class="number">1</span>; <span class="built_in">step</span> &lt; n; <span class="built_in">step</span> &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="built_in">step</span> &lt; n; i += (<span class="built_in">step</span> &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">                lists[i] = merge(lists[i], lists[i + <span class="built_in">step</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">merge</span><span class="params">(ListNode *a, ListNode *b)</span> </span>&#123;</span><br><span class="line">        ListNode dummy_head(0), *tail = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">while</span> (a &amp;&amp; b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a-&gt;val &lt; b-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = a;</span><br><span class="line">                a = a-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = b;</span><br><span class="line">                b = b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = a ? a : b;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>external sort O(nlogk) n is the number of all nodes, k is the number of linked lists</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line">ListNode.__lt__ = <span class="keyword">lambda</span> x, y: x.val &lt; y.val <span class="comment"># ListNode无法直接比较，用val替代也不行，必须重载__lt__</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        q = PriorityQueue()</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">if</span> l:</span><br><span class="line">                q.put(l)</span><br><span class="line">        tail = dummy = ListNode()</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            l = q.get()</span><br><span class="line">            tail.next = l</span><br><span class="line">            tail = l</span><br><span class="line">            l = l.next</span><br><span class="line">            <span class="keyword">if</span> l:</span><br><span class="line">                q.put(l)</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;a, <span class="keyword">const</span> <span class="keyword">auto</span> &amp;b) &#123; <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; &#125;;</span><br><span class="line">        priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, decltype(cmp)&gt; q(cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> l : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l) &#123;</span><br><span class="line">                q.push(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy_head(0), *tail = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> l = q.top(); q.pop();</span><br><span class="line">            tail-&gt;next = l;</span><br><span class="line">            tail = l;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l) &#123;</span><br><span class="line">                q.push(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
        <tag>Merging</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>21. Merge Two Sorted Lists</title>
    <url>/2020/05/31/21-Merge-Two-Sorted-Lists/</url>
    <content><![CDATA[<p>iterative O(m+n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        tail = dummy = ListNode()</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                tail.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tail.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            tail = tail.next</span><br><span class="line">        tail.next = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy_head(0), *p = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>recusive O(m+n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
        <tag>Merging</tag>
      </tags>
  </entry>
  <entry>
    <title>25. Reverse Nodes in k-Group</title>
    <url>/2020/05/31/25-Reverse-Nodes-in-k-Group/</url>
    <content><![CDATA[<p>recursive O(n)<br>这个更清楚</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            p = p.next</span><br><span class="line">        curr, prev = head, self.reverseKGroup(p, k)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            succ = curr.next</span><br><span class="line">            curr.next = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = succ</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; k &amp;&amp; p; ++i) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> prev = reverseKGroup(p, k), curr = head;</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> succ = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = succ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">int</span> t = k; <span class="comment">// 这里不能用k因为后边还得用</span></span><br><span class="line">        <span class="keyword">while</span> (t-- &gt; <span class="number">0</span> &amp;&amp; p) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= <span class="number">0</span>) <span class="keyword">return</span> head; <span class="comment">// 这里检查尾部较短的部分，必须统计t因为p为nullptr时也可能需要reverse，并且t == 0也是有可能的因为t最后还要--</span></span><br><span class="line">        <span class="keyword">auto</span> prev = reverseKGroup(p, k), curr = head; <span class="comment">// 一个正常的翻转链表操作</span></span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> succ = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = succ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; k &amp;&amp; p; ++i, p = p-&gt;next);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> prev = reverseKGroup(p, k), curr = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> succ = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = succ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>26. Remove Duplicates from Sorted Array</title>
    <url>/2020/05/31/26-Remove-Duplicates-from-Sorted-Array/</url>
    <content><![CDATA[<p>O(n) time</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> nums[i] != x:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                nums[i] = x</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[j]) &#123;</span><br><span class="line">                nums[++i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用这个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">1</span> <span class="keyword">or</span> nums[i - <span class="number">1</span>] &lt; x:</span><br><span class="line">                nums[i] = x</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">1</span> || x &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[i++] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>快慢指针解法O(n)<br><a href="http://www.cnblogs.com/grandyang/p/4329128.html" target="_blank" rel="noopener">题解</a><br>快指针fast遍历整个数组，遇到和slow不相同的数，就把nums[fast]赋给slow的下一个，同时慢指针slow向前一步</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[last] != nums[i]) &#123;</span><br><span class="line">                nums[++last] = nums[i]; <span class="comment">// 先加加再写就可以了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last + <span class="number">1</span>; <span class="comment">// 因为last是下标，所以要返回last + 1才是个数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>朴素解法O(n)<br>在每个位置从当前位置开始向后找到第一个比当前位置之前一个数更大的数赋给当前位置，每次向后找的时候就从之前找到的那个更大的数的位置继续向后找即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, j = i;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123; ++j; &#125; <span class="keyword">while</span> (j &lt; n &amp;&amp; nums[j] &lt;= nums[i - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (j &lt; n) nums[i] = nums[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = i; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hare and tortoise</tag>
      </tags>
  </entry>
  <entry>
    <title>27. Remove Element</title>
    <url>/2020/05/31/27-Remove-Element/</url>
    <content><![CDATA[<p>O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> x != val:</span><br><span class="line">                nums[i] = x</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x != val) &#123;</span><br><span class="line">                nums[i++] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">                swap(nums[i], nums[--n]);</span><br><span class="line">                nums.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hare and tortoise</tag>
      </tags>
  </entry>
  <entry>
    <title>28. Implement strStr()</title>
    <url>/2020/05/31/28-Implement-strStr/</url>
    <content><![CDATA[<p>rolling hash O(h + n)<br>hash = (hash * base + ord(c)) % modulus<br>modulus 必须是一个大质数（比 ord(c)要大，否则 C++会算出负数，Python 不会）来避免过多的 collision<br>必须要解决 hash collision，反例<br>“gytisyz”<br>“aaaaaab”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        h, n = len(haystack), len(needle)</span><br><span class="line">        <span class="keyword">if</span> h &lt; n: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        highest_power, hh, nh = <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        M, B = <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>, <span class="number">256</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            highest_power = (highest_power * B) % M</span><br><span class="line">            hh = (hh * B + ord(haystack[i])) % M</span><br><span class="line">            nh = (nh * B + ord(needle[i])) % M</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(h - n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">1</span>:</span><br><span class="line">                hh = (hh * B - ord(haystack[i - <span class="number">1</span>]) * highest_power + ord(haystack[i + n - <span class="number">1</span>])) % M</span><br><span class="line">            <span class="keyword">if</span> hh == nh:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">if</span> haystack[i + j] != needle[j]:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = haystack.length(), n = needle.length();</span><br><span class="line">        <span class="keyword">long</span> M = INT_MAX, B = <span class="number">256</span>; <span class="comment">// INT_MAX是质数！</span></span><br><span class="line">        <span class="keyword">if</span> (h &lt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> highest_power = <span class="number">1</span>, hh = <span class="number">0</span>, nh = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            highest_power = (highest_power * B) % M;</span><br><span class="line">            nh = (nh * B + needle[i]) % M;</span><br><span class="line">            hh = (hh * B + haystack[i]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h - n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                hh = (hh * B - (haystack[i - <span class="number">1</span>]) * highest_power + haystack[i + n - <span class="number">1</span>]) % M; <span class="comment">// 这里highest_power是B的n次方，因为先整体左移再减高位，如果先减高位再整体左移就是n-1次方了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hh == nh) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (haystack[i + j] != needle[j]) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>O(nh)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> haystack <span class="keyword">and</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        h, n = len(haystack), len(needle)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(h - n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> haystack[i:i + n] == needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = needle.length(), h = haystack.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= h - n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack[i + j] != needle[j]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Rolling hash</tag>
      </tags>
  </entry>
  <entry>
    <title>29. Divide Two Integers</title>
    <url>/2020/05/31/29-Divide-Two-Integers/</url>
    <content><![CDATA[<p>binary search O(log(dividend/divisor)) time<br>相当于把商转成二进制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class="line">        dd, dr = abs(dividend), abs(divisor)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> dd &gt;= dr:</span><br><span class="line">            t, cnt = dr, <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> dd &gt;= (t &lt;&lt; <span class="number">1</span>):</span><br><span class="line">                t &lt;&lt;= <span class="number">1</span></span><br><span class="line">                cnt &lt;&lt;= <span class="number">1</span></span><br><span class="line">            dd -= t</span><br><span class="line">            res += cnt</span><br><span class="line">        <span class="keyword">if</span> (dividend ^ divisor) &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -res</span><br><span class="line">        <span class="keyword">return</span> min(res, (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># return [res, (1 &lt;&lt; 31) - 1][res &gt; (1 &lt;&lt; 31) - 1] # 相当于array[0]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> dd = <span class="built_in">labs</span>(dividend), dr = <span class="built_in">labs</span>(divisor), res = <span class="number">0</span>; <span class="comment">// 这里要用labs因为abs(INT_MIN)还是INT_MIN</span></span><br><span class="line">        <span class="keyword">while</span> (dd &gt;= dr) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = dr, cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (dd &gt;= (t &lt;&lt; <span class="number">1</span>)) &#123; <span class="comment">// 这里是要避免1/1这个case死循环</span></span><br><span class="line">                t &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                cnt &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dd -= t;</span><br><span class="line">            res += cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((dividend ^ divisor) &lt; <span class="number">0</span>) <span class="keyword">return</span> -res;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(res, (<span class="keyword">long</span>)INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isNeg = (dividend ^ divisor) &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> dd = <span class="built_in">abs</span>((<span class="keyword">long</span>)dividend), dr = <span class="built_in">abs</span>((<span class="keyword">long</span>)divisor);</span><br><span class="line">        <span class="keyword">if</span> (dr == <span class="number">0</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>, v = <span class="number">0</span>, shift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> changed = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            dd -= (v &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            res += (shift &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            v = dr;</span><br><span class="line">            shift = <span class="number">1</span>;</span><br><span class="line">            changed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (v &lt;= dd) &#123;</span><br><span class="line">                v &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                shift &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (changed);</span><br><span class="line">        <span class="keyword">if</span> (!isNeg &amp;&amp; res &gt;= INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">return</span> isNeg ? -res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isNeg = (dividend ^ divisor) &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> dd = <span class="built_in">abs</span>((<span class="keyword">long</span>)dividend), dr = <span class="built_in">abs</span>((<span class="keyword">long</span>)divisor);</span><br><span class="line">        <span class="keyword">if</span> (dr == <span class="number">0</span>) <span class="keyword">return</span> INT_MAX; <span class="comment">// x/0</span></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> v = dr;</span><br><span class="line">            <span class="keyword">long</span> shift = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">bool</span> changed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (v &lt;= dd) &#123;</span><br><span class="line">                v &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                shift &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                dd -= (v &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                res += (shift &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (!isNeg &amp;&amp; res &gt;= INT_MAX) <span class="keyword">return</span> INT_MAX; <span class="comment">// INT_MIN/-1</span></span><br><span class="line">        <span class="keyword">return</span> isNeg ? -res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Integer</tag>
      </tags>
  </entry>
  <entry>
    <title>3. Longest Substring Without Repeating Characters</title>
    <url>/2020/05/30/3-Longest-Substring-Without-Repeating-Characters/</url>
    <content><![CDATA[<p>O(n) 用hashmap维护下标<br>l表示上一个发生重复的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        res, l = <span class="number">0</span>, <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> r, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            l = max(l, d.get(c, <span class="number">-1</span>))</span><br><span class="line">            res = max(res, r - l)</span><br><span class="line">            d[c] = r</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        vector&lt;int&gt; f(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        int n = s.length();</span><br><span class="line">        int res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int r = <span class="number">0</span>, l = <span class="number">-1</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            l = max(l, f[s[r]]); // 更新l</span><br><span class="line">            f[s[r]] = r; // 更新表</span><br><span class="line">            res = max(res, r - l); // 更新res</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">hm</span><span class="params">(<span class="number">256</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            start = <span class="built_in">max</span>(start, hm[s[i]]); <span class="comment">// 一定要用max更新start，否则见反例abba</span></span><br><span class="line">            hm[s[i]] = i;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n) two pointers</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> hashmap[<span class="number">256</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = i; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; !hashmap[s[j]]) &#123;</span><br><span class="line">                hashmap[s[j++]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, j - i);</span><br><span class="line">            hashmap[s[i]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
      </tags>
  </entry>
  <entry>
    <title>30. Substring with Concatenation of All Words</title>
    <url>/2020/05/31/30-Substring-with-Concatenation-of-All-Words/</url>
    <content><![CDATA[<p>sliding window O(n * l) time O(m * l) space<br>这道题主要思路是把每个单词当成单个字母来处理，用sliding window找出所有符合要求的结果，即对于s[0:10)来说，假设words的每个单词长度为3，那么第一次处理s[0:3) s[3:6) s[6:9) s[9:10)，第二次处理s[1:4) s[4:7) s[7:10)，第三次处理s[2:5) s[5:8) s[8:10)<br>跟<a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. Minimum Window Substring</a>思路接近<br>跟<a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. Find All Anagrams in a String</a>解法一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span><span class="params">(self, s: str, words: List[str])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> words: <span class="keyword">return</span> []</span><br><span class="line">        d = defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            d[w] += <span class="number">1</span></span><br><span class="line">        n, m, l = len(s), len(words), len(words[<span class="number">0</span>])</span><br><span class="line">        total, res = m * l, []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            td, cnt = d.copy(), m</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n, l): <span class="comment"># 应该是j + l &lt;= n但是python里字符串切片越界也不影响</span></span><br><span class="line">                t = s[j:j + l]</span><br><span class="line">                td[t] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> td[t] &gt;= <span class="number">0</span>:</span><br><span class="line">                    cnt -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j - total &gt;= i:</span><br><span class="line">                    t = s[j - total:j - total + l]</span><br><span class="line">                    td[t] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> td[t] &gt; <span class="number">0</span>:</span><br><span class="line">                        cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                    res.append(j - total + l)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (words.empty() || s.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), m = words.<span class="built_in">size</span>(), l = words[<span class="number">0</span>].length(), total = m * l;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : words) &#123;</span><br><span class="line">            ++hm[w];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = hm;</span><br><span class="line">            <span class="keyword">int</span> cnt = m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j + l &lt;= n; j += l) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--t[s.substr(j, l)] &gt;= <span class="number">0</span>) &#123; <span class="comment">// 从0减小成非0不更新cnt</span></span><br><span class="line">                    --cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - total &gt;= i &amp;&amp; ++t[s.substr(j - total, l)] &gt; <span class="number">0</span>) &#123; <span class="comment">// cnt只有在大于等于0以上更新才有用，从非0变成0不贡献频数所以不更新cnt</span></span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.push_back(j - total + l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (words.empty() || s.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), m = words.<span class="built_in">size</span>(), l = words[<span class="number">0</span>].length(), total = m * l;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : words) &#123;</span><br><span class="line">            ++hm[w];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = hm;</span><br><span class="line">            <span class="keyword">int</span> cnt = m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j + l &lt;= n; j += l) &#123;</span><br><span class="line">                <span class="keyword">auto</span> w = s.substr(j, l);</span><br><span class="line">                <span class="keyword">if</span> (t.count(w) &amp;&amp; t[w]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    --cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= total) &#123;</span><br><span class="line">                    w = s.substr(j - total, l);</span><br><span class="line">                    <span class="keyword">if</span> (t.count(w) &amp;&amp; ++t[w] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        ++cnt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.push_back(j - total + l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一点优化：如果当前统计的单词不存在则sliding window直接跳过该单词开始新的统计</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (words.empty() || s.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), m = words.<span class="built_in">size</span>(), len = words[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hm; <span class="comment">// 先统计单词频数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : words) &#123;</span><br><span class="line">            ++hm[w];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123; <span class="comment">// trick在扫描方式上，假设单词长度为3，那么第一次扫0369第二次147第三次258</span></span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;&gt; t; <span class="comment">// 每个queue放每个有效单词的出现位置</span></span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, b = j; j + len &lt;= n; j += len) &#123;</span><br><span class="line">                <span class="keyword">auto</span> w = s.substr(j, len);</span><br><span class="line">                <span class="keyword">if</span> (hm.count(w) == <span class="number">0</span>) &#123; <span class="comment">// 如果当前位置单词不存在，之前统计全部清空</span></span><br><span class="line">                    t.<span class="built_in">clear</span>();</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                    b = j + len;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t[w].<span class="built_in">size</span>() &lt; hm[w]) &#123; <span class="comment">// 如果当前位置单词存在且个数未超过上限</span></span><br><span class="line">                    t[w].push(j);</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果当前位置单词存在但是个数已达上限，清除当前位置单词在窗口内最早出现位置之前的所有单词</span></span><br><span class="line">                    b = t[w].front() + len;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;p : t) &#123;</span><br><span class="line">                        <span class="keyword">while</span> (!p.second.empty() &amp;&amp; p.second.front() &lt; b) &#123;</span><br><span class="line">                            --cnt;</span><br><span class="line">                            p.second.pop();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    t[w].push(j);</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt == m) &#123; <span class="comment">// 如果找到符合要求的单词组合</span></span><br><span class="line">                    res.push_back(b);</span><br><span class="line">                    --cnt;</span><br><span class="line">                    t[s.substr(b, len)].pop();</span><br><span class="line">                    b += len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>33. Search in Rotated Sorted Array</title>
    <url>/2020/06/01/33-Search-in-Rotated-Sorted-Array/</url>
    <content><![CDATA[<p>binary search O(logn)<br>先判断左半边数多还是右半边数多，再对每一种情况分类讨论</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r):</span><br><span class="line">            m = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">elif</span> nums[m] &gt; nums[r]:</span><br><span class="line">                <span class="keyword">if</span> nums[l] &lt;= target &lt; nums[m]:</span><br><span class="line">                    r = m - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[m] &lt; target &lt;= nums[r]:</span><br><span class="line">                    l = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123; <span class="comment">// 这道题是要找数，所以要=</span></span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[mid]) &#123; <span class="comment">// 找到直接返回</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[r]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123; <span class="comment">// 检查是否在单调区间</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>31. Next Permutation</title>
    <url>/2020/05/31/31-Next-Permutation/</url>
    <content><![CDATA[<p>O(n) time 举例021找到第一个顺序对02，说明2开始已经是全逆序了，不可能再找到新的排列，所以只能找2后面的一个数和0交换，从后往前找到第一个比0大的是1，说明1以后的数都不比0大，不可能跟0交换，把1跟0交换以后，得到了一个新的排列，这时要将从2开始的全逆序翻转，即021 –&gt; 120 –&gt; 102</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n, x = len(nums), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i + <span class="number">1</span>]:</span><br><span class="line">                x = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums.reverse()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, x, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[x]:</span><br><span class="line">                nums[x], nums[i] = nums[i], nums[x]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># nums[x + 1:] = reversed(nums[x + 1:])</span></span><br><span class="line">        nums[x + <span class="number">1</span>:] = nums[n - <span class="number">1</span>:x:<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># nums[x + 1:] = nums[x + 1:][::-1]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums.reverse()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>, i, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[i]:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        l, r = i + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] &gt;= nums[i]) --i;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            reverse(<span class="built_in">begin</span>(nums), <span class="built_in">end</span>(nums));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[j] &lt;= nums[i - <span class="number">1</span>]) --j;</span><br><span class="line">        swap(nums[i - <span class="number">1</span>], nums[j]);</span><br><span class="line">        reverse(<span class="built_in">begin</span>(nums) + i, <span class="built_in">end</span>(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i1 = l, i2 = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt; l; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">                i1 = i - <span class="number">1</span>;</span><br><span class="line">                i2 = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == i2) &#123;</span><br><span class="line">            reverse(<span class="built_in">begin</span>(nums), <span class="built_in">end</span>(nums));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i3 = i2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= i2; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i1]) &#123;</span><br><span class="line">                i3 = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i1], nums[i3]);</span><br><span class="line">        reverse(<span class="built_in">begin</span>(nums) + i2, <span class="built_in">end</span>(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        nextPerm(nums, <span class="number">0</span>, n - <span class="number">1</span>); <span class="comment">// 这里用的是左右闭区间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">nextPerm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= l) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果元素个数为0或者1，则没有下一个排列</span></span><br><span class="line">        <span class="keyword">int</span> idx1 = l, idx2 = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r - <span class="number">1</span>; i &gt;= l; --i) &#123; <span class="comment">// 从后往前找到第一个相邻两元素后面的比前面大的</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                idx1 = i;</span><br><span class="line">                idx2 = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx1 == idx2) &#123; <span class="comment">// 如果找不到，说明已经逆序，返回一个初始正序</span></span><br><span class="line">            reverse(nums.<span class="built_in">begin</span>() + l, nums.<span class="built_in">begin</span>() + r + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx3 = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l; --i) &#123; <span class="comment">// 从后往前找到第一个比之前找到的较小元素大的元素，与之交换</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[idx1]) &#123;</span><br><span class="line">                idx3 = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[idx1], nums[idx3]);</span><br><span class="line">        reverse(nums.<span class="built_in">begin</span>() + idx2, nums.<span class="built_in">begin</span>() + r + <span class="number">1</span>); <span class="comment">// 将从之前找到的较大元素到数组尾的所有元素翻转</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Permutation</tag>
      </tags>
  </entry>
  <entry>
    <title>32. Longest Valid Parentheses</title>
    <url>/2020/06/01/32-Longest-Valid-Parentheses/</url>
    <content><![CDATA[<p>stack O(n) time O(n) space<br>所有匹配的括号都出栈了，栈里剩下的都是匹配不上的，所以两个匹配不上的括号之间的就是匹配上的括号串，统计最长的可以匹配上的括号串的长度即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">-1</span>&#125;; <span class="comment">// 开始加入-1方便后面计算，比如"()()())"</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123; <span class="comment">// 如果是"("，直接把下标入栈</span></span><br><span class="line">                v.push_back(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (v.back() != <span class="number">-1</span> &amp;&amp; s[v.back()] == <span class="string">'('</span>) &#123; <span class="comment">// 如果是")"，并且栈不为『空』或者栈顶是"("，证明有正确的匹配，将栈顶的"("的下标出栈</span></span><br><span class="line">                    v.pop_back();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则证明是一个孤立无法匹配的")"，将下标入栈</span></span><br><span class="line">                    v.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v.push_back(n); <span class="comment">// 最后入栈一个结尾长度下标，方便计算，比如")()()"</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, v[i] - v[i - <span class="number">1</span>] - <span class="number">1</span>); <span class="comment">// 只需要检查前后两个不匹配的括号之前的距离便可以找到最长的合法匹配的括号的长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>进一步优化，不需要最后再扫一遍，每次找到一个合法匹配就可以直接更新res</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        stk, res = [<span class="number">-1</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'('</span>:</span><br><span class="line">                stk.append(i)</span><br><span class="line">            <span class="keyword">elif</span> stk[<span class="number">-1</span>] &gt;= <span class="number">0</span> <span class="keyword">and</span> s[stk[<span class="number">-1</span>]] == <span class="string">'('</span>:</span><br><span class="line">                stk.pop()</span><br><span class="line">                res = max(res, i - stk[<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stk.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk&#123;&#123;<span class="number">-1</span>&#125;&#125;; <span class="comment">// 开始加入-1方便后面计算，比如"()()())"</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123; <span class="comment">// 如果是"("，直接把下标入栈</span></span><br><span class="line">                stk.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stk.top() != <span class="number">-1</span> &amp;&amp; s[stk.top()] == <span class="string">'('</span>) &#123; <span class="comment">// 如果是")"，并且栈不为『空』或者栈顶是"("，证明有正确的匹配，将栈顶的"("的下标出栈</span></span><br><span class="line">                stk.pop(); <span class="comment">// 一定要先出栈再更新res</span></span><br><span class="line">                res = <span class="built_in">max</span>(res, i - stk.top()); <span class="comment">// 当前是一个合法的匹配，更新res</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则证明是一个孤立无法匹配的")"，将下标入栈</span></span><br><span class="line">                stk.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>34. Find First and Last Position of Element in Sorted Array</title>
    <url>/2020/06/01/34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/</url>
    <content><![CDATA[<p>O(logn) time</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(b, e, t)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> b &lt; e:</span><br><span class="line">                m = b + (e - b) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[m] &lt; t:</span><br><span class="line">                    b = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    e = m</span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line">        n = len(nums)</span><br><span class="line">        l = find(<span class="number">0</span>, n, target)</span><br><span class="line">        <span class="keyword">if</span> l == n <span class="keyword">or</span> nums[l] != target:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> [l, find(l + <span class="number">1</span>, n, target + <span class="number">1</span>) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = lb(nums, <span class="number">0</span>, n, target);</span><br><span class="line">        <span class="keyword">if</span> (i == n || nums[i] != target) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;i, lb(nums, i, n, target + <span class="number">1</span>) - <span class="number">1</span>&#125;; <span class="comment">// 找大一号的数即可，且可以从下界找起</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> lb = lower_bound(<span class="built_in">begin</span>(nums), <span class="built_in">end</span>(nums), target);</span><br><span class="line">        <span class="keyword">if</span> (lb == <span class="built_in">end</span>(nums) || *lb != target) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> ub = upper_bound(<span class="built_in">begin</span>(nums), <span class="built_in">end</span>(nums), target);</span><br><span class="line">        <span class="keyword">return</span> &#123;lb - <span class="built_in">begin</span>(nums), ub - <span class="number">1</span> - <span class="built_in">begin</span>(nums)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>35. Search Insert Position</title>
    <url>/2020/06/01/35-Search-Insert-Position/</url>
    <content><![CDATA[<p>O(logn) time<br>找lower_bound</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) <span class="comment"># 注意直接用左闭右开！！</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = m</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n; <span class="comment">// 直接用左闭右开</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[m]) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[m]) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>36. Valid Sudoku</title>
    <url>/2020/06/01/36-Valid-Sudoku/</url>
    <content><![CDATA[<p>O(1) time O(1) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">        v = [[<span class="literal">False</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        h = [[<span class="literal">False</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        b = [[<span class="literal">False</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        <span class="comment"># v = [[False] * 10 for _ in range(9)]</span></span><br><span class="line">        <span class="comment"># h, b = deepcopy(v), deepcopy(v)</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                x = board[r][c]</span><br><span class="line">                <span class="keyword">if</span> x != <span class="string">'.'</span>:</span><br><span class="line">                    x = int(x) <span class="comment"># 巧妙！</span></span><br><span class="line">                    <span class="keyword">if</span> v[c][x] <span class="keyword">or</span> h[r][x] <span class="keyword">or</span> b[r // <span class="number">3</span> * <span class="number">3</span> + c // <span class="number">3</span>][x]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    v[c][x] = h[r][x] = b[r // <span class="number">3</span> * <span class="number">3</span> + c // <span class="number">3</span>][x] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>用bitset替代hashtable遍历找重复即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        vector&lt;bitset&lt;9&gt;&gt; h(9), v(9), s(9);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r(<span class="number">0</span>); r &lt; <span class="number">9</span>; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c(<span class="number">0</span>); c &lt; <span class="number">9</span>; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[r][c] == <span class="string">'.'</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> x = board[r][c] - <span class="string">'1'</span>;</span><br><span class="line">                <span class="keyword">if</span> (h[r][x] || v[c][x] || s[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][x]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                h[r][x] = v[c][x] = s[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][x] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>5. Longest Palindromic Substring</title>
    <url>/2020/05/30/5-Longest-Palindromic-Substring/</url>
    <content><![CDATA[<p>manacher’s algorithm可以O(n)但是不会<br>O(n<sup>2</sup>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(l, r)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span> &lt;= l <span class="keyword">and</span> r &lt; len(s) <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> l + <span class="number">1</span>, r - <span class="number">1</span></span><br><span class="line">        ll, rr = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            l, r = find(i, i)</span><br><span class="line">            <span class="keyword">if</span> r - l &gt; rr - ll: ll, rr = l, r</span><br><span class="line">            l, r = find(i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> r - l &gt; rr - ll: ll, rr = l, r</span><br><span class="line">        <span class="keyword">return</span> s[ll:rr + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        ll, rr = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            l, r = self.find(s, i, i)</span><br><span class="line">            <span class="keyword">if</span> r - l &gt; rr - ll: ll, rr = l, r</span><br><span class="line">            l, r = self.find(s, i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> r - l &gt; rr - ll: ll, rr = l, r</span><br><span class="line">        <span class="keyword">return</span> s[ll:rr + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, s, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> &lt;= l <span class="keyword">and</span> r &lt; len(s) <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l + <span class="number">1</span>, r - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>因为回文串是对称的，所以枚举所有可能的对称轴<br>对称轴可能是某个字符，也可能是两个字符中间，填充#符号来避免奇偶问题<br>枚举每个可能的对称轴，从对称轴开始向左右两边比较字符直到找到不一样的或者越界，然后左右指针均回退一个（回退以后一定都是指向#符号），更新全局左右指针<br>最后重建原字符串里的最长回文子字符串<br>O(n^2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        s = <span class="string">'#'</span> + <span class="string">'#'</span>.join(list(s)) + <span class="string">'#'</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        ll, rr = n, n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            l, r = i - <span class="number">1</span>, i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span> &lt;= l <span class="keyword">and</span> r &lt; n <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> r - l &gt; rr - ll: ll, rr = l + <span class="number">1</span>, r - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[ll + <span class="number">1</span> : rr : <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">"#"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            str += c;</span><br><span class="line">            str += <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = str.length(), ll = <span class="number">0</span>, rr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">0</span> &lt;= l &amp;&amp; r &lt; n &amp;&amp; str[l] == str[r]) &#123;</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">            <span class="keyword">if</span> (r - l &gt; rr - ll) &#123;</span><br><span class="line">                ll = l;</span><br><span class="line">                rr = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ll + <span class="number">1</span>; i &lt;= rr; i += <span class="number">2</span>) &#123;</span><br><span class="line">            res += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = split(s);</span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i, r = i;</span><br><span class="line">            <span class="keyword">while</span> (str[l] == str[r] &amp;&amp; l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n) &#123;</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">            <span class="keyword">if</span> (r - l &gt; right - left) &#123;</span><br><span class="line">                left = l;</span><br><span class="line">                right = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reconstruct(str, left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">split</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">"#"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : s) &#123;</span><br><span class="line">            str += c;</span><br><span class="line">            str += <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reconstruct</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt; r; i += <span class="number">2</span>) &#123;</span><br><span class="line">            str += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>memo+recursive<br>f(l, r)表示s[l:r]中最长的回文串的长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), b = <span class="number">0</span>;</span><br><span class="line">        m.resize(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">int</span> mx = f(s, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = l + mx - <span class="number">1</span>; <span class="number">0</span> &lt;= r &amp;&amp; r &lt; n; ++l, ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[l][r] == mx) <span class="keyword">return</span> s.substr(l, mx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (m[l][r] &gt; <span class="number">0</span>) <span class="keyword">return</span> m[l][r];</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> m[l][r] = <span class="number">1</span>;</span><br><span class="line">        m[l][r] = <span class="built_in">max</span>(f(s, l, r - <span class="number">1</span>), f(s, l + <span class="number">1</span>, r));</span><br><span class="line">        <span class="keyword">if</span> (s[l] == s[r]) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = f(s, l + <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (l + t + <span class="number">1</span> == r) &#123;</span><br><span class="line">                m[l][r] = <span class="built_in">max</span>(m[l][r], r + <span class="number">1</span> - l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[l][r];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Brute force</tag>
        <tag>Implementation</tag>
        <tag>Palindrome</tag>
      </tags>
  </entry>
  <entry>
    <title>6. ZigZag Conversion</title>
    <url>/2020/05/30/6-ZigZag-Conversion/</url>
    <content><![CDATA[<p>O(n) time O(n) space<br>用辅助字符串组来保存每一行的字符串，通过调整step来决定是从上往下放字符还是从下往上放字符，当指针指向第一行则从上往下，当指针指向最后一行则从下往上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s: str, numRows: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> numRows &lt;= <span class="number">1</span> <span class="keyword">or</span> numRows &gt;= len(s): <span class="keyword">return</span> s</span><br><span class="line">        v = [<span class="string">''</span>] * numRows</span><br><span class="line">        <span class="comment"># v = ['' for i in range(numRows)]</span></span><br><span class="line">        i, step = <span class="number">0</span>, <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == numRows - <span class="number">1</span>:</span><br><span class="line">                step = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                step = <span class="number">1</span></span><br><span class="line">            v[i] += c</span><br><span class="line">            i += step</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(v)</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">v</span><span class="params">(numRows)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, <span class="built_in">step</span> = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == numRows - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">step</span> = <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">step</span> = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v[i] += c;</span><br><span class="line">            i += <span class="built_in">step</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;str : v) &#123;</span><br><span class="line">            res += str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>8. String to Integer (atoi)</title>
    <url>/2020/05/30/8-String-to-Integer-atoi/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str: str)</span> -&gt; int:</span></span><br><span class="line">        res, MAX, MIN = <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>, -(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)</span><br><span class="line">        str = str.lstrip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> str: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        sign, i = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> str[<span class="number">0</span>] <span class="keyword">in</span> <span class="string">'+-'</span>:</span><br><span class="line">            sign, i = <span class="number">44</span> - ord(str[<span class="number">0</span>]), <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(i, len(str)):</span><br><span class="line">            <span class="keyword">if</span> res &gt; MAX <span class="keyword">or</span> <span class="keyword">not</span> str[i].isdigit(): <span class="keyword">break</span></span><br><span class="line">            res = res * <span class="number">10</span> + int(str[i])</span><br><span class="line">        res *= sign</span><br><span class="line">        <span class="keyword">if</span> res &lt; MIN: <span class="keyword">return</span> MIN</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res &lt;= MAX <span class="keyword">else</span> MAX</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (str[b] == <span class="string">' '</span>) &#123;</span><br><span class="line">            ++b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[b] == <span class="string">'+'</span> || str[b] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            sign = <span class="number">44</span> - str[b];</span><br><span class="line">            ++b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; n &amp;&amp; <span class="built_in">isdigit</span>(str[i]) &amp;&amp; res &lt;= INT_MAX; ++i) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + str[i] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res *= sign;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> res &lt;= INT_MAX ? res : INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">// 去掉开始的空格</span></span><br><span class="line">        <span class="keyword">while</span> (str[b] == <span class="string">' '</span>) &#123;</span><br><span class="line">            ++b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[b] == <span class="string">'-'</span> || str[b] == <span class="string">'+'</span>) &#123; <span class="comment">// 判断符号，注意b++</span></span><br><span class="line">            <span class="keyword">if</span> (str[b++] == <span class="string">'-'</span>) sign = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; n &amp;&amp; <span class="built_in">isdigit</span>(str[i]) &amp;&amp; res &lt;= INT_MAX; ++i) &#123; <span class="comment">// 三个条件：不能越界、必须是数字、值不能超过INT_MAX（INT_MIN可行）</span></span><br><span class="line">            res = res * <span class="number">10</span> + str[i] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res *= sign;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">while</span> (b &lt; n &amp;&amp; str[b] == <span class="string">' '</span>) &#123;</span><br><span class="line">            ++b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> ispos = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[b] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            ispos = <span class="literal">false</span>;</span><br><span class="line">            ++b;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[b] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            ++b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; n &amp;&amp; res &lt;= INT_MAX &amp;&amp; <span class="string">'0'</span> &lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">'9'</span>; ++i) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + str[i] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ispos ? <span class="built_in">min</span>((<span class="keyword">long</span>)INT_MAX, res) : <span class="built_in">max</span>((<span class="keyword">long</span>)INT_MIN, -res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Integer</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>9. Palindrome Number</title>
    <url>/2020/05/30/9-Palindrome-Number/</url>
    <content><![CDATA[<p>O(1) time O(1) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x % <span class="number">10</span> == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; y:</span><br><span class="line">            y = y * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> x == y <span class="keyword">or</span> x == y // <span class="number">10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x != <span class="number">0</span> &amp;&amp; x % <span class="number">10</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 负数和结尾是0的正数都不合法</span></span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; y) &#123;</span><br><span class="line">            y = y * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == y || x == y / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Integer</tag>
        <tag>Palindrome</tag>
      </tags>
  </entry>
  <entry>
    <title>7. Reverse Integer</title>
    <url>/2020/05/30/7-Reverse-Integer/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        res, MAX = <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">        sign = <span class="number">-1</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        x = abs(x)</span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> res &gt; MAX: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> res * sign</span><br></pre></td></tr></table></figure>
<p>这道题不需要保存负号，直接转即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (res &lt; INT_MIN || res &gt; INT_MAX) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 只要invalid就返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == INT_MIN || x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = x &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        x = <span class="built_in">abs</span>(x);</span><br><span class="line">        <span class="built_in">string</span> s = to_string(x);</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.back() == <span class="string">'0'</span>) s.pop_back();</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> rit = s.rbegin(); rit != s.rend(); ++rit) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + *rit - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (res &gt; INT_MAX) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Integer</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>How to bind custom domain to github page</title>
    <url>/2018/07/30/How-to-bind-custom-domain-to-github-page/</url>
    <content><![CDATA[<h3 id="CName-file"><a href="#CName-file" class="headerlink" title="CName file"></a>CName file</h3><p>Github uses a file called CNAME to redirect your site. If you read the official<br>guide it says the file must be saved under the root directory in the master branch. But remember that <strong>for us the source branch is where the raw material is and master branch is generated when you deploy</strong>. So if you put something in the master branch it will be overwritten next time you deploy your site.</p>
<a id="more"></a>

<p>Create a file called CNAME (all caps, no extension) under the <strong>source directory</strong> in the source branch and write your domain name into that file. Replace <em>mydomain.com</em> with your own domain.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="built_in">source</span>/</span><br><span class="line">$ <span class="built_in">echo</span> mydomain.com &gt; CNAME</span><br></pre></td></tr></table></figure>

<h3 id="GoDaddy-setup"><a href="#GoDaddy-setup" class="headerlink" title="GoDaddy setup"></a>GoDaddy setup</h3><ol>
<li><p>ping username.github.io and obtain your ip address</p>
</li>
<li><p>add two DNS entries</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>Type</th>
<th>Host</th>
<th>Points to</th>
<th>TTL</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>@</td>
<td>github IP</td>
<td>1 hour</td>
</tr>
<tr>
<td>CNAME</td>
<td>username.github.io</td>
<td>@</td>
<td>1 hour</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>How to define an alias in fish shell</title>
    <url>/2020/05/18/How-to-define-an-alias-in-fish-shell/</url>
    <content><![CDATA[<p>In fish shell, type the following commands:</p>
<a id="more"></a>

<ul>
<li><p>use alias<br>define alias in .config/fish/config.fish</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> foo <span class="string">'bar'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>use function</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">function</span> foo</span><br><span class="line">      <span class="built_in">command</span> <span class="built_in">echo</span> <span class="string">'foo was here'</span> <span class="variable">$argv</span></span><br><span class="line">  end</span><br><span class="line">$ funcsave foo</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>You should see a file <strong>foo.fish</strong> under <strong>~/.config/fish/functions/</strong></p>
]]></content>
      <categories>
        <category>fish shell</category>
      </categories>
      <tags>
        <tag>fish shell</tag>
      </tags>
  </entry>
  <entry>
    <title>How to check endianness</title>
    <url>/2020/05/18/How-to-check-endianness/</url>
    <content><![CDATA[<p>big-endian:</p>
<p>低地址 -&gt; 高地址</p>
<a id="more"></a>

<p>0x12345678</p>
<p>高位字节 -&gt; 低位字节</p>
<p>更具有可读性</p>
<p>Java一律是big-endian，与平台无关</p>
<hr>
<p>little-endian:</p>
<p>高地址 -&gt; 低地址</p>
<p>0x12345678</p>
<p>高位字节 -&gt; 低位字节</p>
<p>x86是little-endian</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)&amp;a;</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="number">0x78</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"little"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"big"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer architecture</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Computer architecture</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown心得</title>
    <url>/2020/05/16/Markdown%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<ol>
<li>表格如果想正确显示一定要与前面的正文隔两行</li>
</ol>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Induction variable in Python&#39;s for loop</title>
    <url>/2020/05/31/Induction-variable-in-Python-s-for-loop/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    print(i) <span class="comment"># 0 1 2 3</span></span><br><span class="line"></span><br><span class="line">print(i) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        i += <span class="number">2</span></span><br><span class="line">    print(i) <span class="comment"># 2 1 4 3 6 5 5</span></span><br></pre></td></tr></table></figure>

<p>Conclusion:</p>
<ul>
<li>induction variable的scope不仅限于for loop</li>
<li>不管for loop内部对induction variable如何修改，for loop本身还会对其重新赋值</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/07/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>practice of using move and forward</title>
    <url>/2020/05/17/practice-of-using-move-and-forward/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(Widget&amp;&amp; rhs)</span><br><span class="line">    : name(<span class="built_in">std</span>::<span class="built_in">move</span>(rhs.name))</span><br><span class="line">    , p(<span class="built_in">std</span>::<span class="built_in">move</span>(rhs.p)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SomeDataStructure&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = <span class="built_in">std</span>::forward&lt;T&gt;(newName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">move</span>(w); <span class="comment">// DO NOT DO THIS!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget w1;</span><br><span class="line">Widget w2 = <span class="built_in">std</span>::<span class="built_in">move</span>(w1); <span class="comment">// w1 is "empty"</span></span><br><span class="line">Widget &amp;&amp;w3 = <span class="built_in">std</span>::<span class="built_in">move</span>(w2); <span class="comment">// w3 is an rvalue reference and an lvalue, no type deduction</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Widget &amp;&amp;w)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// modify w</span></span><br><span class="line">&#125;</span><br><span class="line">f(w3); <span class="comment">// compilation error! w3 is an lvalue</span></span><br><span class="line">f(<span class="built_in">std</span>::<span class="built_in">move</span>(w3)); <span class="comment">// Okay! modifying w inside f changes w3</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>Conclusion:</p>
<ul>
<li>use <strong>std::move</strong> to rvalue references and <strong>std::forward</strong> to universal references the last time each is used</li>
<li>Do the same thing for rvalue references and universal references being returned from functions that return by value</li>
<li>Never apply <strong>std::move</strong> or <strong>std::forward</strong> to local objects if they would otherwise be eligible for the return value optimization (RVO)</li>
<li><strong>std::move</strong> performs an unconditional cast to an rvalue. In and of itself, it doesn’t move anything</li>
<li><strong>std::forward</strong> casts its argument to an rvalue only if that argument is bound to an rvalue</li>
<li>Neither <strong>std::move</strong> nor <strong>std::forward</strong> do anything at runtime</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>reference class member in C++</title>
    <url>/2020/05/16/reference-class-member-in-CPP/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> &amp;m;</span><br><span class="line">    A(<span class="keyword">int</span> &amp;x) : m(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(x)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.m &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.m &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 6</span></span><br><span class="line">    a.m = <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用RAII思想来管理线程</title>
    <url>/2020/05/16/%E4%BD%BF%E7%94%A8RAII%E6%80%9D%E6%83%B3%E6%9D%A5%E7%AE%A1%E7%90%86%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread_guard</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(thread &amp;t)</span> : <span class="keyword">_t</span><span class="params">(t)</span> </span>&#123;&#125;</span><br><span class="line">    ~thread_guard() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">_t</span>.joinable()) &#123;</span><br><span class="line">            <span class="keyword">_t</span>.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread_guard(<span class="keyword">const</span> thread_guard &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    thread_guard &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> thread_guard &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    thread &amp;<span class="keyword">_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        thread t&#123;[](<span class="keyword">int</span> x) &#123; <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;, i&#125;;</span><br><span class="line">        thread_guard tg&#123;t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Use constexpr whenever possible</title>
    <url>/2020/05/16/Use-constexpr-whenever-possible/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    constexpr Point(double x = 0, double y = 0) noexcept : x(x), y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">xValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">yValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">midpoint</span><span class="params">(<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(p1.xValue() + p2.xValue()) / <span class="number">2</span>, (p1.yValue() + p2.yValue()) / <span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">reflection</span><span class="params">(<span class="keyword">const</span> Point&amp; p)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    Point res;</span><br><span class="line">    res.setX(-p.xValue());</span><br><span class="line">    res.setY(-p.yValue());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = midpoint(p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> reflectedMid = reflection(mid);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>The <strong>Point</strong> constructor can be declared <strong>constexpr</strong>, because if the arguments passed to it are known during compilation, the value of the data members of the constructed <strong>Point</strong> can also be known during compilation. <strong>Point</strong>s initialized could thus be <strong>constexpr</strong>. In C++14, even setters can be <strong>constexpr</strong>.</p>
<p>Conclusion:</p>
<ul>
<li><strong>constexpr</strong> objects are <strong>const</strong> and are initialized with values known during compilation.</li>
<li><strong>constexpr</strong> functions can produce compile-time results when called with arguments whose values are known during compilation.</li>
<li><strong>constexpr</strong> objects and functions may be used in a wider range of contexts than non-<strong>constexpr</strong> objects and functions.</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>type deduction</title>
    <url>/2020/05/16/type-deduction/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;</span><br><span class="line">f(x); <span class="comment">// x is lvalue, so T is int&amp;, param's type is also int&amp;</span></span><br><span class="line">f(cx); <span class="comment">// cx is lvalue, so T is const int&amp;, param's type is also const int&amp;</span></span><br><span class="line">f(rx); <span class="comment">// rx is lvalue, so T is const int&amp;, param's type is also const int&amp;</span></span><br><span class="line">f(<span class="number">27</span>); <span class="comment">// 27 is rvalue, so T is int, param's type is therefore int&amp;&amp;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>Conclusion: when deducing types for universal reference parameters, lvalue arguments get special treatment</p>
<ul>
<li>T&amp;&amp; lvalue =&gt; (const) T&amp; lvalue</li>
<li>T&amp;&amp; rvalue =&gt; T&amp;&amp; rvalue</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>; <span class="comment">// type is void()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>; <span class="comment">// pass by value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>; <span class="comment">// pass by reference</span></span><br><span class="line"></span><br><span class="line">f1(fun); <span class="comment">// param deduced as ptr-to-func; type is void(*)()</span></span><br><span class="line">f2(fun); <span class="comment">// param deduced as ref-to-func; type is void(&amp;)()</span></span><br></pre></td></tr></table></figure>

<p>Conclusion: during template type deduction, arguments that are function names decay to pointers, unless they are used to initialize references</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref1 = x; <span class="comment">// x is int and lvalue, so uref1's type is int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref2 = cx; <span class="comment">// cx is const int and lvalue, so uref2's type is const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref3 = <span class="number">27</span>; <span class="comment">// 27 is int and rvalue, so uref3's type is int&amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p>Conclusion: same as template type deduction</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">const</span> Widget&amp; cw = w;</span><br><span class="line"><span class="keyword">auto</span> myWidget1 = cw; <span class="comment">// auto type deduction: myWIdget1's type is Widget</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) myWidget2 = cw; <span class="comment">// decltype type deduction: myWIdget2's type is const Widget&amp;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) y = x; <span class="comment">// y's type is int</span></span><br><span class="line">y = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) z = (x); <span class="comment">// z's type is int&amp;</span></span><br><span class="line">z = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p><em>x</em> is the name of a variable, so <em>decltype(x)</em> is <em>int</em>. Being a name, <em>x</em> is an lvalue, and C++ defines the expression <em>(x)</em> to be an lvalue, too. <em>decltype((x))</em> is therefore <em>int&amp;</em>.</p>
<p>Conclusion:</p>
<ul>
<li><em>decltype</em> almost always yeilds the type of a variable or expression without any modifications.</li>
<li>For lvalue expressions of type <strong>T</strong> other than names, <em>decltype</em> always reports a type of <strong>T&amp;</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">float</span> a = f(); <span class="comment">// implicitly convert double -&gt; float</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(f()); <span class="comment">// explicitly typed initializer idiom</span></span><br></pre></td></tr></table></figure>

<p>Conclusion: use explicitly typed initializer idiom for <strong>auto</strong> to deduce the type you want it to have</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>线程分离以后的资源回收</title>
    <url>/2020/05/15/%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB%E4%BB%A5%E5%90%8E%E7%9A%84%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::A()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::~A() "</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    this_thread::sleep_for(chrono::seconds(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"parent"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    thread t&#123;child&#125;;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"><span class="comment">//    this_thread::sleep_for(chrono::seconds(1));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    parent();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"main"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//    this_thread::sleep_for(chrono::seconds(5));</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程detach以后，如果进程结束（比如main函数返回）则该detached线程的资源交给系统回收，与该线程的父线程是否返回无关（除非父线程是main函数）</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>4. Median of Two Sorted Arrays</title>
    <url>/2020/05/30/4-Median-of-Two-Sorted-Arrays/</url>
    <content><![CDATA[<p>二分法O(log(m+n))<br><a href="http://www.cnblogs.com/grandyang/p/4465932.html" target="_blank" rel="noopener">题解</a><br>把原题转换成给定两个排好序的数组，找出其中第k小的数（k是1-based）<br>复杂度计算：少1/4，少1/8，少1/16，直到逼近中位数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">        n = len(nums1) + len(nums2) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (self.findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, n // <span class="number">2</span>) + self.findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, (n + <span class="number">1</span>) // <span class="number">2</span>)) / <span class="number">2</span> <span class="comment">#必须要用self，跟MATLAB一样</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKth</span><span class="params">(self, A: List[int], b1: int, B: List[int], b2: int, k)</span> -&gt; float:</span></span><br><span class="line">        m, n = len(A) - b1, len(B) - b2</span><br><span class="line">        <span class="keyword">if</span> m &gt; n: <span class="keyword">return</span> self.findKth(B, b2, A, b1, k)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>: <span class="keyword">return</span> B[b2 + k - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>: <span class="keyword">return</span> min(A[b1], B[b2])</span><br><span class="line">        i, j = min(k // <span class="number">2</span>, m), min(k // <span class="number">2</span>, n)</span><br><span class="line">        <span class="keyword">if</span> A[b1 + i - <span class="number">1</span>] &lt; B[b2 + j - <span class="number">1</span>]: <span class="keyword">return</span> self.findKth(A, b1 + i, B, b2, k - i)</span><br><span class="line">        <span class="keyword">return</span> self.findKth(A, b1, B, b2 + j, k - j)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findKth</span><span class="params">(A, b1, B, b2, k)</span>:</span></span><br><span class="line">            m, n = len(A) - b1, len(B) - b2</span><br><span class="line">            <span class="keyword">if</span> m &gt; n: <span class="keyword">return</span> findKth(B, b2, A, b1, k)</span><br><span class="line">            <span class="keyword">if</span> m == <span class="number">0</span>: <span class="keyword">return</span> B[b2 + k - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">1</span>: <span class="keyword">return</span> min(A[b1], B[b2])</span><br><span class="line">            i, j = min(k // <span class="number">2</span>, m), min(k // <span class="number">2</span>, n)</span><br><span class="line">            <span class="keyword">if</span> A[b1 + i - <span class="number">1</span>] &lt; B[b2 + j - <span class="number">1</span>]: <span class="keyword">return</span> findKth(A, b1 + i, B, b2, k - i)</span><br><span class="line">            <span class="keyword">return</span> findKth(A, b1, B, b2 + j, k - j)</span><br><span class="line">        n = len(nums1) + len(nums2) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, n // <span class="number">2</span>) + findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, (n + <span class="number">1</span>) // <span class="number">2</span>)) / <span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> (kth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, (m + n + <span class="number">1</span>) / <span class="number">2</span>) + kth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, (m + n + <span class="number">2</span>) / <span class="number">2</span>)) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="keyword">int</span> b1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2, <span class="keyword">int</span> b2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="keyword">int</span>(nums1.<span class="built_in">size</span>()) - b1, n = <span class="keyword">int</span>(nums2.<span class="built_in">size</span>()) - b2;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> kth(nums2, b2, nums1, b1, k);</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> nums2[b2 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">min</span>(nums1[b1], nums2[b2]);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">min</span>(m, k / <span class="number">2</span>), j = <span class="built_in">min</span>(n, k / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> nums1[b1 + i - <span class="number">1</span>] &lt; nums2[b2 + j - <span class="number">1</span>] ? kth(nums1, b1 + i, nums2, b2, k - i) : kth(nums1, b1, nums2, b2 + j, k - j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> (findKth(nums1, nums2, (m + n + <span class="number">1</span>) / <span class="number">2</span>) + findKth(nums1, nums2, (m + n + <span class="number">2</span>) / <span class="number">2</span>)) * <span class="number">0.5</span>; <span class="comment">// 这里因为是第k大，所以是1-based，(m + n + 1) / 2和(m + n + 2) / 2当m + n是奇数的时候相等，偶数的时候相邻</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.<span class="built_in">size</span>(), n = B.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> findKth(B, A, k); <span class="comment">// 永远保持A比B少</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> B[k - <span class="number">1</span>]; <span class="comment">// 如果A是空的，直接在B里找</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">min</span>(A[<span class="number">0</span>], B[<span class="number">0</span>]); <span class="comment">// 如果要找第1小的数，直接返回最小的那个</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">min</span>(m, k / <span class="number">2</span>), j = <span class="built_in">min</span>(n, k / <span class="number">2</span>); <span class="comment">// 每次去掉较小的那k / 2个</span></span><br><span class="line">        <span class="keyword">return</span> A[i - <span class="number">1</span>] &lt; B[j - <span class="number">1</span>] ? findKth(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(A.<span class="built_in">begin</span>() + i, A.<span class="built_in">end</span>()), B, k - i) : findKth(A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(B.<span class="built_in">begin</span>() + j, B.<span class="built_in">end</span>()), k - j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(log(m+n))二分法<br>把原题转换成找第k小的数，k=(m+n)/2<br>每次比较两个数组中第k/2大的数，假设nums1[k/2] &lt; nums2[k/2]，则nums1的前k/2元素都不可能是第k大的数，因为至少有剩余的k个数以及nums2[k/2]共k+1个数比这k/2个数大，所以接下来只需要在nums1的剩余数和nums2全部数中找第k-k/2大的数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, (n + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, n / <span class="number">2</span>) + findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, n / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="keyword">int</span> s1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2, <span class="keyword">int</span> s2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 &gt;= nums1.<span class="built_in">size</span>()) <span class="keyword">return</span> nums2[s2 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s2 &gt;= nums2.<span class="built_in">size</span>()) <span class="keyword">return</span> nums1[s1 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">min</span>(nums1[s1], nums2[s2]);</span><br><span class="line">        <span class="keyword">int</span> i1 = s1 + k / <span class="number">2</span> - <span class="number">1</span>, i2 = s2 + k / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> e1 = i1 &gt;= nums1.<span class="built_in">size</span>() ? INT_MAX : nums1[i1];</span><br><span class="line">        <span class="keyword">int</span> e2 = i2 &gt;= nums2.<span class="built_in">size</span>() ? INT_MAX : nums2[i2];</span><br><span class="line">        <span class="keyword">if</span> (e1 &lt; e2) &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, s1 + k / <span class="number">2</span>, nums2, s2, k - k / <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, s1, nums2, s2 + k / <span class="number">2</span>, k - k / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Divide and conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>37. Sudoku Solver</title>
    <url>/2020/06/10/37-Sudoku-Solver/</url>
    <content><![CDATA[<p>backtracking<br>预处理board把每个cell能算出来的都填上，再跑backtracking试数<br>先写backtracking，再写预处理优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        row.resize(<span class="number">9</span>);</span><br><span class="line">        col.resize(<span class="number">9</span>);</span><br><span class="line">        sub.resize(<span class="number">9</span>);</span><br><span class="line">        s.resize(<span class="number">81</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">9</span>; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">9</span>; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[r][c] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = board[r][c] - <span class="string">'0'</span>;</span><br><span class="line">                    row[r][i] = col[c][i] = sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> change = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            change = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">9</span>; ++r) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">9</span>; ++c) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (board[r][c] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!row[r][i] &amp;&amp; !col[c][i] &amp;&amp; !sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i]) &#123;</span><br><span class="line">                                s[r * <span class="number">9</span> + c].insert(i);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (s[r * <span class="number">9</span> + c].<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="keyword">int</span> i = *s[r * <span class="number">9</span> + c].<span class="built_in">begin</span>();</span><br><span class="line">                            board[r][c] = <span class="string">'0'</span> + i;</span><br><span class="line">                            ++change;</span><br><span class="line">                            row[r][i] = col[c][i] = sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (change &gt; <span class="number">0</span>);</span><br><span class="line">        dfs(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;b, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">81</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> r = idx / <span class="number">9</span>, c = idx % <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">if</span> (b[r][c] != <span class="string">'.'</span>) <span class="keyword">return</span> dfs(b, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : s[idx]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row[r][i] || col[c][i] || sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i]) <span class="keyword">continue</span>;</span><br><span class="line">            b[r][c] = <span class="string">'0'</span> + i;</span><br><span class="line">            row[r][i] = col[c][i] = sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (dfs(b, idx + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            row[r][i] = col[c][i] = sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b[r][c] = <span class="string">'.'</span>; <span class="comment">// revert</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">bitset</span>&lt;10&gt;&gt; row, col, sub;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; s; <span class="comment">// 对每个位置来说所有可能的数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>没有预处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        h = [[<span class="literal">False</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        v = [[<span class="literal">False</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        s = [[<span class="literal">False</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                x = board[r][c]</span><br><span class="line">                <span class="keyword">if</span> x != <span class="string">'.'</span>:</span><br><span class="line">                    x = int(x)</span><br><span class="line">                    h[r][x] = v[c][x] = s[r // <span class="number">3</span> * <span class="number">3</span> + c // <span class="number">3</span>][x] = <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(idx)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> idx == <span class="number">81</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            r, c = divmod(idx, <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">if</span> board[r][c] != <span class="string">'.'</span>: <span class="keyword">return</span> dfs(idx + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span> h[r][x] <span class="keyword">or</span> v[c][x] <span class="keyword">or</span> s[r // <span class="number">3</span> * <span class="number">3</span> + c // <span class="number">3</span>][x]: <span class="keyword">continue</span></span><br><span class="line">                board[r][c] = str(x)</span><br><span class="line">                h[r][x] = v[c][x] = s[r // <span class="number">3</span> * <span class="number">3</span> + c // <span class="number">3</span>][x] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> dfs(idx + <span class="number">1</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                h[r][x] = v[c][x] = s[r // <span class="number">3</span> * <span class="number">3</span> + c // <span class="number">3</span>][x] = <span class="literal">False</span></span><br><span class="line">                board[r][c] = <span class="string">'.'</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        row.resize(<span class="number">9</span>);</span><br><span class="line">        col.resize(<span class="number">9</span>);</span><br><span class="line">        sub.resize(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">9</span>; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">9</span>; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[r][c] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = board[r][c] - <span class="string">'0'</span>;</span><br><span class="line">                    row[r][i] = col[c][i] = sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;b, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">81</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> r = idx / <span class="number">9</span>, c = idx % <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">if</span> (b[r][c] != <span class="string">'.'</span>) <span class="keyword">return</span> dfs(b, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row[r][i] || col[c][i] || sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i]) <span class="keyword">continue</span>;</span><br><span class="line">            b[r][c] = <span class="string">'0'</span> + i;</span><br><span class="line">            row[r][i] = col[c][i] = sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (dfs(b, idx + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            row[r][i] = col[c][i] = sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i] = <span class="literal">false</span>;</span><br><span class="line">						b[r][c] = <span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">bitset</span>&lt;10&gt;&gt; row, col, sub;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>38. Count and Say</title>
    <url>/2020/06/10/38-Count-and-Say/</url>
    <content><![CDATA[<p>sliding window</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        res = <span class="string">'1'</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            s, i, j, n = <span class="string">''</span>, <span class="number">0</span>, <span class="number">1</span>, len(res)</span><br><span class="line">            <span class="keyword">while</span> i &lt; n:</span><br><span class="line">                <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> res[j] == res[i]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                s += str(j - i) + res[i]</span><br><span class="line">                i = j</span><br><span class="line">            res = s</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cas</span><span class="params">(s)</span>:</span></span><br><span class="line">            res = <span class="string">''</span></span><br><span class="line">            i, j, n = <span class="number">0</span>, <span class="number">1</span>, len(s)</span><br><span class="line">            <span class="keyword">while</span> i &lt; n:</span><br><span class="line">                <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> s[j] == s[i]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                res += str(j - i) + s[i]</span><br><span class="line">                i = j</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        res = <span class="string">'1'</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            res = cas(res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res = helper(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>, j = i;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n &amp;&amp; s[j] == c; ++j) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            res += to_string(cnt);</span><br><span class="line">            res += c;</span><br><span class="line">            i = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res = helper(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        s += <span class="string">"#"</span>;</span><br><span class="line">        <span class="keyword">char</span> prev = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != prev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res += to_string(i - b);</span><br><span class="line">                    res += prev;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = s[i];</span><br><span class="line">                b = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>iterative</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 要从1开始，因为0已经数过了</span></span><br><span class="line">            res += <span class="string">"#"</span>;</span><br><span class="line">            <span class="keyword">int</span> len = res.length() - <span class="number">1</span>; <span class="comment">// 不需要看最后一个#字符</span></span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">// cnt要从1开始，因为每次res[i] != res[i + 1]的时候会少做一次cnt++</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res[i] == res[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s += to_string(cnt) + res[i];</span><br><span class="line">                    cnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(res, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res += <span class="string">"#"</span>;</span><br><span class="line">            <span class="keyword">char</span> prev = <span class="string">'#'</span>;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> len = res.length();</span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res[i] != prev) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i - b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        s += to_string(i - b);</span><br><span class="line">                        s += prev;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = res[i];</span><br><span class="line">                    b = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(res, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>39. Combination Sum</title>
    <url>/2020/06/10/39-Combination-Sum/</url>
    <content><![CDATA[<p>backtracking</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res, A = [], []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(b, s)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">                res.append(A[:]) <span class="comment"># 注意要copy!!!</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(b, len(candidates)):</span><br><span class="line">                x = candidates[i]</span><br><span class="line">                <span class="keyword">if</span> x &gt; s:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                A.append(x)</span><br><span class="line">                dfs(i, s - x)</span><br><span class="line">                A.pop()</span><br><span class="line">        dfs(<span class="number">0</span>, target)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(b, s, A)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">                res.append(A)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(b, len(candidates)):</span><br><span class="line">                x = candidates[i]</span><br><span class="line">                <span class="keyword">if</span> x &gt; s:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                dfs(i, s - x, A + [x]) <span class="comment"># 会触发copy</span></span><br><span class="line">        dfs(<span class="number">0</span>, target, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(<span class="built_in">begin</span>(candidates), <span class="built_in">end</span>(candidates)); <span class="comment">// 用来加速和去重</span></span><br><span class="line">        dfs(candidates, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> b, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; candidates[i] &lt;= target; ++i) &#123; <span class="comment">// 注意candidates &lt;= target</span></span><br><span class="line">            v.push_back(candidates[i]); <span class="comment">// 尝试寻找以candidates[i]开头的可行解</span></span><br><span class="line">            dfs(candidates, i, target - candidates[i]);</span><br><span class="line">            v.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
        <tag>Combination</tag>
      </tags>
  </entry>
  <entry>
    <title>40. Combination Sum II</title>
    <url>/2020/06/11/40-Combination-Sum-II/</url>
    <content><![CDATA[<p>backtracking<br>对比<a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">39. Combination Sum</a>这道题candidates可能有dup且每个candidate只能用一次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res, A = [], []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(b, s)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">                res.append(A[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(b, len(candidates)):</span><br><span class="line">                x = candidates[i]</span><br><span class="line">                <span class="keyword">if</span> x &gt; s:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; b <span class="keyword">and</span> x == candidates[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                A.append(x)</span><br><span class="line">                dfs(i + <span class="number">1</span>, s - x)</span><br><span class="line">                A.pop()</span><br><span class="line">        dfs(<span class="number">0</span>, target)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(b, s, A)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">                res.append(A)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(b, len(candidates)):</span><br><span class="line">                x = candidates[i]</span><br><span class="line">                <span class="keyword">if</span> x &gt; s:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; b <span class="keyword">and</span> x == candidates[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dfs(i + <span class="number">1</span>, s - x, A + [x])</span><br><span class="line">        dfs(<span class="number">0</span>, target, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(<span class="built_in">begin</span>(candidates), <span class="built_in">end</span>(candidates));</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> b, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; candidates[i] &lt;= target; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; b &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">            v.push_back(candidates[i]);</span><br><span class="line">            dfs(candidates, i + <span class="number">1</span>, target - candidates[i]); <span class="comment">// 从下一个开始</span></span><br><span class="line">            v.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
        <tag>Combination</tag>
      </tags>
  </entry>
  <entry>
    <title>41. First Missing Positive</title>
    <url>/2020/06/11/41-First-Missing-Positive/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>负号法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> x &lt; <span class="number">1</span> <span class="keyword">or</span> x &gt; n:</span><br><span class="line">                nums[i] = n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            x = abs(x)</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt; x &lt;= n:</span><br><span class="line">                nums[x - <span class="number">1</span>] = -abs(nums[x - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; n) &#123;</span><br><span class="line">                x = n + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            x = <span class="built_in">abs</span>(x);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt; x &amp;&amp; x &lt;= n) &#123;</span><br><span class="line">                nums[x - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[x - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类似桶排序，每个数都应该放在对应的位置，即 nums[i] == nums[nums[i] - 1]，所以不停交换数，尽可能把每个数挪到对应的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span> &lt; nums[i] &lt;= n <span class="keyword">and</span> nums[i] != nums[nums[i] - <span class="number">1</span>]:</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>], nums[i] = nums[i], nums[nums[i] - <span class="number">1</span>] <span class="comment"># 注意不能写成nums[i], nums[nums[i] - 1] = nums[nums[i] - 1], nums[i]因为从左到右赋值，nums[i]先被修改，nums[nums[i] - 1]的新值是错的！！必要时可以考虑加一个中间变量t来swap</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> x != i + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123; <span class="comment">// 交换的条件，nums[i]必须在(0, n]之间，而且被交换的数不能等于nums[i]，否则会造成死循环</span></span><br><span class="line">                swap(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 查找第一个不在对应位置的数</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hare and tortoise</tag>
        <tag>负号法</tag>
      </tags>
  </entry>
  <entry>
    <title>43. Multiply Strings</title>
    <url>/2020/06/14/43-Multiply-Strings/</url>
    <content><![CDATA[<p>O(mn) time O(m+n) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line">        m, n = len(num1), len(num2)</span><br><span class="line">        num = [<span class="number">0</span>] * (m + n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            c = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                s = num[i + j + <span class="number">1</span>] + int(num1[i]) * int(num2[j]) + c</span><br><span class="line">                c, num[i + j + <span class="number">1</span>] = divmod(s, <span class="number">10</span>)</span><br><span class="line">            num[i] = c</span><br><span class="line">        res = <span class="string">''</span>.join(map(str, num)).lstrip(<span class="string">'0'</span>)</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res <span class="keyword">else</span> <span class="string">'0'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = num1.length(), n = num2.length();</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(m + n, <span class="string">'0'</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>, j; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">int</span> s = (res[i + j + <span class="number">1</span>] - <span class="string">'0'</span>) + (num1[i] - <span class="string">'0'</span>) * (num2[j] - <span class="string">'0'</span>) + c;</span><br><span class="line">                res[i + j + <span class="number">1</span>] = s % <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                c = s / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = c + <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = res.find_first_not_of(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">return</span> p == <span class="built_in">string</span>::npos ? <span class="string">"0"</span> : res.substr(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>42. Trapping Rain Water</title>
    <url>/2020/06/14/42-Trapping-Rain-Water/</url>
    <content><![CDATA[<p>O(n)<br>跟<a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. Container With Most Water</a>方法几乎一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(height)</span><br><span class="line">        l, r, res = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mn = min(height[l], height[r])</span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> height[l] &lt;= mn:</span><br><span class="line">                res += mn - height[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> height[r] &lt;= mn:</span><br><span class="line">                res += mn - height[r]</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mn = <span class="built_in">min</span>(<span class="built_in">height</span>[l], <span class="built_in">height</span>[r]);</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">height</span>[l] &lt;= mn) &#123;</span><br><span class="line">                res += mn - <span class="built_in">height</span>[l];</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">height</span>[r] &lt;= mn) &#123;</span><br><span class="line">                res += mn - <span class="built_in">height</span>[r];</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        int left(0), right(height.size() - 1), ret(0);</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">auto</span> <span class="title">min</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">min</span>(<span class="built_in">height</span>[left], <span class="built_in">height</span>[right]))</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">min</span> == <span class="built_in">height</span>[left])</span><br><span class="line">                <span class="keyword">while</span> (++left &lt; right &amp;&amp; <span class="built_in">height</span>[left] &lt; <span class="built_in">min</span>)</span><br><span class="line">                    ret += <span class="built_in">min</span> - <span class="built_in">height</span>[left];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; --right &amp;&amp; <span class="built_in">height</span>[right] &lt; <span class="built_in">min</span>)</span><br><span class="line">                    ret += <span class="built_in">min</span> - <span class="built_in">height</span>[right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>44. Wildcard Matching</title>
    <url>/2020/06/14/44-Wildcard-Matching/</url>
    <content><![CDATA[<p>backtracking best case O(m+n) time O(1) space<br>worst case O(mn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, ist = <span class="number">-1</span>, jst = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">'?'</span>)) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; n &amp;&amp; (p[j] == <span class="string">'*'</span>)) &#123; <span class="comment">// 保存*匹配到的i和j</span></span><br><span class="line">                ist = i;</span><br><span class="line">                jst = j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ist &gt;= <span class="number">0</span>) &#123; <span class="comment">// 如果之前匹配过*</span></span><br><span class="line">                i = ++ist; <span class="comment">// 这里重置到ist的下一个是因为*有可能匹配多个字符，方便重置i</span></span><br><span class="line">                j = jst + <span class="number">1</span>; <span class="comment">// backtracking假设*可以cover之前的ist那个字符，继续尝试匹配之后的字符</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; p[j] == <span class="string">'*'</span>) &#123; <span class="comment">// 只有p后边全是*才说明完全匹配上了</span></span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>dp O(mn) time O(mn) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        m, n = len(s), len(p)</span><br><span class="line">        f = [[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            f[<span class="number">0</span>][i] = p[i - <span class="number">1</span>] == <span class="string">'*'</span> <span class="keyword">and</span> f[<span class="number">0</span>][i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">1</span>] <span class="keyword">or</span> f[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] <span class="keyword">and</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">'?'</span>)</span><br><span class="line">        <span class="keyword">return</span> f[m][n]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), m = p.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>))</span></span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 两个空串肯定匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            f[<span class="number">0</span>][j] = f[<span class="number">0</span>][j - <span class="number">1</span>] &amp;&amp; (p[j - <span class="number">1</span>] == <span class="string">'*'</span>); <span class="comment">// *可以匹配任意多个字符，所以直接继承前一个的结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">1</span>] || f[i - <span class="number">1</span>][j]; <span class="comment">// s[i - 1]不去跟*匹配，看s[0:i-1]和p[0:j-2]是否匹配；s[i - 1]去跟*匹配，看s[0:i-2]和p[0:j-1]是否匹配</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">'?'</span>); <span class="comment">// 两字符相同（或通配符是?）直接查看之前的匹配结果</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>recursive</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        cache.resize(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> f(m, n, s, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">string</span> &amp;p)</span> </span>&#123;<span class="comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (cache[i][j] != <span class="number">-1</span>) <span class="keyword">return</span> cache[i][j];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> cache[i][j] = p[j - <span class="number">1</span>] == <span class="string">'*'</span> &amp;&amp; f(i, j - <span class="number">1</span>, s, p);</span><br><span class="line">        <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">'*'</span>) <span class="keyword">return</span> cache[i][j] = f(i, j - <span class="number">1</span>, s, p) || f(i - <span class="number">1</span>, j, s, p);</span><br><span class="line">        <span class="keyword">return</span> cache[i][j] = (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">'?'</span>) &amp;&amp; f(i - <span class="number">1</span>, j - <span class="number">1</span>, s, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cache;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>Backtracking</tag>
        <tag>String match</tag>
      </tags>
  </entry>
  <entry>
    <title>45. Jump Game II</title>
    <url>/2020/06/14/45-Jump-Game-II/</url>
    <content><![CDATA[<p>greedy O(n) time O(1) space<br>相当于BFS一棵树<br>last就是当前层所能达到的最远位置（可以覆盖的地方）<br>curr_max是当前位置能达到的最远位置<br><a href="http://www.cnblogs.com/lichen782/p/leetcode_Jump_Game_II.html" target="_blank" rel="noopener">题解</a>比较清楚<br>0 1 2 3 4 i<br>2 3 1 1 4 nums[i]<br>2 4 3 4 8 i + nums[i]<br>0 2 2 4 4 last<br>2 4 4 4 8 curr_max<br>{0(2)} –&gt; {1(4) 2(3)} –&gt; {3(4) 4(8)}<br>意思是最开始在0，不跳的话只能到0，如果想跳到1以后需要跳一次，这一次最远跳到2，然后如果想再跳到3以后需要再跳一次，这一次至少跳到4（最远跳到8但是不需要了），因为4已经达到最远点，跳出循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        possible = curr = res = <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> curr &gt;= n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> curr &lt; i:</span><br><span class="line">                curr = possible</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            possible = max(possible, i + nums[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; last &lt; n - <span class="number">1</span>; ++i) &#123; <span class="comment">// last &lt; n - 1是一个优化，因为last达到n - 1就说明cnt已经够了</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; last) &#123; <span class="comment">// bfs应该先更新，表示必须要jump一次才能达到当前的i</span></span><br><span class="line">                last = curr_max;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            curr_max = <span class="built_in">max</span>(curr_max, i + nums[i]); <span class="comment">// bfs应该后『遍历』如果颠倒顺序last少更新一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>dp O(n<sup>2</sup>) time O(n) space TLE<br>dp[i]表示达到i所需要的最少步数<br>求dp[i]需要查询dp[j] where 0 &lt;= j &lt; i，然后+1<br>dp[0]肯定为0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">n</span><span class="params">(nums.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>); i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j(<span class="number">0</span>); j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + nums[j] &gt;= i)</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>47. Permutations II</title>
    <url>/2020/06/14/47-Permutations-II/</url>
    <content><![CDATA[<p>O(n*n!) time<br>先写 dfs 版本再写循环版本<br>先排序，对于每个位置，从小到大枚举之后的每个数（相同的数要跳过）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res, n = [], len(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(A, b)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> b == n:</span><br><span class="line">                res.append(A)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(b, n):</span><br><span class="line">                <span class="keyword">if</span> i &gt; b <span class="keyword">and</span> A[i] == A[b]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                A[b], A[i] = A[i], A[b]</span><br><span class="line">                dfs(A[:], b + <span class="number">1</span>)</span><br><span class="line">        dfs(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(<span class="built_in">begin</span>(nums), <span class="built_in">end</span>(nums));</span><br><span class="line">        dfs(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">// 注意nums是深拷贝</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (b == n) &#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; b &amp;&amp; nums[i] == nums[b]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">            swap(nums[i], nums[b]);</span><br><span class="line">            dfs(nums, b + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>O(n*n!) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125; <span class="keyword">while</span> (next(nums));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">next</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i - <span class="number">1</span>] &lt; A[i]) &#123;</span><br><span class="line">                x = i - <span class="number">1</span>;</span><br><span class="line">                y = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; x; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[x]) &#123;</span><br><span class="line">                swap(A[i], A[x]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(A.<span class="built_in">begin</span>() + y, A.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>O(n<sup>n</sup>) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        n = nums.<span class="built_in">size</span>();</span><br><span class="line">        visited.resize(n);</span><br><span class="line">        sort(<span class="built_in">begin</span>(nums), <span class="built_in">end</span>(nums));</span><br><span class="line">        dfs(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] || i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 如果前一个数已经访问过（还没被访问）并且跟这个数相同，则再访问这个数是重复的，如果前一个数正在被访问（说明在v里）则可以访问当前这个数，即便跟前一个数相同</span></span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            v.push_back(nums[i]);</span><br><span class="line">            dfs(nums);</span><br><span class="line">            v.pop_back();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
        <tag>Permutation</tag>
      </tags>
  </entry>
  <entry>
    <title>50. Pow(x, n)</title>
    <url>/2020/06/15/50-Pow-x-n/</url>
    <content><![CDATA[<p>O(logn)<br>循环版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            x = <span class="number">1</span> / x</span><br><span class="line">            n = -n</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                res *= x</span><br><span class="line">            x *= x</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> t = <span class="built_in">labs</span>(n); <span class="comment">// 注意n溢出！！</span></span><br><span class="line">        x = n &lt; <span class="number">0</span> ? <span class="number">1</span> / x : x;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                res *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                res *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            n /= <span class="number">2</span>; <span class="comment">// 这里一定不要用 n &gt;&gt;= 1因为n可能为INT_MIN</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1.00000<br>-2147483648<br>这个测试用例很重要！因为-INT_MIN还是INT_MIN！！所以必须要把n &lt; 0的分支分离出来，否则会造成死循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &lt; <span class="number">0</span> ? power(<span class="number">1</span> / x, <span class="built_in">labs</span>(n)) : power(x, n);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n &amp; <span class="number">1</span> ? x * power(x * x, n / <span class="number">2</span>) : power(x * x, n / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        n &lt; <span class="number">0</span> ? power(<span class="number">1</span> / x, <span class="built_in">labs</span>(n), res) : power(x, n, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n, <span class="keyword">double</span> &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        power(x * x, n / <span class="number">2</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Integer</tag>
      </tags>
  </entry>
  <entry>
    <title>49. Group Anagrams</title>
    <url>/2020/06/14/49-Group-Anagrams/</url>
    <content><![CDATA[<p>O(nk) time<br>这道题考如何hash<br>followup是MapReduce</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        d = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            f = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">                f[ord(c) - ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">            d[tuple(f)].append(s)</span><br><span class="line">        <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">myhash</span><span class="params">(s)</span>:</span> <span class="comment"># 'bcabe' -&gt; '1a2b1c1e'</span></span><br><span class="line">            f = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">                f[ord(c) - ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">            res = <span class="string">''</span></span><br><span class="line">            <span class="keyword">for</span> i, cnt <span class="keyword">in</span> enumerate(f):</span><br><span class="line">                <span class="keyword">if</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">                    res += str(cnt) + chr(ord(<span class="string">'a'</span>) + i)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        d = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            d[myhash(s)].append(s)</span><br><span class="line">        <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">myhash</span><span class="params">(s)</span>:</span> <span class="comment"># 'bcabe' -&gt; '1 2 1 0 1 0 ... 0'</span></span><br><span class="line">            f = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">                f[ord(c) - ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">            res = <span class="string">''</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">' '</span>.join(map(str, f))</span><br><span class="line">        d = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            d[myhash(s)].append(s)</span><br><span class="line">        <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : strs) &#123;</span><br><span class="line">            m[hash(s)].push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : m) &#123;</span><br><span class="line">            res.push_back(p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">hash</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123; <span class="comment">// bucket sort</span></span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            ++f[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : f) &#123;</span><br><span class="line">            res += to_string(x);</span><br><span class="line">            res += <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>普通解法 O(nklogk) time</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        d = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            d[<span class="string">''</span>.join(sorted(s))].append(s) <span class="comment"># key是一个str: 'bcabe' -&gt; 'abbce'</span></span><br><span class="line">            <span class="comment"># d[tuple(sorted(s))].append(s) # key是一个tuple: 'bcabe' -&gt; ('a', 'b', 'b', 'c', 'e')</span></span><br><span class="line">        <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; hm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : strs) &#123;</span><br><span class="line">            hm[key(s)].push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : hm) &#123;</span><br><span class="line">            res.push_back(p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">key</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> primes[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; hash_map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;str : strs)</span><br><span class="line">            hash_map[key(str)].push_back(str);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; <span class="title">ret</span><span class="params">(hash_map.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">i</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;pair : hash_map) &#123;</span><br><span class="line">            ret[i].swap(pair.second);</span><br><span class="line">            sort(ret[i].<span class="built_in">begin</span>(), ret[i].<span class="built_in">end</span>());</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">key</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">long</span> <span class="title">ret</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;c : str)</span><br><span class="line">            ret *= primes[c - <span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
        <tag>String</tag>
        <tag>Anagram</tag>
      </tags>
  </entry>
  <entry>
    <title>46. Permutations</title>
    <url>/2020/06/14/46-Permutations/</url>
    <content><![CDATA[<p>O(n*n!) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125; <span class="keyword">while</span> (next(nums));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">next</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i - <span class="number">1</span>] &lt; A[i]) &#123;</span><br><span class="line">                x = i - <span class="number">1</span>;</span><br><span class="line">                y = i;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 说明从i开始后边全降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; x; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[x]) &#123;</span><br><span class="line">                swap(A[i], A[x]); <span class="comment">// 找到下一个比A[x]大的开始下一轮遍历</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(A.<span class="built_in">begin</span>() + y, A.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>backtracking O(n*n!) time</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n, res = len(nums), []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(A, b)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> b == n:</span><br><span class="line">                res.append(A)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(b, n):</span><br><span class="line">                A[i], A[b] = A[b], A[i]</span><br><span class="line">                dfs(A[:], b + <span class="number">1</span>)</span><br><span class="line">        dfs(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        n, res = len(nums), []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(b)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> b == n:</span><br><span class="line">                res.append(nums[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(b, n):</span><br><span class="line">                nums[i], nums[b] = nums[b], nums[i]</span><br><span class="line">                dfs(b + <span class="number">1</span>)</span><br><span class="line">                nums[i], nums[b] = nums[b], nums[i]</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(<span class="built_in">begin</span>(nums), <span class="built_in">end</span>(nums));</span><br><span class="line">        dfs(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">// 这里nums是深拷贝！！</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (b == n) &#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; n; ++i) &#123;</span><br><span class="line">            swap(nums[i], nums[b]); <span class="comment">// 每次把一个数放到最前边（可以保证剩下的序列还是升序），然后对剩下的序列全排列</span></span><br><span class="line">            dfs(nums, b + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>O(n<sup>n</sup>) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        n = nums.<span class="built_in">size</span>();</span><br><span class="line">        visited.resize(n);</span><br><span class="line">        sort(<span class="built_in">begin</span>(nums), <span class="built_in">end</span>(nums));</span><br><span class="line">        dfs(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            v.push_back(nums[i]); <span class="comment">// 把当前剩下还没访问过的数分别尝试append到v后边</span></span><br><span class="line">            dfs(nums);</span><br><span class="line">            v.pop_back();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
        <tag>Permutation</tag>
      </tags>
  </entry>
  <entry>
    <title>48. Rotate Image</title>
    <url>/2020/06/14/48-Rotate-Image/</url>
    <content><![CDATA[<p>two spins O(n<sup>2</sup>)<br>先上下翻转，再沿对称轴翻转</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        matrix.reverse()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        matrix.reverse()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(matrix)):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        reverse(matrix.<span class="built_in">begin</span>(), matrix.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">0</span>); i &lt; matrix.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j(i + <span class="number">1</span>); j &lt; matrix.<span class="built_in">size</span>(); ++j)</span><br><span class="line">                swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>直接移 O(n<sup>2</sup>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">n</span><span class="params">(matrix.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row(<span class="number">0</span>); row &lt; n; ++row)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col(row); col &lt; matrix.<span class="built_in">size</span>() - <span class="number">1</span> - row; ++col) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">auto</span> <span class="title">temp</span><span class="params">(matrix[row][col])</span></span>;</span><br><span class="line">                matrix[row][col] = matrix[matrix.<span class="built_in">size</span>() - <span class="number">1</span> - col][row];</span><br><span class="line">                matrix[matrix.<span class="built_in">size</span>() - <span class="number">1</span> - col][row] = matrix[matrix.<span class="built_in">size</span>() - <span class="number">1</span> - row][matrix.<span class="built_in">size</span>() - <span class="number">1</span> - col];</span><br><span class="line">                matrix[matrix.<span class="built_in">size</span>() - <span class="number">1</span> - row][matrix.<span class="built_in">size</span>() - <span class="number">1</span> - col] = matrix[col][matrix.<span class="built_in">size</span>() - <span class="number">1</span> - row];</span><br><span class="line">                matrix[col][matrix.<span class="built_in">size</span>() - <span class="number">1</span> - row] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title>快速启动Emacs</title>
    <url>/2020/06/27/%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8Emacs/</url>
    <content><![CDATA[<ul>
<li><p>Emacs CS模式<br>在~/.emacs里加入</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">require</span> 'server)</span><br><span class="line">(<span class="name">unless</span> (<span class="name">server-running-p</span>) (<span class="name">server-start</span>))</span><br></pre></td></tr></table></figure>
<p>或者(server-start)，emacs启动的时候就会自动启动server。然后你可以利<br>用emacscilent -c命令来打开一个新的窗口，速度会非常快。这有个缺点，如果充当server<br>的emacs被关闭之后，使用客户端命令就会出现无法打开的现象。可以使用emacs –daemon&amp;<br>模式在后台打开一个emacs作为server</p>
</li>
<li><p>开机自动启动emacs<br>Linux下在~/.profile里加入emacs –daemon&amp;即可<br>以后就可以使用emacsclient -c启动客户端了</p>
</li>
<li><p>Emacs和Emacsclient<br>有的时候，快速启动得到的emacsclient不能编辑需要sudo的文件。这是因为它的server没<br>有处在root权限下，所以会出现出错的现象。另外，emacsclient下的字体背景等会和原来<br>的有差异。我的解决办法是，平时开启一个emacs进程作为主要编辑的工具，另外一个<br>emacsclient则是编辑临时文件的时候使用，这样既保证了编辑临时文件的速度问题，同样<br>尽可能的排除错误。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>unique_ptr函数传参</title>
    <url>/2020/07/15/unique-ptr%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::A"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~A() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::~A"</span>&lt;&lt;<span class="built_in">endl</span>;x=<span class="number">0</span>;&#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a) : x(a.x) &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"copy ctor"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    A(A&amp;&amp; a)  <span class="keyword">noexcept</span> : x(a.x) &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"move ctor"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;A&gt; &amp;&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x-&gt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    x-&gt;x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">unique_ptr</span>&lt;A&gt; &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x-&gt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    x-&gt;x = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;A&gt; <span class="title">f3</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;A&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x-&gt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// 可以拷贝或赋值一个将要被销毁的unique_ptr （C++ Primer 5th p418）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = make_unique&lt;A&gt;(); <span class="comment">// A::A</span></span><br><span class="line">    f1(<span class="built_in">move</span>(a)); <span class="comment">// 1</span></span><br><span class="line">    f2(a); <span class="comment">// 2</span></span><br><span class="line">    a = f3(<span class="built_in">move</span>(a)); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// A::~A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>1249. Minimum Remove to Make Valid Parentheses</title>
    <url>/2020/11/22/1249-Minimum-Remove-to-Make-Valid-Parentheses/</url>
    <content><![CDATA[<p>跟<a href="https://leetcode.com/problems/remove-invalid-parentheses/" target="_blank" rel="noopener">301. Remove Invalid Parentheses</a>不完全一样<br>跟<a href="https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/" target="_blank" rel="noopener">921. Minimum Add to Make Parentheses Valid</a>结合起来看<br>O(n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minRemoveToMakeValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        s = <span class="built_in">remove</span>(s, <span class="string">')'</span>, <span class="string">'('</span>); <span class="comment">// 一定要先从后往前删，再从前往后删，因为s要翻转两次</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">remove</span>(s, <span class="string">'('</span>, <span class="string">')'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">char</span> lp, <span class="keyword">char</span> rp)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = s.length(), i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            cnt += s[i] == rp ? <span class="number">-1</span> : (s[i] == lp);</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) &#123; <span class="comment">// 说明找到一个无法匹配的『右括号』</span></span><br><span class="line">                cnt = <span class="number">0</span>; <span class="comment">// 重置</span></span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 跳过</span></span><br><span class="line">            &#125;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minRemoveToMakeValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        reverse(<span class="built_in">begin</span>(s), <span class="built_in">end</span>(s));</span><br><span class="line">        s = <span class="built_in">remove</span>(s, <span class="string">')'</span>, <span class="string">'('</span>);</span><br><span class="line">        reverse(<span class="built_in">begin</span>(s), <span class="built_in">end</span>(s));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">remove</span>(s, <span class="string">'('</span>, <span class="string">')'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">char</span> lp, <span class="keyword">char</span> rp)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            cnt += s[i] == rp ? <span class="number">-1</span> : (s[i] == lp);</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Parentheses</tag>
      </tags>
  </entry>
  <entry>
    <title>124. Binary Tree Maximum Path Sum</title>
    <url>/2020/11/22/124-Binary-Tree-Maximum-Path-Sum/</url>
    <content><![CDATA[<p>O(n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode *root, <span class="keyword">int</span> &amp;res)</span> </span>&#123; <span class="comment">// 以root结尾的最大和path的最大和</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">max</span>(<span class="number">0</span>, helper(root-&gt;left, res)); <span class="comment">// 如果返回的最大和是负数，则直接用0代替</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">max</span>(<span class="number">0</span>, helper(root-&gt;right, res));</span><br><span class="line">        res = <span class="built_in">max</span>(res, root-&gt;val + l + r); <span class="comment">// 更新res</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(l, r); <span class="comment">// 返回包括root在内的最大路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Postorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>953. Verifying an Alien Dictionary</title>
    <url>/2020/11/22/953-Verifying-an-Alien-Dictionary/</url>
    <content><![CDATA[<p>O(m*n) time O(1) space where m is the avg length of a word while n is the number of words</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlienSorted</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dict[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            dict[order[i] - <span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; words.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lte(words[i - <span class="number">1</span>], words[i], dict)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lte</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b, <span class="keyword">int</span> dict[<span class="number">26</span>])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = a.length(), n = b.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>(m, n); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> dict[a[i] - <span class="string">'a'</span>] &lt;= dict[b[i] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m &lt;= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>1428. Leftmost Column with at Least a One</title>
    <url>/2020/11/22/1428-Leftmost-Column-with-at-Least-a-One/</url>
    <content><![CDATA[<p>从右上往左下方向找边缘 O(m+n) time O(1) space<br>复杂度要不是m要不是n，最多是m+n</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the BinaryMatrix's API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class BinaryMatrix &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     int get(int row, int col);</span></span><br><span class="line"><span class="comment"> *     vector&lt;int&gt; dimensions();</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leftMostColumnWithOne</span><span class="params">(BinaryMatrix &amp;binaryMatrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;dim = binaryMatrix.dimensions();</span><br><span class="line">        <span class="keyword">int</span> m = dim[<span class="number">0</span>], n = dim[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>, r = <span class="number">0</span>, c = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; m &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (binaryMatrix.<span class="built_in">get</span>(r, c)) &#123;</span><br><span class="line">                res = c--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the BinaryMatrix's API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class BinaryMatrix &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     int get(int row, int col);</span></span><br><span class="line"><span class="comment"> *     vector&lt;int&gt; dimensions();</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leftMostColumnWithOne</span><span class="params">(BinaryMatrix &amp;binaryMatrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;dim = binaryMatrix.dimensions();</span><br><span class="line">        <span class="keyword">int</span> m = dim[<span class="number">0</span>], n = dim[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = n, r = <span class="number">0</span>, c = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; m &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (binaryMatrix.<span class="built_in">get</span>(r, c)) &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, c);</span><br><span class="line">                --c;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == n ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>158. Read N Characters Given Read4 II - Call multiple times</title>
    <url>/2020/11/22/158-Read-N-Characters-Given-Read4-II-Call-multiple-times/</url>
    <content><![CDATA[<p>跟<a href="https://leetcode.com/problems/read-n-characters-given-read4/" target="_blank" rel="noopener">157. Read N Characters Given Read4</a>的区别是前一次read过的剩余字符下次read的时候直接写进buf</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The read4 API is defined in the parent class Reader4.</span></span><br><span class="line"><span class="comment"> *     int read4(char *buf4);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param buf Destination buffer</span></span><br><span class="line"><span class="comment">     * @param n   Number of characters to read</span></span><br><span class="line"><span class="comment">     * @return    The number of actual characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (b != e &amp;&amp; cnt &lt; n) &#123;</span><br><span class="line">            buf[cnt++] = buf4[b++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n) <span class="keyword">return</span> cnt;</span><br><span class="line">        b = <span class="number">0</span>;</span><br><span class="line">        e = read4(buf4);</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="number">0</span>) <span class="keyword">return</span> cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt + <span class="built_in">read</span>(buf + cnt, n - cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf4[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of the read4 API.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read4</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param buf Destination buffer</span></span><br><span class="line"><span class="comment">     * @param n   Number of characters to read</span></span><br><span class="line"><span class="comment">     * @return    The number of actual characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; e &amp;&amp; cnt &lt; n) &#123; <span class="comment">// 在全局buffer的边界之内尽可能多的读字符</span></span><br><span class="line">            buf[cnt++] = t[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == e) i = e = <span class="number">0</span>; <span class="comment">// 如果全局buffer里到边界的所有字符都被读走，则重置下标和边界</span></span><br><span class="line">        <span class="keyword">if</span> (cnt == n) <span class="keyword">return</span> cnt; <span class="comment">// 如果已经读够了需要的字符，则返回</span></span><br><span class="line">        e = read4(t);</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="number">0</span>) <span class="keyword">return</span> cnt; <span class="comment">// 如果还需要继续读字符但是读出的字符数为0</span></span><br><span class="line">        <span class="keyword">return</span> cnt + <span class="built_in">read</span>(buf + cnt, n - cnt); <span class="comment">// 如果还需要继续读字符，递归</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, e = <span class="number">0</span>; <span class="comment">// 维护全局buffer的下标和右边界（不一定为4）</span></span><br><span class="line">    <span class="keyword">char</span> t[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>199. Binary Tree Right Side View</title>
    <url>/2020/11/22/199-Binary-Tree-Right-Side-View/</url>
    <content><![CDATA[<p>bfs O(n) time O(n) space<br>bfs逐层遍历每次取最后一个即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">list</span>&lt;TreeNode *&gt; q; <span class="comment">// q&#123;&#123;root&#125;&#125;;</span></span><br><span class="line">        q.push_back(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            res.push_back(q.back()-&gt;val);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = q.front(); q.pop_front();</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left) &#123; <span class="comment">// 因为要直接access node一定不能把nullptr放进去</span></span><br><span class="line">                    q.push_back(p-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                    q.push_back(p-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>269. Alien Dictionary</title>
    <url>/2020/11/22/269-Alien-Dictionary/</url>
    <content><![CDATA[<p>build graph O(mn) time<br>topological sort O(v+e) time<br>这里[“ab”, “abc”]以及[“z”, “z”]都是合法的，返回任一结果即可，但是[“abc”, “ab”]是非法的，必须返回空串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">alienOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : words) &#123; <span class="comment">// 这个必须是deep copy因为后边要修改</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!g.count(c)) &#123;</span><br><span class="line">                    g[c] = &#123;&#125;; <span class="comment">// 需要对unordered_set初始化否则结果不完整会丢字符</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="built_in">min</span>(u.length(), v.length()), i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; n; ++i) &#123; <span class="comment">// 比较前后两个字符串的每个字符，如果发现不一样的加一条边</span></span><br><span class="line">                <span class="keyword">if</span> (u[i] != v[i]) &#123;</span><br><span class="line">                    g[u[i]].insert(v[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == n &amp;&amp; u.length() &gt; v.length()) <span class="keyword">return</span> <span class="string">""</span>; <span class="comment">// ["abc", "ab"]非法</span></span><br><span class="line">            u.swap(v);</span><br><span class="line">        &#125;</span><br><span class="line">        visited.resize(<span class="number">128</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [c, _] : g) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isAcyclic(c)) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(rbegin(s), rend(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAcyclic</span><span class="params">(<span class="keyword">char</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[u]) <span class="keyword">return</span> visited[u] == <span class="number">1</span>;</span><br><span class="line">        visited[u] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isAcyclic(v)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s += u;</span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;&gt; g; <span class="comment">// 用unordered_set去重</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; visited; <span class="comment">// -1 0 1节省空间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">alienOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (words.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> words[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b) &#123;<span class="keyword">return</span> a.length() &lt; b.length();&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = words.<span class="built_in">size</span>(), m = max_element(<span class="built_in">begin</span>(words), <span class="built_in">end</span>(words), cmp)-&gt;length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">isOrdered</span><span class="params">(n - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isOrdered[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (words[i].length() &lt;= j) &#123;</span><br><span class="line">                        isOrdered[i] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (words[i][j] != words[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">                        isOrdered[i] = <span class="literal">true</span>;</span><br><span class="line">                        g[words[i][j]].insert(words[i + <span class="number">1</span>][j]);</span><br><span class="line">                        <span class="keyword">if</span> (g.count(words[i + <span class="number">1</span>][j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                            g[words[i + <span class="number">1</span>][j]] = &#123;&#125;;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; words[i].length() &amp;&amp; g.count(words[i][j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    g[words[i][j]] = &#123;&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; words[i + <span class="number">1</span>].length() &amp;&amp; g.count(words[i + <span class="number">1</span>][j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    g[words[i + <span class="number">1</span>][j]] = &#123;&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited.resize(<span class="number">128</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;p : g) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ts(p.first)) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            res += s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ts</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[ch] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited[ch] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        visited[ch] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;c : g[ch]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ts(c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(ch);</span><br><span class="line">        visited[ch] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;&gt; g;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Topological sort</tag>
      </tags>
  </entry>
  <entry>
    <title>238. Product of Array Except Self</title>
    <url>/2020/11/22/238-Product-of-Array-Except-Self/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>input: 1 2 3 4<br>res: 1 1 1 1<br>--&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line">-------</span><br><span class="line">1 1 1 1</span><br><span class="line">  1 1 1</span><br><span class="line">    2 2</span><br><span class="line">	  3</span><br></pre></td></tr></table></figure>
<p>&lt;–</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line">-------</span><br><span class="line">1 1 1 1</span><br><span class="line">4 1 1 1</span><br><span class="line">3 4 2 2</span><br><span class="line">2 3 4 3</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, p = <span class="number">1</span>; i &gt;= <span class="number">0</span>; p *= nums[i--]) &#123;</span><br><span class="line">            res[i] *= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">1</span>; i &lt; n; p *= nums[i++]) &#123;</span><br><span class="line">            res[i] *= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, p = <span class="number">1</span>; i &gt;= <span class="number">0</span>; p *= nums[i--]) &#123;</span><br><span class="line">            res[i] *= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p = nums[i - <span class="number">1</span>]; i &lt; n; p *= nums[i++]) &#123;</span><br><span class="line">            res[i] *= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>, p = nums[i + <span class="number">1</span>]; i &gt;= <span class="number">0</span>; p *= nums[i--]) &#123;</span><br><span class="line">            res[i] *= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            p *= nums[i - <span class="number">1</span>];</span><br><span class="line">            res[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            p *= nums[i + <span class="number">1</span>];</span><br><span class="line">            res[i] *= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>273. Integer to English Words</title>
    <url>/2020/11/22/273-Integer-to-English-Words/</url>
    <content><![CDATA[<p>recursive</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="number">1e9</span>, <span class="string">"Billion"</span>&#125;, &#123;<span class="number">1e6</span>, <span class="string">"Million"</span>&#125;, &#123;<span class="number">1e3</span>, <span class="string">"Thousand"</span>&#125;, &#123;<span class="number">100</span>, <span class="string">"Hundred"</span>&#125;,</span><br><span class="line">    &#123;<span class="number">90</span>, <span class="string">"Ninety"</span>&#125;, &#123;<span class="number">80</span>, <span class="string">"Eighty"</span>&#125;, &#123;<span class="number">70</span>, <span class="string">"Seventy"</span>&#125;, &#123;<span class="number">60</span>, <span class="string">"Sixty"</span>&#125;, &#123;<span class="number">50</span>, <span class="string">"Fifty"</span>&#125;, &#123;<span class="number">40</span>, <span class="string">"Forty"</span>&#125;, &#123;<span class="number">30</span>, <span class="string">"Thirty"</span>&#125;, &#123;<span class="number">20</span>, <span class="string">"Twenty"</span>&#125;,</span><br><span class="line">    &#123;<span class="number">19</span>, <span class="string">"Nineteen"</span>&#125;, &#123;<span class="number">18</span>, <span class="string">"Eighteen"</span>&#125;, &#123;<span class="number">17</span>, <span class="string">"Seventeen"</span>&#125;, &#123;<span class="number">16</span>, <span class="string">"Sixteen"</span>&#125;, &#123;<span class="number">15</span>, <span class="string">"Fifteen"</span>&#125;, &#123;<span class="number">14</span>, <span class="string">"Fourteen"</span>&#125;, &#123;<span class="number">13</span>, <span class="string">"Thirteen"</span>&#125;, &#123;<span class="number">12</span>, <span class="string">"Twelve"</span>&#125;, &#123;<span class="number">11</span>, <span class="string">"Eleven"</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="string">"Ten"</span>&#125;, &#123;<span class="number">9</span>, <span class="string">"Nine"</span>&#125;, &#123;<span class="number">8</span>, <span class="string">"Eight"</span>&#125;, &#123;<span class="number">7</span>, <span class="string">"Seven"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"Six"</span>&#125;, &#123;<span class="number">5</span>, <span class="string">"Five"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"Four"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"Three"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"Two"</span>&#125;, &#123;<span class="number">1</span>, <span class="string">"One"</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="string">"Zero"</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">numberToWords</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1e9</span>, <span class="number">1e6</span>, <span class="number">1e3</span>, <span class="number">100</span>&#125;; <span class="comment">// 100以上的数统一处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= x) &#123;</span><br><span class="line">                res.append(numberToWords(num / x)).append(<span class="string">" "</span>).append(m[x]);</span><br><span class="line">                num %= x;</span><br><span class="line">                <span class="keyword">return</span> num &gt; <span class="number">0</span> ? res.append(<span class="string">" "</span>).append(numberToWords(num)) : res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">20</span>) &#123; <span class="comment">// 100以内20以上的数统一处理</span></span><br><span class="line">            res.append(m[num - num % <span class="number">10</span>]);</span><br><span class="line">            num %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> num &gt; <span class="number">0</span> ? res.append(<span class="string">" "</span>).append(numberToWords(num)) : res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[num]; <span class="comment">// 20以内的数直接查表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="number">1e9</span>, <span class="string">"Billion"</span>&#125;, &#123;<span class="number">1e6</span>, <span class="string">"Million"</span>&#125;, &#123;<span class="number">1e3</span>, <span class="string">"Thousand"</span>&#125;, &#123;<span class="number">100</span>, <span class="string">"Hundred"</span>&#125;,</span><br><span class="line">    &#123;<span class="number">90</span>, <span class="string">"Ninety"</span>&#125;, &#123;<span class="number">80</span>, <span class="string">"Eighty"</span>&#125;, &#123;<span class="number">70</span>, <span class="string">"Seventy"</span>&#125;, &#123;<span class="number">60</span>, <span class="string">"Sixty"</span>&#125;, &#123;<span class="number">50</span>, <span class="string">"Fifty"</span>&#125;, &#123;<span class="number">40</span>, <span class="string">"Forty"</span>&#125;, &#123;<span class="number">30</span>, <span class="string">"Thirty"</span>&#125;, &#123;<span class="number">20</span>, <span class="string">"Twenty"</span>&#125;,</span><br><span class="line">    &#123;<span class="number">19</span>, <span class="string">"Nineteen"</span>&#125;, &#123;<span class="number">18</span>, <span class="string">"Eighteen"</span>&#125;, &#123;<span class="number">17</span>, <span class="string">"Seventeen"</span>&#125;, &#123;<span class="number">16</span>, <span class="string">"Sixteen"</span>&#125;, &#123;<span class="number">15</span>, <span class="string">"Fifteen"</span>&#125;, &#123;<span class="number">14</span>, <span class="string">"Fourteen"</span>&#125;, &#123;<span class="number">13</span>, <span class="string">"Thirteen"</span>&#125;, &#123;<span class="number">12</span>, <span class="string">"Twelve"</span>&#125;, &#123;<span class="number">11</span>, <span class="string">"Eleven"</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="string">"Ten"</span>&#125;, &#123;<span class="number">9</span>, <span class="string">"Nine"</span>&#125;, &#123;<span class="number">8</span>, <span class="string">"Eight"</span>&#125;, &#123;<span class="number">7</span>, <span class="string">"Seven"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"Six"</span>&#125;, &#123;<span class="number">5</span>, <span class="string">"Five"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"Four"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"Three"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"Two"</span>&#125;, &#123;<span class="number">1</span>, <span class="string">"One"</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="string">"Zero"</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">numberToWords</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1000000000</span>, <span class="number">1000000</span>, <span class="number">1000</span>, <span class="number">100</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> it = lower_bound(<span class="built_in">begin</span>(v), <span class="built_in">end</span>(v), num, greater&lt;&gt;()); it != <span class="built_in">end</span>(v)) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = *it;</span><br><span class="line">            res.append(numberToWords(num / x).append(<span class="string">" "</span>).append(m[x]));</span><br><span class="line">            num %= x;</span><br><span class="line">            <span class="keyword">return</span> num &gt; <span class="number">0</span> ? res.append(<span class="string">" "</span>).append(numberToWords(num)) : res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">20</span>) &#123;</span><br><span class="line">            res.append(m[num - num % <span class="number">10</span>]);</span><br><span class="line">            num %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> num &gt; <span class="number">0</span> ? res.append(<span class="string">" "</span>).append(numberToWords(num)) : res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Integer</tag>
      </tags>
  </entry>
  <entry>
    <title>415. Add Strings</title>
    <url>/2020/11/22/415-Add-Strings/</url>
    <content><![CDATA[<p>O(m+n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">             i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || c &gt; <span class="number">0</span>;</span><br><span class="line">             --i, --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = i &lt; <span class="number">0</span> ? <span class="number">0</span> : (num1[i] - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">int</span> b = j &lt; <span class="number">0</span> ? <span class="number">0</span> : (num2[j] - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">int</span> s = a + b + c;</span><br><span class="line">            res += <span class="string">'0'</span> + s % <span class="number">10</span>;</span><br><span class="line">            c = s / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(rbegin(res), rend(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Addition</tag>
      </tags>
  </entry>
  <entry>
    <title>560. Subarray Sum Equals K</title>
    <url>/2020/11/22/560-Subarray-Sum-Equals-K/</url>
    <content><![CDATA[<p>O(n) 在遍历每个数的过程中用hashmap把已经算过的前缀和存起来，之后只需要查看目标前缀和的个数即可<br>初始化要加入{0,1}这对映射，这是为啥呢，因为我们的解题思路是遍历数组中的数字，用sum来记录到当前位置的累加和，我们建立哈希表的目的是为了让我们可以快速的查找sum-k是否存在，即是否有连续子数组的和为sum-k，如果存在的话，那么和为k的子数组一定也存在，这样当sum刚好为k的时候，那么数组从起始到当前位置的这段子数组的和就是k，满足题意，如果哈希表中事先没有m[0]项的话，这个符合题意的结果就无法累加到结果res中，这就是初始化的用途</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            s += x;</span><br><span class="line">            res += m[s - k];</span><br><span class="line">            ++m[s];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>O(n^2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                res += (sum[i] + k == sum[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
        <tag>Prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>67. Add Binary</title>
    <url>/2020/11/22/67-Add-Binary/</url>
    <content><![CDATA[<p>O(max(m, n)) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>, i = a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>;</span><br><span class="line">            i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || c &gt; <span class="number">0</span>;</span><br><span class="line">            --i, --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &lt; <span class="number">0</span> ? <span class="number">0</span> : (a[i] - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">int</span> y = j &lt; <span class="number">0</span> ? <span class="number">0</span> : (b[j] - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">int</span> s = x + y + c;</span><br><span class="line">            res += <span class="string">'0'</span> + (s &amp; <span class="number">1</span>);</span><br><span class="line">            c = s &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(rbegin(res), rend(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.empty()) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span> (b.empty()) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span> (!a.empty() || !b.empty() || c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a.empty() ? <span class="number">0</span> : (a.back() - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">int</span> y = b.empty() ? <span class="number">0</span> : (b.back() - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span> (!a.empty()) &#123;</span><br><span class="line">                a.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!b.empty()) &#123;</span><br><span class="line">                b.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> s = x + y + c;</span><br><span class="line">            res += <span class="string">'0'</span> + (s &amp; <span class="number">1</span>);</span><br><span class="line">            c = (s &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(rbegin(res), rend(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Addition</tag>
      </tags>
  </entry>
  <entry>
    <title>973. K Closest Points to Origin</title>
    <url>/2020/11/22/973-K-Closest-Points-to-Origin/</url>
    <content><![CDATA[<p>quickselection<br>O(n) time on average O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">kClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>(), l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = partition(points, l, r);</span><br><span class="line">            <span class="keyword">if</span> (k == K - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; K - <span class="number">1</span>) &#123;</span><br><span class="line">                l = k + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = k - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="built_in">begin</span>(points), <span class="built_in">begin</span>(points) + K);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;l, l + (r - l) / <span class="number">2</span>, r&#125;;</span><br><span class="line">        swap(p[l], p[v[rand() % <span class="number">3</span>]]);</span><br><span class="line">        <span class="keyword">int</span> j = l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lt(p[i], p[l])) &#123;</span><br><span class="line">                swap(p[i], p[j++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(p[--j], p[l]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lt</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] * a[<span class="number">0</span>] + a[<span class="number">1</span>] * a[<span class="number">1</span>] &lt; b[<span class="number">0</span>] * b[<span class="number">0</span>] + b[<span class="number">1</span>] * b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">kClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>(), l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = partition(points, l, r);</span><br><span class="line">            <span class="keyword">if</span> (k == K - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; K - <span class="number">1</span>) &#123;</span><br><span class="line">                l = k + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = k - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="built_in">begin</span>(points), <span class="built_in">begin</span>(points) + K);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;l, l + (r - l) / <span class="number">2</span>, r&#125;;</span><br><span class="line">        swap(p[l], p[v[rand() % <span class="number">3</span>]]);</span><br><span class="line">        <span class="keyword">auto</span> pivot = p[l];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !lt(p[r], pivot)) --r;</span><br><span class="line">            p[l] = p[r];</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; lt(p[l], pivot)) ++l;</span><br><span class="line">            p[r] = p[l];</span><br><span class="line">        &#125;</span><br><span class="line">        p[l] = pivot;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lt</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] * a[<span class="number">0</span>] + a[<span class="number">1</span>] * a[<span class="number">1</span>] &lt; b[<span class="number">0</span>] * b[<span class="number">0</span>] + b[<span class="number">1</span>] * b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>O(nlogK) time O(K) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">kClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">using</span> vi = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">        <span class="keyword">auto</span> less = [](<span class="keyword">const</span> vi &amp;a, <span class="keyword">const</span> vi &amp;b)&#123;<span class="keyword">return</span> a[<span class="number">0</span>] * a[<span class="number">0</span>] + a[<span class="number">1</span>] * a[<span class="number">1</span>] &lt; b[<span class="number">0</span>] * b[<span class="number">0</span>] + b[<span class="number">1</span>] * b[<span class="number">1</span>];&#125;;</span><br><span class="line">        priority_queue&lt;vi, vector&lt;vi&gt;, decltype(less)&gt; q(less);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : points) &#123;</span><br><span class="line">            q.push(p);</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; K) &#123;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;vi&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            res.push_back(q.top());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>O(nlog(n-K)) time O(n-K) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">kClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">using</span> vi = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">        <span class="keyword">auto</span> greater = [](<span class="keyword">const</span> vi &amp;p1, <span class="keyword">const</span> vi &amp;p2) &#123;<span class="keyword">return</span> p1[<span class="number">0</span>] * p1[<span class="number">0</span>] + p1[<span class="number">1</span>] * p1[<span class="number">1</span>] &gt; p2[<span class="number">0</span>] * p2[<span class="number">0</span>] + p2[<span class="number">1</span>] * p2[<span class="number">1</span>];&#125;;</span><br><span class="line">        priority_queue&lt;vi, vector&lt;vi&gt;, decltype(greater)&gt; q(greater);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : points) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &lt; n - K) &#123;</span><br><span class="line">                q.push(p);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (greater(p, q.top())) &#123;</span><br><span class="line">                res.push_back(q.top());</span><br><span class="line">                q.pop();</span><br><span class="line">                q.push(p);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Heap</tag>
        <tag>Leetcode</tag>
        <tag>Quickselect</tag>
      </tags>
  </entry>
  <entry>
    <title>680. Valid Palindrome II</title>
    <url>/2020/11/22/680-Valid-Palindrome-II/</url>
    <content><![CDATA[<p>O(n) 两个指针l和r从外往内扫描，如果遇到两个字符s[l]和s[r]不一样，则分别判断s[l:r-1]和s[l+1:r]是不是回文串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = s.length(), l = <span class="number">0</span>, r = n - <span class="number">1</span>; l &lt; r; ++l, --r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l] != s[r]) &#123;</span><br><span class="line">                <span class="keyword">return</span> isPalin(s, l, r - <span class="number">1</span>) || isPalin(s, l + <span class="number">1</span>, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalin</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l++] != s[r--]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l] != s[r]) &#123;</span><br><span class="line">                ++cnt1;</span><br><span class="line">                <span class="keyword">if</span> (cnt1 &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[l + <span class="number">1</span>] == s[r]) &#123;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[l] == s[r - <span class="number">1</span>]) &#123;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">        l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l] != s[r]) &#123;</span><br><span class="line">                ++cnt2;</span><br><span class="line">                <span class="keyword">if</span> (cnt2 &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[l] == s[r - <span class="number">1</span>]) &#123;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[l + <span class="number">1</span>] == s[r]) &#123;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt1 &lt; <span class="number">2</span> || cnt2 &lt; <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Palindrome</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>size_t overflow</title>
    <url>/2020/11/22/size-t-overflow/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// your code goes here</span></span><br><span class="line">	<span class="keyword">size_t</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">auto</span> j = x - <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 18446744073709551615</span></span><br><span class="line">	<span class="keyword">int</span> i = j;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// -1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>125. Valid Palindrome</title>
    <url>/2020/11/22/125-Valid-Palindrome/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = s.length() - <span class="number">1</span>; l &lt; r; ++l, --r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !<span class="built_in">isalnum</span>(s[l])) ++l;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !<span class="built_in">isalnum</span>(s[r])) --r;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[l]) != <span class="built_in">tolower</span>(s[r])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !<span class="built_in">isalnum</span>(s[l])) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !<span class="built_in">isalnum</span>(s[r])) &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[l]) != <span class="built_in">tolower</span>(s[r])) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// uniform case!!</span></span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Palindrome</tag>
      </tags>
  </entry>
  <entry>
    <title>1570. Dot Product of Two Sparse Vectors</title>
    <url>/2020/11/22/1570-Dot-Product-of-Two-Sparse-Vectors/</url>
    <content><![CDATA[<p>拉链法 或者 加 二分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseVector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    SparseVector(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]) &#123;</span><br><span class="line">                v.emplace_back(i, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIdx</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v[i].first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v[i].second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> e, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::lower_bound(<span class="built_in">begin</span>(v) + b, <span class="built_in">begin</span>(v) + e, idx, [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p, <span class="keyword">int</span> idx)&#123; <span class="keyword">return</span> p.first &lt; idx; &#125;) - <span class="built_in">begin</span>(v); <span class="comment">// 这个lambda相当于实现一个less，即找到第一个不小于的为止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the dotProduct of two sparse vectors</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dotProduct</span><span class="params">(SparseVector&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, m = getDim(), n = vec.getDim(); i &lt; m &amp;&amp; j &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">int</span> ii = getIdx(i), ij = vec.getIdx(j);</span><br><span class="line">            <span class="keyword">if</span> (ii == ij) &#123;</span><br><span class="line">                res += getNum(i++) * vec.getNum(j++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ii &lt; ij) &#123;</span><br><span class="line">                i = lower_bound(i + <span class="number">1</span>, m, ij);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = vec.lower_bound(j + <span class="number">1</span>, n, ii);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your SparseVector object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// SparseVector v1(nums1);</span></span><br><span class="line"><span class="comment">// SparseVector v2(nums2);</span></span><br><span class="line"><span class="comment">// int ans = v1.dotProduct(v2);</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Merging</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>211. Design Add and Search Words Data Structure</title>
    <url>/2020/11/22/211-Design-Add-and-Search-Words-Data-Structure/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        TrieNode *children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="keyword">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TrieNode *root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    WordDictionary() : root(<span class="keyword">new</span> TrieNode) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : <span class="keyword">word</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = c - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children[k]) &#123;</span><br><span class="line">                p-&gt;children[k] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;children[k];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> search(<span class="keyword">word</span>, <span class="number">0</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;w, <span class="keyword">int</span> i, TrieNode *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == w.length()) <span class="keyword">return</span> p-&gt;isEnd;</span><br><span class="line">        <span class="keyword">if</span> (w[i] != <span class="string">'.'</span>) <span class="keyword">return</span> search(w, i + <span class="number">1</span>, p-&gt;children[w[i] - <span class="string">'a'</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (search(w, i + <span class="number">1</span>, p-&gt;children[k])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary* obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addWord(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>215. Kth Largest Element in an Array</title>
    <url>/2020/11/22/215-Kth-Largest-Element-in-an-Array/</url>
    <content><![CDATA[<p>quickselect O(n) on avg</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = partition(nums, l, r);</span><br><span class="line">            <span class="keyword">if</span> (m == k - <span class="number">1</span>) <span class="keyword">return</span> nums[m];</span><br><span class="line">            <span class="keyword">if</span> (m &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;l, l + (r - l) / <span class="number">2</span>, r&#125;;</span><br><span class="line">        swap(A[l], A[v[rand() % <span class="number">3</span>]]);</span><br><span class="line">        <span class="keyword">int</span> j = l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[l]) &#123;</span><br><span class="line">                swap(A[i], A[j++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(A[--j], A[l]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = partition(nums, l, r);</span><br><span class="line">            <span class="keyword">if</span> (i == k - <span class="number">1</span>) <span class="keyword">return</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">                r = i - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;l, (l + r) / <span class="number">2</span>, r&#125;;</span><br><span class="line">        swap(nums[l], nums[v[rand() % <span class="number">3</span>]]);</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[l];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] &lt;= pivot) &#123; <span class="comment">// 因为是求第k大所以要降序</span></span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[l] = nums[r];</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] &gt;= pivot) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[r] = nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l] = pivot;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>; <span class="comment">// 左右闭区间</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123; <span class="comment">// 要考虑l == r的情况</span></span><br><span class="line">            <span class="keyword">auto</span> i = partition(nums, l, r);</span><br><span class="line">            <span class="keyword">if</span> (i == k - <span class="number">1</span>) &#123; <span class="comment">// k是从1开始的</span></span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">                l = i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">int</span> l = left, r = right;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] &lt;= pivot) --r;</span><br><span class="line">            nums[l] = nums[r];</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] &gt;= pivot) ++l;</span><br><span class="line">            nums[r] = nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l] = pivot;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>O(nlogk) 最小堆里永远保存k个数，堆顶的数是当前第k大的数，如果一个数比堆顶的数大，则入堆，堆自动调整后，将堆顶多余的第k+1大的数弹出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">                h.push(n);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h.top() &lt; n) &#123;</span><br><span class="line">                h.pop();</span><br><span class="line">                h.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Quickselect</tag>
      </tags>
  </entry>
  <entry>
    <title>523. Continuous Subarray Sum</title>
    <url>/2020/11/22/523-Continuous-Subarray-Sum/</url>
    <content><![CDATA[<p>同余 O(n) time O(n) space<br>a % k = c<br>(a + sum) % k = c<br>sum % k = 0<br>需要sum的数字个数大于1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// 利用一个map保存&lt;前缀和余数, 下标&gt;</span></span><br><span class="line">        m[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 因为连续的子数组是从头开始的，则需要提前先保存一个余数0</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="number">0</span>) sum %= k; <span class="comment">// k如果是0，跳过即可</span></span><br><span class="line">            <span class="keyword">if</span> (m.count(sum)) &#123; <span class="comment">// 如果map里没有当前余数，保存即可，否则检查是否相隔至少2个数</span></span><br><span class="line">                 <span class="keyword">if</span> (i - m[sum] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这个if不能跟上一层的merge！！！因为有可能有相邻的</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>前缀和O(n^2) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">presum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            presum[i] = presum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n - <span class="number">1</span>; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - len; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len;</span><br><span class="line">                <span class="keyword">int</span> sum = presum[j + <span class="number">1</span>] - presum[i];</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sum == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum / k * k == sum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>301. Remove Invalid Parentheses</title>
    <url>/2020/11/22/301-Remove-Invalid-Parentheses/</url>
    <content><![CDATA[<p>time worst case O(n^2) “)a)a)a)a)a” 因为需要最后的结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">remove</span>(s, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'('</span>, <span class="string">')'</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> sb, <span class="keyword">int</span> rb, <span class="keyword">char</span> lp, <span class="keyword">char</span> rp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">int</span> i = search(s, sb, lp, rp); i == s.length()) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">t</span><span class="params">(rbegin(s), rend(s))</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (lp == <span class="string">'('</span>) &#123;</span><br><span class="line">                <span class="built_in">remove</span>(t, <span class="number">0</span>, <span class="number">0</span>, rp, lp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rb; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == rp &amp;&amp; (j == rb || s[j] != s[j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    <span class="built_in">remove</span>(s.substr(<span class="number">0</span>, j) + s.substr(j + <span class="number">1</span>), i, j, lp, rp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> b, <span class="keyword">char</span> lp, <span class="keyword">char</span> rp)</span> </span>&#123; <span class="comment">// 找到第一个不匹配的右括号</span></span><br><span class="line">        <span class="keyword">int</span> i = b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            cnt += (s[i] == rp) ? <span class="number">-1</span> : (s[i] == lp);</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">remove</span>(s, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'('</span>, <span class="string">')'</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> sb, <span class="keyword">int</span> rb, <span class="keyword">char</span> lp, <span class="keyword">char</span> rp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = sb, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; cnt &gt;= <span class="number">0</span>) &#123; <span class="comment">// 遍历字符串直到找到第一个匹配不上的『右括号』</span></span><br><span class="line">            cnt += (s[i] == rp ? <span class="number">-1</span> : s[i] == lp); <span class="comment">// 注意字符串里可能还有非左右括号的字符</span></span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">0</span>) &#123; <span class="comment">// 如果没有匹配不上的『右括号』则翻转字符串尝试删除匹配不上的『左括号』</span></span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">t</span><span class="params">(rbegin(s), rend(s))</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (lp == <span class="string">'('</span>) &#123;</span><br><span class="line">                <span class="built_in">remove</span>(t, <span class="number">0</span>, <span class="number">0</span>, rp, lp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果两种case都已经尝试过了，则当前字符串已经全部匹配</span></span><br><span class="line">                res.push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当找到第一个匹配不上的『右括号』</span></span><br><span class="line">            --i; <span class="comment">// 先回退到这个匹配不上的『右括号』</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rb; j &lt;= i; ++j) &#123; <span class="comment">// 从上次删除过的位置开始一直到当前这个匹配不上的为止，尝试删除『右括号』并拼成新字符串</span></span><br><span class="line">                <span class="keyword">if</span> (s[j] == rp &amp;&amp; (j == rb || s[j - <span class="number">1</span>] != s[j])) &#123; <span class="comment">// 跳过连续『右括号』去重</span></span><br><span class="line">                    <span class="built_in">remove</span>(s.substr(<span class="number">0</span>, j) + s.substr(j + <span class="number">1</span>), i, j, lp, rp); <span class="comment">// 下个iteration的删除要从这次删除的位置j开始</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>O(2^n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123; <span class="comment">// 先统计需要删除几个左括号和右括号（无法匹配）</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">                l &gt; <span class="number">0</span> ? --l : ++r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(s, <span class="number">0</span>, l, r);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> b, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span>) &#123; <span class="comment">// 如果多余的左括号和右括号都已经删除</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(s)) <span class="comment">// 判断当前的字符串是否合法（因为是盲删的所以可能得到的字符串不合法）</span></span><br><span class="line">                res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; b &amp;&amp; s[i - <span class="number">1</span>] == s[i]) <span class="keyword">continue</span>; <span class="comment">// 去重，比如连续两个右括号，删一个即可</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span> &amp;&amp; l &gt; <span class="number">0</span>) &#123; <span class="comment">// 盲删左括号</span></span><br><span class="line">                helper(s.substr(<span class="number">0</span>, i) + s.substr(i + <span class="number">1</span>), i, l - <span class="number">1</span>, r); <span class="comment">// 从i开始也是一种去重</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span> &amp;&amp; r &gt; <span class="number">0</span>) &#123; <span class="comment">// 盲删右括号</span></span><br><span class="line">                helper(s.substr(<span class="number">0</span>, i) + s.substr(i + <span class="number">1</span>), i, l, r - <span class="number">1</span>); <span class="comment">// 切记不要用s.erase因为是循环删除，所以前面删除以后会影响后边</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--cnt &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Parentheses</tag>
      </tags>
  </entry>
  <entry>
    <title>721. Accounts Merge</title>
    <url>/2020/11/23/721-Accounts-Merge/</url>
    <content><![CDATA[<p>union-find O(sum(Ai logAi)) time O(sum(Ai)) space where Ai = accounts[i].length()<br>用一个hashmap维护email和其对应的accounts的下标i<br>当不同account有相同的email时，merge对应的两个下标<br>最后整理原来accounts每个下标对应的所有email以及name即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">accountsMerge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n = accounts.<span class="built_in">size</span>();</span><br><span class="line">        parent.resize(n);</span><br><span class="line">        iota(<span class="built_in">begin</span>(parent), <span class="built_in">end</span>(parent), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; accounts[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m.count(accounts[i][j])) &#123;</span><br><span class="line">                    merge(m[accounts[i][j]], i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    m[accounts[i][j]] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[s, i] : m) &#123;</span><br><span class="line">            v[<span class="built_in">find</span>(i)].insert(s); <span class="comment">// 归并email</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i].empty()) <span class="keyword">continue</span>;</span><br><span class="line">            res.push_back(&#123;accounts[i][<span class="number">0</span>]&#125;); <span class="comment">// 归并email和name</span></span><br><span class="line">            res.back().insert(<span class="built_in">end</span>(res.back()), <span class="built_in">begin</span>(v[i]), <span class="built_in">end</span>(v[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">            x = parent[x] = parent[parent[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        parent[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">accountsMerge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; email2id;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; email2name;</span><br><span class="line">        UF uf;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;a : accounts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!email2id.count(a[<span class="number">1</span>])) &#123;</span><br><span class="line">                    email2id[a[<span class="number">1</span>]] = id++;</span><br><span class="line">                    email2name[a[<span class="number">1</span>]] = a[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                uf.add(email2id[a[<span class="number">1</span>]]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!email2id.count(a[i])) &#123;</span><br><span class="line">                        email2id[a[i]] = id++;</span><br><span class="line">                        email2name[a[i]] = a[<span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    uf.add(email2id[a[i]]);</span><br><span class="line">                    uf.merge(email2id[a[<span class="number">1</span>]], email2id[a[i]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : email2id) &#123;</span><br><span class="line">            m[uf.getParent(email2id[p.first])].insert(p.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : m) &#123;</span><br><span class="line">            res.push_back(&#123;email2name[*p.second.<span class="built_in">begin</span>()]&#125;);</span><br><span class="line">            res.back().insert(res.back().<span class="built_in">end</span>(), p.second.<span class="built_in">begin</span>(), p.second.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UF</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (parent.count(x)) <span class="keyword">return</span>;</span><br><span class="line">            parent[x] = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getParent</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">                x = parent[x] = parent[parent[x]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            parent[getParent(x)] = getParent(y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; parent;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">accountsMerge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, pair&lt;<span class="built_in">string</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt;&gt; m;</span><br><span class="line">        UF uf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;a : accounts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                uf.add(a[<span class="number">1</span>]);</span><br><span class="line">                m[a[<span class="number">1</span>]].first = a[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                    uf.add(a[i]);</span><br><span class="line">                    m[a[i]].first = a[<span class="number">0</span>];</span><br><span class="line">                    uf.merge(a[<span class="number">1</span>], a[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : m) &#123;</span><br><span class="line">            m[uf.getParent(p.first)].second.insert(p.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p.second.second.empty()) &#123;</span><br><span class="line">                res.push_back(&#123;p.second.first&#125;);</span><br><span class="line">                res.back().insert(res.back().<span class="built_in">end</span>(), p.second.second.<span class="built_in">begin</span>(), p.second.second.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UF</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (parent.count(s)) <span class="keyword">return</span>;</span><br><span class="line">            parent[s] = s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">getParent</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (parent[s] != s) &#123;</span><br><span class="line">                s = parent[s] = parent[parent[s]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent[s];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;x, <span class="keyword">const</span> <span class="built_in">string</span> &amp;y)</span> </span>&#123;</span><br><span class="line">            parent[getParent(x)] = getParent(y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; parent;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>173. Binary Search Tree Iterator</title>
    <url>/2020/11/27/173-Binary-Search-Tree-Iterator/</url>
    <content><![CDATA[<p>amortized O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BSTIterator(TreeNode *root) &#123;</span><br><span class="line">        pushAllLeft(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !s.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">node</span><span class="params">(s.top())</span></span>;</span><br><span class="line">        s.pop();</span><br><span class="line">        pushAllLeft(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushAllLeft</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator will be called like this:</span></span><br><span class="line"><span class="comment"> * BSTIterator i = BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>preorder iterator</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BSTIterator(TreeNode *root) &#123;</span><br><span class="line">        s.push(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !s.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = s.top(); s.pop();</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">            s.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">            s.push(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator will be called like this:</span></span><br><span class="line"><span class="comment"> * BSTIterator i = BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
        <tag>Binary search tree</tag>
      </tags>
  </entry>
  <entry>
    <title>282. Expression Add Operators</title>
    <url>/2020/11/27/282-Expression-Add-Operators/</url>
    <content><![CDATA[<p>exponential O(n * 4^n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">addOperators</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="string">""</span>, <span class="number">0</span>, num, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">long</span> sum, <span class="keyword">long</span> last_num, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> b, <span class="keyword">const</span> <span class="built_in">string</span> &amp;num, <span class="keyword">const</span> <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target &amp;&amp; b == num.length()) &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> curr_s;</span><br><span class="line">        <span class="keyword">long</span> curr_num = <span class="number">0</span>; <span class="comment">// 必须用long防止溢出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; num.length(); ++i) &#123;</span><br><span class="line">            curr_s += num[i];</span><br><span class="line">            curr_num = curr_num * <span class="number">10</span> + num[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">0</span>) &#123; <span class="comment">// +3456-23-74+90是错的，第一个数字前不能有符号</span></span><br><span class="line">                dfs(curr_num, curr_num, curr_s, i + <span class="number">1</span>, num, target);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dfs(sum + curr_num, curr_num, s + <span class="string">'+'</span> + curr_s, i + <span class="number">1</span>, num, target);</span><br><span class="line">                dfs(sum - curr_num, -curr_num, s + <span class="string">'-'</span> + curr_s, i + <span class="number">1</span>, num, target);</span><br><span class="line">                dfs(sum - last_num + last_num * curr_num, last_num * curr_num, s + <span class="string">'*'</span> + curr_s, i + <span class="number">1</span>, num, target);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num[b] == <span class="string">'0'</span>) &#123; <span class="comment">// 数字不能以0开始，2534+034是错的</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
        <tag>Depth first search</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>297. Serialize and Deserialize Binary Tree</title>
    <url>/2020/11/26/297-Serialize-and-Deserialize-Binary-Tree/</url>
    <content><![CDATA[<p>O(n) BFS<br>“1 2 3 # # 4 5 # # # # “</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> n = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (n) &#123;</span><br><span class="line">                res += to_string(n-&gt;val);</span><br><span class="line">                q.push(n-&gt;left);</span><br><span class="line">                q.push(n-&gt;right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += <span class="string">"#"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="function">TreeNode <span class="title">dummy_root</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">bool</span>, TreeNode *&gt;&gt; q&#123;&#123;&#123;<span class="literal">true</span>, &amp;dummy_root&#125;&#125;&#125;;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">while</span> (input &gt;&gt; s) &#123;</span><br><span class="line">            TreeNode *n = (s == <span class="string">"#"</span> ? <span class="literal">nullptr</span> : <span class="keyword">new</span> TreeNode(stoi(s)));</span><br><span class="line">            <span class="keyword">if</span> (q.front().first) &#123;</span><br><span class="line">                q.front().second-&gt;right = n;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                q.front().second-&gt;left = n;</span><br><span class="line">                q.front().first = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n) &#123; <span class="comment">// 这里要检查是否是空指针，因为要对queue里的指针设左右子树，不能出现空指针</span></span><br><span class="line">                q.emplace(<span class="literal">false</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>

<p>preorder dfs<br>“1 2 # # 3 4 # # 5 # # “</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root ? to_string(root-&gt;val) + <span class="string">" "</span> + serialize(root-&gt;left) + serialize(root-&gt;right) : <span class="string">"# "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> deserialize(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">deserialize</span><span class="params">(<span class="built_in">istringstream</span> &amp;input)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">if</span> (input &gt;&gt; s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="string">"#"</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">auto</span> res = <span class="keyword">new</span> TreeNode(stoi(s));</span><br><span class="line">            res-&gt;left = deserialize(input);</span><br><span class="line">            res-&gt;right = deserialize(input);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Breadth first search</tag>
        <tag>Serialization</tag>
      </tags>
  </entry>
  <entry>
    <title>278. First Bad Version</title>
    <url>/2020/11/26/278-First-Bad-Version/</url>
    <content><![CDATA[<p>binary search O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of isBadVersion API.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBadVersion</span><span class="params">(<span class="keyword">int</span> version)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(m)) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>426. Convert Binary Search Tree to Sorted Doubly Linked List</title>
    <url>/2020/11/27/426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List/</url>
    <content><![CDATA[<p>inorder dfs O(n) time O(h) space<br>维护一个prev用root更新prev，因为prev一直被更新，所以到最后prev就是tail，最后连接head和prev（即tail）即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root; <span class="comment">// 注意这里必须提前判空，因为后边不好处理</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">auto</span> head = dummy_head.right;</span><br><span class="line">        head-&gt;left = prev;</span><br><span class="line">        prev-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        prev-&gt;right = root;</span><br><span class="line">        root-&gt;left = prev;</span><br><span class="line">        prev = root;</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node dummy_head, *prev = &amp;dummy_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Linked list</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>438. Find All Anagrams in a String</title>
    <url>/2020/11/26/438-Find-All-Anagrams-in-a-String/</url>
    <content><![CDATA[<p>sliding window O(m+n) time O(1) space<br>跟<a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener">30. Substring with Concatenation of All Words</a>解法基本一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : p) &#123;</span><br><span class="line">            ++f[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = s.length(), n = p.length(), cnt = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--f[s[i] - <span class="string">'a'</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= n &amp;&amp; ++f[s[i - n] - <span class="string">'a'</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                --cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt == n) &#123;</span><br><span class="line">                res.push_back(i - n + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        vector&lt;int&gt; mp(26), mc(26);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : p) &#123;</span><br><span class="line">            ++mp[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> m = p.length(), n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ++mc[s[i] - <span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= m - <span class="number">1</span>) &#123; <span class="comment">// 从m - 1开始就进行判断，避免在结尾处理的麻烦</span></span><br><span class="line">                <span class="keyword">if</span> (mc == mp) &#123;</span><br><span class="line">                    res.push_back(i - m + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                --mc[s[i - m + <span class="number">1</span>] - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>636. Exclusive Time of Functions</title>
    <url>/2020/11/27/636-Exclusive-Time-of-Functions/</url>
    <content><![CDATA[<p>stack类似括号匹配O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exclusiveTime</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; logs)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;l : logs) &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = parse(l);</span><br><span class="line">            <span class="keyword">if</span> (e[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = e[<span class="number">2</span>] - s.top()[<span class="number">2</span>] + <span class="number">1</span>; <span class="comment">// 先计算最近一个线程的时间</span></span><br><span class="line">                res[e[<span class="number">0</span>]] += t; <span class="comment">// 修改最近一个线程的时间</span></span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span> (!s.empty()) &#123; <span class="comment">// 如果前面还有别的线程被阻塞</span></span><br><span class="line">                    res[s.top()[<span class="number">0</span>]] -= t; <span class="comment">// 从那个线程上减去最近这个线程的运行时间</span></span><br><span class="line">                    <span class="comment">// s.top()[2] += t; 是错的因为只考虑了局部，这道题必须从全局考虑，所以应该直接处理对应线程的最终结果，两层以上的nested call就是错的</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.push(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">parse</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = s.<span class="built_in">find</span>(<span class="string">":"</span>), p2 = s.<span class="built_in">find</span>(<span class="string">":"</span>, p1 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;stoi(s.substr(<span class="number">0</span>, p1)), s.substr(p1 + <span class="number">1</span>, p2 - p1 - <span class="number">1</span>) == <span class="string">"end"</span>, stoi(s.substr(p2 + <span class="number">1</span>))&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Log</span> &#123;</span></span><br><span class="line">        Log(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(s)</span></span>;</span><br><span class="line">            <span class="built_in">string</span> token;</span><br><span class="line">            getline(input, token, <span class="string">':'</span>);</span><br><span class="line">            id = stoi(token);</span><br><span class="line">            getline(input, e, <span class="string">':'</span>);</span><br><span class="line">            getline(input, token, <span class="string">':'</span>);</span><br><span class="line">            time = stoi(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="built_in">string</span> e;</span><br><span class="line">        <span class="keyword">int</span> time;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exclusiveTime</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; logs)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> sz = logs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">stack</span>&lt;Log&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<span class="built_in">log</span> : logs) &#123;</span><br><span class="line">            <span class="function">Log <span class="title">curr</span><span class="params">(<span class="built_in">log</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (curr.e == <span class="string">"start"</span>) &#123;</span><br><span class="line">                s.push(curr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log prev = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">int</span> interval = curr.time + <span class="number">1</span> - prev.time;</span><br><span class="line">                res[prev.id] += interval;</span><br><span class="line">                <span class="keyword">if</span> (!s.empty()) &#123; <span class="comment">// 这里很重要，父函数的实际运行时间不包括子函数的运行时间</span></span><br><span class="line">                    res[s.top().id] -= interval; <span class="comment">// s.top()是父函数，因为每次统计函数运行时间都是直接累加，所以要把子函数的运行时间『先』减掉</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>987. Vertical Order Traversal of a Binary Tree</title>
    <url>/2020/11/27/987-Vertical-Order-Traversal-of-a-Binary-Tree/</url>
    <content><![CDATA[<p>O(nlog(n/k)) time O(n) space<br>n是node数 k是column数 也是树的width<br>插入是O(n)<br>整理是O(k*(n/k)log(n/k)) = O(nlog(n/k))<br>跟<a href="https://leetcode.com/problems/binary-tree-vertical-order-traversal/" target="_blank" rel="noopener">314. Binary Tree Vertical Order Traversal</a>的区别是要相同位置的数要按大小排序，所以排序优先级是左右上下大小，因此必须维护行号，理论上bfs和dfs均可，但dfs代码简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">verticalTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(mx - mn + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;[i, v] : m) &#123;</span><br><span class="line">            sort(<span class="built_in">begin</span>(v), <span class="built_in">end</span>(v));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[j, val] : v) &#123;</span><br><span class="line">                res[i - mn].push_back(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        m[i].emplace_back(j, root-&gt;val);</span><br><span class="line">        mn = <span class="built_in">min</span>(mn, i);</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, i);</span><br><span class="line">        dfs(root-&gt;left, i - <span class="number">1</span>, j + <span class="number">1</span>); <span class="comment">// 因为要保证自顶向下的顺序所以这里一定要+1不能-1</span></span><br><span class="line">        dfs(root-&gt;right, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mn = INT_MAX, mx = INT_MIN;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>O(nlogn) time O(n) space<br>插入是O(nlogk) k是column数 也是树的width<br>整理是O(k*(n/k)log(n/k))<br>O(nlogk + k*(n/k)log(n/k)) = O(nlogk + nlog(n/k)) = O(nlog(k*(n/k))) = O(nlogn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">verticalTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">1000</span>, <span class="number">0</span>); <span class="comment">// 宽度从1000开始，层数从0开始</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> prev = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;p : m) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = p.first / <span class="number">1000</span>; <span class="comment">// 宽度即结果数组的row</span></span><br><span class="line">            <span class="keyword">if</span> (prev != curr) &#123;</span><br><span class="line">                res.push_back(&#123;&#125;);</span><br><span class="line">                prev = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            res.back().insert(<span class="built_in">end</span>(res.back()), <span class="built_in">begin</span>(p.second), <span class="built_in">end</span>(p.second));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        m[i * <span class="number">1000</span> + j].insert(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left, i - <span class="number">1</span>, j + <span class="number">1</span>); <span class="comment">// 因为要保证自顶向下的顺序所以这里一定要+1不能-1</span></span><br><span class="line">        dfs(root-&gt;right, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; m; <span class="comment">// 同一坐标的数按数大小来排序所以要用set</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果没有1000这个限制条件，则把一维map转换成二维map</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">verticalTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;[k, s] : m) &#123;</span><br><span class="line">            res.push_back(&#123;&#125;); <span class="comment">// 对于同一列要按照从上到下的顺序输出，同一位置再按大小输出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;[_, v] : s) &#123;</span><br><span class="line">                res.back().insert(<span class="built_in">end</span>(res.back()), <span class="built_in">begin</span>(v), <span class="built_in">end</span>(v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        m[i][j].insert(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left, i - <span class="number">1</span>, j + <span class="number">1</span>); <span class="comment">// 因为要保证自顶向下的顺序所以这里一定要+1不能-1</span></span><br><span class="line">        dfs(root-&gt;right, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Breadth first search</tag>
        <tag>Vertical order traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>314. Binary Tree Vertical Order Traversal</title>
    <url>/2020/11/28/314-Binary-Tree-Vertical-Order-Traversal/</url>
    <content><![CDATA[<p>bfs O(n) time 给每个node一个伪下标并维护最小最大下标，最后利用最小下标来还原真实下标<br>必须自顶向下自左向右 dfs如果不维护行号会违反 bfs完美符合不用维护行号只需要把每个数放到对应column即可所以选择bfs 即排序优先级是左右上下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">verticalOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, TreeNode *&gt;&gt; v;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, TreeNode *&gt;&gt; q;</span><br><span class="line">        q.emplace(<span class="number">0</span>, root);</span><br><span class="line">        <span class="keyword">int</span> mn = INT_MAX, mx = INT_MIN;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [idx, x] = q.front(); q.pop();</span><br><span class="line">            v.emplace_back(idx, x);</span><br><span class="line">            mn = <span class="built_in">min</span>(mn, idx);</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, idx);</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;left) &#123;</span><br><span class="line">                q.emplace(idx - <span class="number">1</span>, x-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;right) &#123;</span><br><span class="line">                q.emplace(idx + <span class="number">1</span>, x-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(mx - mn + <span class="number">1</span>)</span></span>; <span class="comment">// 利用最大最小下标提前分配内存</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [idx, x] : v) &#123;</span><br><span class="line">            res[idx - mn].push_back(x-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">verticalOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;TreeNode *&gt;&gt; m;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, TreeNode *&gt;&gt; q;</span><br><span class="line">        q.emplace(<span class="number">0</span>, root);</span><br><span class="line">        <span class="keyword">int</span> mn = INT_MAX, mx = INT_MIN;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">int</span> idx = p.first;</span><br><span class="line">            <span class="keyword">auto</span> x = p.second;</span><br><span class="line">            m[idx].push_back(x);</span><br><span class="line">            mn = <span class="built_in">min</span>(mn, idx);</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, idx);</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;left) &#123;</span><br><span class="line">                q.emplace(idx - <span class="number">1</span>, x-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;right) &#123;</span><br><span class="line">                q.emplace(idx + <span class="number">1</span>, x-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(mx - mn + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mn; i &lt;= mx; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> x : m[i]) &#123;</span><br><span class="line">                res[i - mn].push_back(x-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Vertical order traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>528. Random Pick with Weight</title>
    <url>/2020/11/28/528-Random-Pick-with-Weight/</url>
    <content><![CDATA[<p>O(logn) time O(n) space<br>[1, 3]是频数，即构造成下标数组[0, 1, 1, 1]然后随机一个index<br>累加频数，构造频数和数组[1, 4]，这里最后一个4是所有频数的和，即数组[0, 1, 1, 1]的长度，随机以后得到一个下标，需要得到下标所对应的原数组的index，因为频数和数组是递增的，所以二分可得到对应的频数和位置，即为原频数数组的下标</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w) &#123;</span><br><span class="line">        v = w;</span><br><span class="line">        partial_sum(<span class="built_in">begin</span>(v), <span class="built_in">end</span>(v), <span class="built_in">begin</span>(v), plus&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> upper_bound(<span class="built_in">begin</span>(v), <span class="built_in">end</span>(v), rand() % v.back()) - <span class="built_in">begin</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w) &#123;</span><br><span class="line">        v = w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            v[i] += v[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lower_bound(<span class="built_in">begin</span>(v), <span class="built_in">end</span>(v), (rand() % v.back() + <span class="number">1</span>)) - <span class="built_in">begin</span>(v); <span class="comment">// 加1恢复成1-indexed</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : w) &#123;</span><br><span class="line">            v.push_back(sum += x); <span class="comment">// 累加频数</span></span><br><span class="line">        &#125;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance(<span class="built_in">begin</span>(v), upper_bound(<span class="built_in">begin</span>(v), <span class="built_in">end</span>(v), rand() % v.back())); <span class="comment">// 这里要用upper_bound因为rand出来的是0-indexed，而频数本身是1-indexed，用lower_bound会找错，举例[1, 4]rand % 4出来的是下标1，而不是频数1，upper_bound找到的是频数和4，而lower_bound找到的是错误的频数和1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.com/problems/random-pick-with-weight/discuss/182620/Follow-up%3A-what-if-we-can-change-weights-array" target="_blank" rel="noopener">follow-up</a>如果weight数组是mutable的<br>用线段树，因为需要前缀和，把二分查找前缀和的上界改成二分查找区间和的上界，只是这个区间和是从0开始的<br>update O(logn)<br>query O(logn)<br>pickIndex O(logn*logn)<br>需要注意update和pickIndex的比例，如果很少update也可以考虑普通前缀和来做这样update虽然是O(n)但是pickIndex是O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w) &#123;</span><br><span class="line">        n = w.<span class="built_in">size</span>();</span><br><span class="line">        v.resize(n * <span class="number">2</span>);</span><br><span class="line">        copy(<span class="built_in">begin</span>(w), <span class="built_in">end</span>(w), <span class="built_in">begin</span>(v) + n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            v[i] = v[i * <span class="number">2</span>] + v[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        i += n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = val - v[i]; i &gt; <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            v[i] += d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = n, r = i + n; l &lt;= r; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                res += v[l++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((r &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                res += v[r--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = rand() % v[<span class="number">1</span>], l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (query(m) &lt;= x) &#123; <span class="comment">// &lt;是找下界&lt;=是找上界c</span></span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
        <tag>Random</tag>
        <tag>Segment tree</tag>
      </tags>
  </entry>
  <entry>
    <title>249. Group Shifted Strings</title>
    <url>/2020/11/28/249-Group-Shifted-Strings/</url>
    <content><![CDATA[<p>O(C) time O(<br>normalize每个单词存到hashmap里</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupStrings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strings)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : strings) &#123;</span><br><span class="line">            m[norm(s)].push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;[_, v] : m) &#123;</span><br><span class="line">            res.push_back(<span class="built_in">move</span>(v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">norm</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; <span class="comment">// 返回以ASCII码0为基准的字符串</span></span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">26</span> - s[<span class="number">0</span>]; <span class="comment">// 不关心'a'，只关心每个字符和s[0]的offset</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;c : s) &#123;</span><br><span class="line">            c = (c + offset) % <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupStrings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strings)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : strings) &#123;</span><br><span class="line">            m[norm(s)].push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;[_, v] : m) &#123;</span><br><span class="line">            res.push_back(<span class="built_in">move</span>(v)); <span class="comment">// 转成右值直接move过去避免copy</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">norm</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; <span class="comment">// 返回值并不需要是一个正常的纯英文可读字符串</span></span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">26</span> + <span class="string">'a'</span> - s[<span class="number">0</span>]; <span class="comment">// 这里假设以ASCII码0为基准 最后所有的'a'都变成0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;c : s) &#123;</span><br><span class="line">            c = (c - <span class="string">'a'</span> + offset) % <span class="number">26</span>; <span class="comment">// 减'a'以后以字符0为基准 实际上因为是Galois Field不减'a'也行 但是不好描述</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupStrings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strings)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m; <span class="comment">// 存下标就行，最后整理再放字符串</span></span><br><span class="line">        <span class="keyword">int</span> n = strings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            m[norm(strings[i])].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[_, v] : m) &#123;</span><br><span class="line">            res.push_back(&#123;&#125;);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : v) &#123;</span><br><span class="line">                res.back().push_back(strings[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">norm</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">26</span> + <span class="string">'a'</span> - s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> &amp;c : s) &#123;</span><br><span class="line">            c = (c + offset) % <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupStrings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strings)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : strings) &#123;</span><br><span class="line">            m[norm(s)].push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;[_, v] : m) &#123;</span><br><span class="line">            res.push_back(&#123;&#125;);</span><br><span class="line">            res.back().swap(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">norm</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; <span class="comment">// 输出以'a'为基准的真正可读字符串</span></span><br><span class="line">        <span class="keyword">int</span> offset = <span class="string">'a'</span> - s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;c : s) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = c + offset;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; <span class="string">'a'</span>) &#123;</span><br><span class="line">                c = <span class="string">'a'</span> + (t - <span class="string">'a'</span>) + <span class="number">26</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>133. Clone Graph</title>
    <url>/2020/11/29/133-Clone-Graph/</url>
    <content><![CDATA[<p>DFS O(n) time O(n) space<br>这道题一定要preorder先cache再递归，因为有可能存在环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span> (nodes.count(node)) <span class="keyword">return</span> nodes[node];</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="keyword">new</span> Node;</span><br><span class="line">        nodes[node] = res; <span class="comment">// 一定要先cache！！</span></span><br><span class="line">        res-&gt;val = node-&gt;val;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : node-&gt;neighbors) &#123;</span><br><span class="line">            res-&gt;neighbors.push_back(cloneGraph(n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node *, Node *&gt; nodes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>BFS</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node *, Node *&gt; nodes&#123;&#123;node, <span class="keyword">new</span> Node(node-&gt;val, &#123;&#125;)&#125;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node *&gt; q&#123;&#123;node&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> x = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> n : x-&gt;neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!nodes.count(n)) &#123;</span><br><span class="line">                    nodes[n] = <span class="keyword">new</span> Node(n-&gt;val, &#123;&#125;);</span><br><span class="line">                    q.push(n);</span><br><span class="line">                &#125;</span><br><span class="line">                nodes[x]-&gt;neighbors.push_back(nodes[n]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes[node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Breadth first search</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>340. Longest Substring with At Most K Distinct Characters</title>
    <url>/2020/11/28/340-Longest-Substring-with-At-Most-K-Distinct-Characters/</url>
    <content><![CDATA[<p>O(n) time O(26) space<br>是<a href="https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank" rel="noopener">159. Longest Substring with At Most Two Distinct Characters
</a>的follow-up</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            ++m[s[r]];</span><br><span class="line">            <span class="keyword">while</span> (m.<span class="built_in">size</span>() &gt; k) &#123; <span class="comment">// 注意k有可能为0</span></span><br><span class="line">                <span class="keyword">if</span> (--m[s[l]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    m.erase(s[l]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, r + <span class="number">1</span> - l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>lee的做法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; n; ++r) &#123;</span><br><span class="line">            ++m[s[r]];</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--m[s[l]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    m.erase(s[l]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>398. Random Pick Index</title>
    <url>/2020/11/29/398-Random-Pick-Index/</url>
    <content><![CDATA[<p>reservoir sampling O(n) time O(n) space<br>大小为1的水塘采样<br>從S中抽取首k項放入「水塘」中<br>對於每一個S[j]項（j ≥ k）：<br>   隨機產生一個範圍從0到j的整數r<br>   若 r &lt; k 則把水塘中的第r項換成S[j]項<br>这道题里的k为1，所以目标随机下标r为0<br>证明：假设最后一个被选中的是i，则i之前是否选中不重要，概率乘积为1，之后都不能被选中，假设target共有n个，则i被选中的概率为1/i * i/(i + 1) * … * (n - 1)/n = 1/n</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums) : nums(<span class="built_in">move</span>(nums)) &#123;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != target) <span class="keyword">continue</span>; <span class="comment">// 跳过所有的非目标，采样跟他们无关</span></span><br><span class="line">            <span class="keyword">if</span> (rand() % ++count == <span class="number">0</span>) &#123; <span class="comment">// 遇到目标时随机一次，这样采样数据源只包括所有的目标</span></span><br><span class="line">                res = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.pick(target);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) : b(<span class="built_in">begin</span>(nums)), e(<span class="built_in">end</span>(nums)) &#123;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = b; it != e; ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*it != target) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (rand() % ++count == <span class="number">0</span>) &#123;</span><br><span class="line">                res = distance(b, it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator b, e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.pick(target);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Reservoir sampling</tag>
      </tags>
  </entry>
  <entry>
    <title>543. Diameter of Binary Tree </title>
    <url>/2020/11/29/543-Diameter-of-Binary-Tree/</url>
    <content><![CDATA[<p>postorder O(n) 跟<a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. Binary Tree Maximum Path Sum</a>思路基本一致</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span> </span>&#123; <span class="comment">// 返回以root为根的最长链有几个结点</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = dfs(root-&gt;left), r = dfs(root-&gt;right);</span><br><span class="line">        res = <span class="built_in">max</span>(res, l + r); <span class="comment">// 人家问的是边不是点，不要加1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>708. Insert into a Sorted Circular Linked List</title>
    <url>/2020/11/29/708-Insert-into-a-Sorted-Circular-Linked-List/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>one pass</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            <span class="keyword">auto</span> res = <span class="keyword">new</span> Node(insertVal);</span><br><span class="line">            res-&gt;next = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> prev = head, curr = head-&gt;next;</span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">// 因为上来如果判断prev != head没法写循环，改成dowhile就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (prev-&gt;val &lt;= insertVal &amp;&amp; insertVal &lt;= curr-&gt;val) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (prev-&gt;val &gt; curr-&gt;val &amp;&amp; (prev-&gt;val &lt;= insertVal || insertVal &lt;= curr-&gt;val)) <span class="keyword">break</span>;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = prev-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (prev != head);</span><br><span class="line">        prev-&gt;next = <span class="keyword">new</span> Node(insertVal, curr);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123; <span class="comment">// 一定要注意空表！！！</span></span><br><span class="line">            <span class="keyword">auto</span> res = <span class="keyword">new</span> Node(insertVal);</span><br><span class="line">            res-&gt;next = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> prev = head, curr = prev-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (curr != head) &#123; <span class="comment">// curr == head说明已经找了一圈了都不符合要求，这是最后一个，只能这个了</span></span><br><span class="line">            <span class="keyword">if</span> (prev-&gt;val &lt;= insertVal &amp;&amp; insertVal &lt;= curr-&gt;val) <span class="keyword">break</span>; <span class="comment">// 终止条件1：insertVal恰好在prev和curr之间</span></span><br><span class="line">            <span class="keyword">if</span> (prev-&gt;val &gt; curr-&gt;val &amp;&amp; (prev-&gt;val &lt;= insertVal || insertVal &lt;= curr-&gt;val)) <span class="keyword">break</span>; <span class="comment">// 终止条件2：升序序列，insertVal恰好比最大的数大或者比最小的数小，必须最大的严格大于最小的，否则可能插入错误</span></span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = prev-&gt;next;</span><br><span class="line">        &#125; <span class="comment">// 如果都不符合要求，则说明head之前就是应该插入的地方</span></span><br><span class="line">        prev-&gt;next = <span class="keyword">new</span> Node(insertVal, curr);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>two pass</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            <span class="keyword">auto</span> res = <span class="keyword">new</span> Node(insertVal);</span><br><span class="line">            res-&gt;next = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;next != head &amp;&amp; curr-&gt;val &lt;= curr-&gt;next-&gt;val) &#123;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> prev = curr, smallest = prev-&gt;next;</span><br><span class="line">        curr = smallest;</span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;val &lt; insertVal) &#123;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = prev-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (curr == smallest) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev-&gt;next = <span class="keyword">new</span> Node(insertVal, curr);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>88. Merge Sorted Array</title>
    <url>/2020/11/28/88-Merge-Sorted-Array/</url>
    <content><![CDATA[<p>O(m+n) time O(1) space<br>关键是从后往前扫描！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m + n - <span class="number">1</span>, i1 = m - <span class="number">1</span>, i2 = n - <span class="number">1</span>; i2 &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                nums1[i] = nums1[i1] &gt; nums2[i2] ? nums1[i1--] : nums2[i2--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[i] = nums2[i2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m + n - <span class="number">1</span>, i1 = m - <span class="number">1</span>, i2 = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 &gt;= <span class="number">0</span> &amp;&amp; i2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                nums1[i] = nums1[i1] &gt; nums2[i2] ? nums1[i1--] : nums2[i2--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i2 &gt;= <span class="number">0</span>) &#123; <span class="comment">// i1到头了，只扫nums2即可</span></span><br><span class="line">                nums1[i] = nums2[i2--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// i2到头了，nums1保持不变，不用再扫了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(m+n) time O(m+n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(m + n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m || j &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = i &lt; m ? nums1[i] : INT_MAX;</span><br><span class="line">            <span class="keyword">int</span> b = j &lt; n ? nums2[j] : INT_MAX;</span><br><span class="line">            res[i + j] = <span class="built_in">min</span>(a, b);</span><br><span class="line">            <span class="keyword">if</span> (res[i + j] == a) ++i;</span><br><span class="line">            <span class="keyword">else</span> ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        nums1 = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Merging</tag>
      </tags>
  </entry>
  <entry>
    <title>986. Interval List Intersections</title>
    <url>/2020/11/29/986-Interval-List-Intersections/</url>
    <content><![CDATA[<p>二路归并 O(m + n) time O(1) space<br>最简单的办法是取两个interval的交集，如果交集存在则存入结果，再「分别」判断『交集』的右边界和两个interval是否重合，重合则看下一个interval<br>这道题用扫描线做会非常复杂</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">intervalIntersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.<span class="built_in">size</span>(), n = B.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="built_in">max</span>(A[i][<span class="number">0</span>], B[j][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> e = <span class="built_in">min</span>(A[i][<span class="number">1</span>], B[j][<span class="number">1</span>]); <span class="comment">// 找intersection</span></span><br><span class="line">            <span class="keyword">if</span> (s &lt;= e) &#123; <span class="comment">// 如果有intersection</span></span><br><span class="line">                res.push_back(&#123;s, e&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e == A[i][<span class="number">1</span>]) &#123; <span class="comment">// 如果A[i]区间比较靠前则看下一个</span></span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e == B[j][<span class="number">1</span>]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Merging</tag>
        <tag>Implementation</tag>
        <tag>Sweep line</tag>
      </tags>
  </entry>
  <entry>
    <title>65. Valid Number</title>
    <url>/2020/11/28/65-Valid-Number/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> <span class="built_in">exp</span> = <span class="literal">false</span>, dot = <span class="literal">false</span>, num = <span class="literal">false</span>, numAfterE = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.find_first_not_of(<span class="string">' '</span>); i &lt;= s.find_last_not_of(<span class="string">' '</span>); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                num = numAfterE = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'e'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">exp</span> || !num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">exp</span> = <span class="literal">true</span>;</span><br><span class="line">                numAfterE = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dot || <span class="built_in">exp</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                dot = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'+'</span> || c == <span class="string">'-'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">' '</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">'e'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num &amp;&amp; numAfterE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">bool</span> num = <span class="literal">false</span>, numAfterE = <span class="literal">false</span>, dot = <span class="literal">false</span>, <span class="built_in">exp</span> = <span class="literal">false</span>, sign = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((num || dot || <span class="built_in">exp</span> || sign) &amp;&amp; i + <span class="number">1</span> &lt; n &amp;&amp; s[i + <span class="number">1</span>] != <span class="string">' '</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 空格不能出现在中间</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                num = numAfterE = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dot || <span class="built_in">exp</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不能有多个.且指数部分不能有.</span></span><br><span class="line">                dot = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'e'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">exp</span> || !num) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不能有多个e且e前必须得有数字出现</span></span><br><span class="line">                <span class="built_in">exp</span> = <span class="literal">true</span>;</span><br><span class="line">                numAfterE = <span class="literal">false</span>; <span class="comment">// 重置！！</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'+'</span> || c == <span class="string">'-'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">' '</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 符号只能出现在最开始的空格之后或者e之后</span></span><br><span class="line">                sign = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num &amp;&amp; numAfterE; <span class="comment">// 最后底数和指数都要检查</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>139. Word Break</title>
    <url>/2020/11/30/139-Word-Break/</url>
    <content><![CDATA[<p>dp dfs + memo top-down<br>这个题应该要注意到可能会有大量重复，所以一定可以用memo优化！！所以肯定是一个dp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : wordDict) &#123;</span><br><span class="line">            table.insert(string_view&#123;w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(string_view&#123;s&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(string_view sv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sv.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (m.count(sv)) <span class="keyword">return</span> m[sv];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="built_in">size</span>(sv), i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table.count(sv.substr(<span class="number">0</span>, i)) &amp;&amp; dfs(sv.substr(i))) <span class="keyword">return</span> m[sv] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[sv] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;string_view&gt; table;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;string_view, <span class="keyword">bool</span>&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        ws = <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;(wordDict.<span class="built_in">begin</span>(), wordDict.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> dfs(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (m.count(s)) <span class="keyword">return</span> m[s];</span><br><span class="line">        <span class="built_in">string</span> prefix;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            prefix += s[i];</span><br><span class="line">            <span class="keyword">if</span> (ws.count(prefix) &amp;&amp; dfs(s.substr(i + <span class="number">1</span>))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[s] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; m;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; ws;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类似palindrom partition bottom-up<br>划分型dp O(s.length<sup>3</sup>) m是单词平均长度<br>f[i]表示前i个字母组成的字符串<br>最后一步是f[0]到f[n-1]都已经知道了是否能break，遍历一遍看哪种break可以让f[n]为true<br>所以转移方程是遍历0到n，分别计算每一种划分f[0]到f[n]<br>f[i] = (f[j] 并且字典里能找到s[j:i] where 0 &lt;= j &lt; i)，即前j个字符和前i个字符之间是s[j:i]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">dict</span><span class="params">(wordDict.<span class="built_in">begin</span>(), wordDict.<span class="built_in">end</span>())</span></span>; <span class="comment">// 用一个hashset存单词方便查找</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// 表示前n个字母是否符合要求，注意f[0]一定要为true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i] = f[j] &amp;&amp; (dict.count(s.substr(j, i - j)) &gt; <span class="number">0</span>)) <span class="keyword">break</span>; <span class="comment">// 注意及时break否则就白找了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用这个<br>string_view把复杂度降到O(s.length<sup>2</sup>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;string_view&gt; dict;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : wordDict) &#123;</span><br><span class="line">            dict.insert(string_view&#123;w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        string_view sv&#123;s&#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="built_in">size</span>(sv);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i] = f[j] &amp;&amp; (dict.count(sv.substr(j, i - j)) &gt; <span class="number">0</span>)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">dict</span><span class="params">(<span class="built_in">begin</span>(wordDict), <span class="built_in">end</span>(wordDict))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i] = (f[j] &amp;&amp; dict.count(s.substr(j, i - j)))) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外一种方法<br>O(s.length * wordDict.size * word.length) time<br>如果wordDict较小且word.length较短，则整体复杂度比常规dp要小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : wordDict) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i] &amp;&amp; s.substr(i, <span class="built_in">min</span>(n, w.length())) == w) &#123;</span><br><span class="line">                    f[i + w.length()] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>378. Kth Smallest Element in a Sorted Matrix</title>
    <url>/2020/11/30/378-Kth-Smallest-Element-in-a-Sorted-Matrix/</url>
    <content><![CDATA[<p>bisection O(nlognlogD) time where D是最大最小值之差<br>用这个二分猜数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> lo = matrix[<span class="number">0</span>][<span class="number">0</span>], hi = matrix[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;v : matrix) &#123; <span class="comment">// 统计所有不大于m的数的个数</span></span><br><span class="line">                cnt += (upper_bound(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), m) - v.<span class="built_in">begin</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; k) &#123; <span class="comment">// 如果不大于m（包括m）的数不到k个，说明m不是最终结果</span></span><br><span class="line">                lo = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O((n+n<sup>2</sup>-k)logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;lhs, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.first &lt; rhs.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> target = matrix.<span class="built_in">size</span>() * matrix.<span class="built_in">size</span>() - k;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, cmp&gt; heap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; matrix.<span class="built_in">size</span>(); ++row) &#123;</span><br><span class="line">            heap.push(make_pair(matrix[row].back(), row));</span><br><span class="line">            matrix[row].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">            <span class="keyword">if</span> (!matrix[p.second].empty()) &#123;</span><br><span class="line">                heap.push(make_pair(matrix[p.second].back(), p.second));</span><br><span class="line">                matrix[p.second].pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap.top().first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n<sup>3</sup>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = matrix.<span class="built_in">size</span>() * matrix.<span class="built_in">size</span>() - k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> max_num = INT_MIN;</span><br><span class="line">            <span class="keyword">int</span> max_row = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> row = matrix.<span class="built_in">size</span>() - <span class="number">1</span>; row &gt;= <span class="number">0</span>; --row) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!matrix[row].empty() &amp;&amp; matrix[row].back() &gt; max_num) &#123;</span><br><span class="line">                    max_num = matrix[row].back();</span><br><span class="line">                    max_row = row;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="built_in">size</span> - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> matrix[max_row].back();</span><br><span class="line">            matrix[max_row].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Merging</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>339. Nested List Weight Sum</title>
    <url>/2020/11/30/339-Nested-List-Weight-Sum/</url>
    <content><![CDATA[<p>bfs O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></span><br><span class="line"><span class="comment"> *     NestedInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></span><br><span class="line"><span class="comment"> *     NestedInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></span><br><span class="line"><span class="comment"> *     void setInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"><span class="comment"> *     void add(const NestedInteger &amp;ni);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!nestedList.empty()) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;NestedInteger&gt; nextLevel;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;ni : nestedList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ni.isInteger()) &#123;</span><br><span class="line">                    res += ni.getInteger() * depth;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextLevel.insert(<span class="built_in">end</span>(nextLevel), <span class="built_in">begin</span>(ni.getList()), <span class="built_in">end</span>(ni.getList()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nestedList.swap(nextLevel);</span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></span><br><span class="line"><span class="comment"> *     NestedInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></span><br><span class="line"><span class="comment"> *     NestedInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></span><br><span class="line"><span class="comment"> *     void setInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"><span class="comment"> *     void add(const NestedInteger &amp;ni);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">list</span>&lt;NestedInteger&gt; <span class="title">q</span><span class="params">(<span class="built_in">begin</span>(nestedList), <span class="built_in">end</span>(nestedList))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = q.front(); q.pop_front();</span><br><span class="line">                <span class="keyword">if</span> (x.isInteger()) &#123;</span><br><span class="line">                    res += x.getInteger() * depth;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    q.insert(<span class="built_in">end</span>(q), <span class="built_in">begin</span>(x.getList()), <span class="built_in">end</span>(x.getList()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></span><br><span class="line"><span class="comment"> *     NestedInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></span><br><span class="line"><span class="comment"> *     NestedInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></span><br><span class="line"><span class="comment"> *     void setInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"><span class="comment"> *     void add(const NestedInteger &amp;ni);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;NestedInteger&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;ni : nestedList) &#123;</span><br><span class="line">            q.push(ni);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, depth = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (x.isInteger()) &#123;</span><br><span class="line">                    res += x.getInteger() * depth;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;ni : x.getList()) &#123;</span><br><span class="line">                        q.push(ni);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dfs</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></span><br><span class="line"><span class="comment"> *     NestedInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></span><br><span class="line"><span class="comment"> *     NestedInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></span><br><span class="line"><span class="comment"> *     void setInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"><span class="comment"> *     void add(const NestedInteger &amp;ni);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(nestedList, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;ni : nestedList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ni.isInteger()) &#123;</span><br><span class="line">                res += ni.getInteger() * depth;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += dfs(ni.getList(), depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Implementation</tag>
        <tag>Breadth first search</tag>
        <tag>Level order traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>1499. Max Value of Equation</title>
    <url>/2020/12/01/1499-Max-Value-of-Equation/</url>
    <content><![CDATA[<p>deque O(n) time O(n) space<br>先把equation拆成后边（x+y）和前边（x-y）之差，即(x<sub>j</sub> + y<sub>j</sub>) - (x<sub>i</sub> - y<sub>i</sub>)，对于每个(x<sub>j</sub> + y<sub>j</sub>)只需要知道前边最小的(x<sub>i</sub> - y<sub>i</sub>)即可，又因为有一个限制条件|x<sub>i</sub> - x<sub>j</sub>| &lt;= k，说明需要用sliding window，参考<a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. Sliding Window Maximum</a>用deque维护一个升序，每次先把不符合限制条件|x<sub>i</sub> - x<sub>j</sub>| &lt;= k的i从前边剔除，然后计算结果，再插入j并在尾部剔除较大的不符合要求的下标以保持升序<br>另外要注意如果k过小，有可能没有结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxValueOfEquation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="built_in">size</span>(points), i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty() &amp;&amp; points[i][<span class="number">0</span>] - points[q.front()][<span class="number">0</span>] &gt; k) &#123;</span><br><span class="line">                q.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!q.empty()) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, points[i][<span class="number">0</span>] + points[i][<span class="number">1</span>] - (points[q.front()][<span class="number">0</span>] - points[q.front()][<span class="number">1</span>])); <span class="comment">// 注意这道题一定要先计算再push新数，因为i &lt; j</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty() &amp;&amp; points[q.back()][<span class="number">0</span>] - points[q.back()][<span class="number">1</span>] &gt;= points[i][<span class="number">0</span>] - points[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                q.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            q.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
        <tag>Deque</tag>
      </tags>
  </entry>
  <entry>
    <title>270. Closest Binary Search Tree Value</title>
    <url>/2020/12/01/270-Closest-Binary-Search-Tree-Value/</url>
    <content><![CDATA[<p>iterative O(h) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = root-&gt;val;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(root-&gt;val - target) &lt; <span class="built_in">fabs</span>(res - target)) &#123;</span><br><span class="line">                res = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;val &gt; target ? root-&gt;left : root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>recursive O(h) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        res = root-&gt;val;</span><br><span class="line">        dfs(root, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(root-&gt;val - target) &lt; <span class="built_in">fabs</span>(res - target)) &#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;val &gt; target ? dfs(root-&gt;left, target) : dfs(root-&gt;right, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n) time O(h) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        res = root-&gt;val;</span><br><span class="line">        dfs(root, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(root-&gt;val - target) &lt; <span class="built_in">fabs</span>(res - target)) &#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, target);</span><br><span class="line">        dfs(root-&gt;right, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
        <tag>Binary search tree</tag>
      </tags>
  </entry>
  <entry>
    <title>317. Shortest Distance from All Buildings</title>
    <url>/2020/12/01/317-Shortest-Distance-from-All-Buildings/</url>
    <content><![CDATA[<p>O(m*n*b) time O(m*n) space<br>思路很直白 遍历每个房子 对每个房子bfs 累加每个空地到每个房子的距离 要找的是一个可以reach所有房子的空地（前提是房子少空地多，否则就要对每个空地bfs）<br>这道题最重要的corner case是有的房子reach不到所有的空地<br>下面这个方法比较tricky但是省空间且不需要最后的遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty() || grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">s</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    res = bfs(s, grid, cnt--, i, j, m, n); <span class="comment">// cnt其实就是房子的个数</span></span><br><span class="line">                    <span class="keyword">if</span> (res == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 有任何一个房子不能reach到所有空地，直接返回-1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> cnt, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.emplace(i, j);</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span>, res = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = q.<span class="built_in">size</span>(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [ui, uj] = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">4</span>; ++p) &#123;</span><br><span class="line">                    <span class="keyword">int</span> vi = ui + di[p];</span><br><span class="line">                    <span class="keyword">int</span> vj = uj + dj[p];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= vi &amp;&amp; vi &lt; m &amp;&amp; <span class="number">0</span> &lt;= vj &amp;&amp; vj &lt; n &amp;&amp; cnt == grid[vi][vj]) &#123; <span class="comment">// 只有当前空地的计数器等于之前遍历过的所有房子的个数才有可能对res进行更新，如果之前有某个房子不能reach到，则当前空地的计数器一定和cnt不等；如果当前房子是reach不到的则res也不会更新，因为res会被overwritten，所以如果有一个房子reach不到，那么res会被改成INT_MAX并且之后再遍历的所有房子都不会再更新res</span></span><br><span class="line">                        grid[vi][vj] = cnt - <span class="number">1</span>;</span><br><span class="line">                        s[vi][vj] += d;</span><br><span class="line">                        q.emplace(vi, vj);</span><br><span class="line">                        res = <span class="built_in">min</span>(res, s[vi][vj]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> di[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dj[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty() || grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; s(m, vector&lt;int&gt;(n)), cnt = s; // s用来累加每个空地到其他房子的距离，cnt用来统计每个空地能有多少个房子reach</span><br><span class="line">        <span class="keyword">int</span> color = <span class="number">0</span>; <span class="comment">// color用来给grid里的空地着色，避免重复访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    bfs(s, grid, cnt, --color, i, j, m, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i][j] &gt; <span class="number">0</span> &amp;&amp; cnt[i][j] + color == <span class="number">0</span>) &#123; <span class="comment">// 如果存在一个空地可以reach所有房子，s[i][j] &gt; 0说明是空地，cnt[i][j] + color == 0说明可以reach所有房子</span></span><br><span class="line">                    res = <span class="built_in">min</span>(res, s[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">-1</span> : res; <span class="comment">// 如果不存在能reach所有房子的空地</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;cnt, <span class="keyword">int</span> color, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.emplace(i, j);</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = q.<span class="built_in">size</span>(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="keyword">auto</span> u = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">4</span>; ++p) &#123;</span><br><span class="line">                    <span class="keyword">int</span> vi = u.first + di[p];</span><br><span class="line">                    <span class="keyword">int</span> vj = u.second + dj[p];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= vi &amp;&amp; vi &lt; m &amp;&amp; <span class="number">0</span> &lt;= vj &amp;&amp; vj &lt; n &amp;&amp; color &lt; grid[vi][vj] &amp;&amp; grid[vi][vj] &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                        grid[vi][vj] = color;</span><br><span class="line">                        s[vi][vj] += d;</span><br><span class="line">                        q.emplace(vi, vj);</span><br><span class="line">                        ++cnt[vi][vj];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> di[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dj[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title>670. Maximum Swap</title>
    <url>/2020/12/01/670-Maximum-Swap/</url>
    <content><![CDATA[<p>桶排序 O(n) time O(10) space<br>思路就是从高位到低位扫描，对于每一位数字，找到其右侧比他大的所有数字里最大的那个数字，找到这个数字最后一次出现的位置，交换即可，因此需要统计每个数字最后一次出现的位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> s = to_string(num);</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            last[s[i] - <span class="string">'0'</span>] = i; <span class="comment">// 记录所有数字最后出现的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">9</span>; j &gt; s[i] - <span class="string">'0'</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; last[j]) &#123; <span class="comment">// 对于每个处于高位的数字，如果能找到一个比它大的在低位的数字，交换并返回</span></span><br><span class="line">                    swap(s[i], s[last[j]]);</span><br><span class="line">                    <span class="keyword">return</span> stoi(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>桶排序 O(n) time O(n) space<br>0到9十个数字十个桶，扫描数字字符串，把每个数字出现的下标保存到对应数字的桶里<br>从9到0依次扫描桶，取出当前桶i最后一次出现的下标b[i].back()，然后扫描所有比当前桶对应的数字小的数字的桶j中的第一次出现的下标b[j].front()并找到最小的下标l，将其与桶i最后一次出现的下标b[i].back()，交换原字符串中的数字即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> s = to_string(num);</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            b[s[i] - <span class="string">'0'</span>].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b[i].empty()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> l = b[i].back();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b[j].empty()) <span class="keyword">continue</span>;</span><br><span class="line">                l = <span class="built_in">min</span>(l, b[j].front());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; b[i].back()) &#123;</span><br><span class="line">                swap(s[l], s[b[i].back()]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stoi(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Bucket sort</tag>
      </tags>
  </entry>
  <entry>
    <title>785. Is Graph Bipartite?</title>
    <url>/2020/12/01/785-Is-Graph-Bipartite/</url>
    <content><![CDATA[<p>着色法 O(V+E) time O(v) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        colors.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (colors[i] == <span class="number">0</span> &amp;&amp; !dfs(graph, i, <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph, <span class="keyword">int</span> node, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (colors[node] != <span class="number">0</span>) <span class="keyword">return</span> colors[node] == color;</span><br><span class="line">        colors[node] = color;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(graph, neighbor, -color)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; colors;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Backtracking</tag>
        <tag>Bipartite</tag>
      </tags>
  </entry>
  <entry>
    <title>Categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>About me</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p>Chang is currently a senior software engineer at <a href="https://www.mathworks.com/" target="_blank" rel="noopener">MathWorks</a>. Before joining <a href="https://www.mathworks.com/" target="_blank" rel="noopener">MathWorks</a>, he did research in network and communication system verification at <a href="https://vt.edu/" target="_blank" rel="noopener">Virginia Tech</a> and got his master degree in computer engineering. He used to study information security and got his bachelor degree at <a href="http://en.nankai.edu.cn/" target="_blank" rel="noopener">Nankai University</a> in Tianjin, China.</p>
]]></content>
  </entry>
  <entry>
    <title>Tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-barber-shop.min.css</url>
    <content><![CDATA[.pace,.pace .pace-progress{width:100%;overflow:hidden}.pace,.pace .pace-activity{position:fixed;top:0;left:0}.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;z-index:2000;height:12px;background:#fff}.pace-inactive{display:none}.pace .pace-progress{background-color:#29d;position:fixed;top:0;bottom:0;right:100%}.pace .pace-activity{right:-32px;bottom:0;-webkit-transform:translate3d(0,0,0);-moz-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);-o-transform:translate3d(0,0,0);transform:translate3d(0,0,0);background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(.25,rgba(255,255,255,.2)),color-stop(.25,transparent),color-stop(.5,transparent),color-stop(.5,rgba(255,255,255,.2)),color-stop(.75,rgba(255,255,255,.2)),color-stop(.75,transparent),to(transparent));background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.2) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.2) 50%,rgba(255,255,255,.2) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(45deg,rgba(255,255,255,.2) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.2) 50%,rgba(255,255,255,.2) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.2) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.2) 50%,rgba(255,255,255,.2) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.2) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.2) 50%,rgba(255,255,255,.2) 75%,transparent 75%,transparent);-webkit-background-size:32px 32px;-moz-background-size:32px 32px;-o-background-size:32px 32px;background-size:32px 32px;-webkit-animation:pace-theme-barber-shop-motion .5s linear infinite;-moz-animation:pace-theme-barber-shop-motion .5s linear infinite;-ms-animation:pace-theme-barber-shop-motion .5s linear infinite;-o-animation:pace-theme-barber-shop-motion .5s linear infinite;animation:pace-theme-barber-shop-motion .5s linear infinite}@-webkit-keyframes pace-theme-barber-shop-motion{0%{-webkit-transform:none;transform:none}100%{-webkit-transform:translate(-32px,0);transform:translate(-32px,0)}}@-moz-keyframes pace-theme-barber-shop-motion{0%{-moz-transform:none;transform:none}100%{-moz-transform:translate(-32px,0);transform:translate(-32px,0)}}@-o-keyframes pace-theme-barber-shop-motion{0%{-o-transform:none;transform:none}100%{-o-transform:translate(-32px,0);transform:translate(-32px,0)}}@-ms-keyframes pace-theme-barber-shop-motion{0%{-ms-transform:none;transform:none}100%{-ms-transform:translate(-32px,0);transform:translate(-32px,0)}}@keyframes pace-theme-barber-shop-motion{0%{transform:none}100%{transform:translate(-32px,0)}}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-big-counter.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace.pace-inactive .pace-progress{display:none}.pace .pace-progress{position:fixed;z-index:2000;top:0;right:0;height:5rem;width:5rem;-webkit-transform:translate3d(0,0,0)!important;-ms-transform:translate3d(0,0,0)!important;transform:translate3d(0,0,0)!important}.pace .pace-progress:after{display:block;position:absolute;top:0;right:.5rem;content:attr(data-progress-text);font-family:"Helvetica Neue",sans-serif;font-weight:100;font-size:5rem;line-height:1;text-align:right;color:rgba(34,153,221,.19999999999999996)}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-bounce.min.css</url>
    <content><![CDATA[.pace{width:140px;height:300px;position:fixed;top:-90px;right:-20px;z-index:2000;-webkit-transform:scale(0);-moz-transform:scale(0);-ms-transform:scale(0);-o-transform:scale(0);transform:scale(0);opacity:0;-webkit-transition:all 2s linear 0s;-moz-transition:all 2s linear 0s;transition:all 2s linear 0s}.pace.pace-active{-webkit-transform:scale(.25);-moz-transform:scale(.25);-ms-transform:scale(.25);-o-transform:scale(.25);transform:scale(.25);opacity:1}.pace .pace-activity{width:140px;height:140px;border-radius:70px;background:#29d;position:absolute;top:0;z-index:1911;-webkit-animation:pace-bounce 1s infinite;-moz-animation:pace-bounce 1s infinite;-o-animation:pace-bounce 1s infinite;-ms-animation:pace-bounce 1s infinite;animation:pace-bounce 1s infinite}.pace .pace-progress{position:absolute;display:block;left:50%;bottom:0;z-index:1910;margin-left:-30px;width:60px;height:75px;background:rgba(20,20,20,.1);box-shadow:0 0 20px 35px rgba(20,20,20,.1);border-radius:30px/40px;-webkit-transform:scaleY(.3)!important;-moz-transform:scaleY(.3)!important;-ms-transform:scaleY(.3)!important;-o-transform:scaleY(.3)!important;transform:scaleY(.3)!important;-webkit-animation:pace-compress .5s infinite alternate;-moz-animation:pace-compress .5s infinite alternate;-o-animation:pace-compress .5s infinite alternate;-ms-animation:pace-compress .5s infinite alternate;animation:pace-compress .5s infinite alternate}@-webkit-keyframes pace-bounce{0%,100%,95%{top:0;-webkit-animation-timing-function:ease-in}50%{top:140px;height:140px;-webkit-animation-timing-function:ease-out}55%{top:160px;height:120px;border-radius:70px/60px;-webkit-animation-timing-function:ease-in}65%{top:120px;height:140px;border-radius:70px;-webkit-animation-timing-function:ease-out}}@-moz-keyframes pace-bounce{0%,100%,95%{top:0;-moz-animation-timing-function:ease-in}50%{top:140px;height:140px;-moz-animation-timing-function:ease-out}55%{top:160px;height:120px;border-radius:70px/60px;-moz-animation-timing-function:ease-in}65%{top:120px;height:140px;border-radius:70px;-moz-animation-timing-function:ease-out}}@keyframes pace-bounce{0%,100%,95%{top:0;animation-timing-function:ease-in}50%{top:140px;height:140px;animation-timing-function:ease-out}55%{top:160px;height:120px;border-radius:70px/60px;animation-timing-function:ease-in}65%{top:120px;height:140px;border-radius:70px;animation-timing-function:ease-out}}@-webkit-keyframes pace-compress{0%{bottom:0;margin-left:-30px;width:60px;height:75px;background:rgba(20,20,20,.1);box-shadow:0 0 20px 35px rgba(20,20,20,.1);border-radius:30px/40px;-webkit-animation-timing-function:ease-in}100%{bottom:30px;margin-left:-10px;width:20px;height:5px;background:rgba(20,20,20,.3);box-shadow:0 0 20px 35px rgba(20,20,20,.3);border-radius:20px;-webkit-animation-timing-function:ease-out}}@-moz-keyframes pace-compress{0%{bottom:0;margin-left:-30px;width:60px;height:75px;background:rgba(20,20,20,.1);box-shadow:0 0 20px 35px rgba(20,20,20,.1);border-radius:30px/40px;-moz-animation-timing-function:ease-in}100%{bottom:30px;margin-left:-10px;width:20px;height:5px;background:rgba(20,20,20,.3);box-shadow:0 0 20px 35px rgba(20,20,20,.3);border-radius:20px;-moz-animation-timing-function:ease-out}}@keyframes pace-compress{0%{bottom:0;margin-left:-30px;width:60px;height:75px;background:rgba(20,20,20,.1);box-shadow:0 0 20px 35px rgba(20,20,20,.1);border-radius:30px/40px;animation-timing-function:ease-in}100%{bottom:30px;margin-left:-10px;width:20px;height:5px;background:rgba(20,20,20,.3);box-shadow:0 0 20px 35px rgba(20,20,20,.3);border-radius:20px;animation-timing-function:ease-out}}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-center-atom.min.css</url>
    <content><![CDATA[.pace,.pace .pace-progress{z-index:2000;height:60px;width:100px}.pace .pace-activity,.pace .pace-progress:before{border-radius:50%;display:block;position:absolute}.pace.pace-inactive{display:none}.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;position:fixed;margin:auto;top:0;left:0;right:0;bottom:0}.pace .pace-progress{position:absolute;-webkit-transform:translate3d(0,0,0)!important;-ms-transform:translate3d(0,0,0)!important;transform:translate3d(0,0,0)!important}.pace .pace-progress:before{content:attr(data-progress-text);text-align:center;color:#fff;background:#29d;font-family:"Helvetica Neue",sans-serif;font-size:14px;font-weight:100;line-height:1;padding:20% 0 7px;width:50%;height:40%;margin:10px 0 0 30px;z-index:999}.pace .pace-activity{font-size:15px;line-height:1;z-index:2000;-webkit-animation:pace-theme-center-atom-spin 2s linear infinite;-moz-animation:pace-theme-center-atom-spin 2s linear infinite;-o-animation:pace-theme-center-atom-spin 2s linear infinite;animation:pace-theme-center-atom-spin 2s linear infinite;border:5px solid #29d;content:' ';top:0;left:0;height:60px;width:100px}.pace .pace-activity:after,.pace .pace-activity:before{content:' ';display:block;position:absolute;top:-5px;left:-5px;height:60px;width:100px}.pace .pace-activity:after{border-radius:50%;border:5px solid #29d;-webkit-transform:rotate(60deg);-moz-transform:rotate(60deg);-o-transform:rotate(60deg);transform:rotate(60deg)}.pace .pace-activity:before{border-radius:50%;border:5px solid #29d;-webkit-transform:rotate(120deg);-moz-transform:rotate(120deg);-o-transform:rotate(120deg);transform:rotate(120deg)}@-webkit-keyframes pace-theme-center-atom-spin{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(359deg)}}@-moz-keyframes pace-theme-center-atom-spin{0%{-moz-transform:rotate(0)}100%{-moz-transform:rotate(359deg)}}@-o-keyframes pace-theme-center-atom-spin{0%{-o-transform:rotate(0)}100%{-o-transform:rotate(359deg)}}@keyframes pace-theme-center-atom-spin{0%{transform:rotate(0)}100%{transform:rotate(359deg)}}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-center-radar.min.css</url>
    <content><![CDATA[.pace,.pace .pace-activity{z-index:2000;height:90px;width:90px}.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;position:fixed;margin:auto;top:0;left:0;right:0;bottom:0}.pace.pace-inactive .pace-activity{display:none}.pace .pace-activity,.pace .pace-activity:before{position:absolute;display:block;border-color:#29d transparent transparent;border-radius:50%}.pace .pace-activity{left:-30px;top:-30px;border-width:30px;border-style:double;-webkit-animation:spin 1s linear infinite;-moz-animation:spin 1s linear infinite;-o-animation:spin 1s linear infinite;animation:spin 1s linear infinite}.pace .pace-activity:before{content:' ';top:10px;left:10px;height:50px;width:50px;border-width:10px;border-style:solid}@-webkit-keyframes spin{100%{-webkit-transform:rotate(359deg)}}@-moz-keyframes spin{100%{-moz-transform:rotate(359deg)}}@-o-keyframes spin{100%{-moz-transform:rotate(359deg)}}@keyframes spin{100%{transform:rotate(359deg)}}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-center-simple.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;z-index:2000;position:fixed;margin:auto;top:0;left:0;right:0;bottom:0;height:5px;width:200px;background:#fff;border:1px solid #29d;overflow:hidden}.pace .pace-progress{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;-o-box-sizing:border-box;box-sizing:border-box;-webkit-transform:translate3d(0,0,0);-moz-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);-o-transform:translate3d(0,0,0);transform:translate3d(0,0,0);max-width:200px;z-index:2000;display:block;position:absolute;top:0;right:100%;height:100%;width:100%;background:#29d}.pace.pace-inactive{display:none}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-center-circle.min.css</url>
    <content><![CDATA[.pace,.pace .pace-progress{z-index:2000;left:0;top:0;height:6rem}.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;-webkit-perspective:12rem;-moz-perspective:12rem;-ms-perspective:12rem;-o-perspective:12rem;perspective:12rem;position:fixed;width:6rem;margin:auto;right:0;bottom:0}.pace.pace-inactive .pace-progress{display:none}.pace .pace-progress{display:block;position:absolute;width:6rem!important;line-height:6rem;font-size:2rem;border-radius:50%;background:rgba(34,153,221,.8);color:#fff;font-family:"Helvetica Neue",sans-serif;font-weight:100;text-align:center;-webkit-animation:pace-theme-center-circle-spin linear infinite 2s;-moz-animation:pace-theme-center-circle-spin linear infinite 2s;-ms-animation:pace-theme-center-circle-spin linear infinite 2s;-o-animation:pace-theme-center-circle-spin linear infinite 2s;animation:pace-theme-center-circle-spin linear infinite 2s;-webkit-transform-style:preserve-3d;-moz-transform-style:preserve-3d;-ms-transform-style:preserve-3d;-o-transform-style:preserve-3d;transform-style:preserve-3d}.pace .pace-progress:after{content:attr(data-progress-text);display:block}@-webkit-keyframes pace-theme-center-circle-spin{from{-webkit-transform:rotateY(0)}to{-webkit-transform:rotateY(360deg)}}@-moz-keyframes pace-theme-center-circle-spin{from{-moz-transform:rotateY(0)}to{-moz-transform:rotateY(360deg)}}@-ms-keyframes pace-theme-center-circle-spin{from{-ms-transform:rotateY(0)}to{-ms-transform:rotateY(360deg)}}@-o-keyframes pace-theme-center-circle-spin{from{-o-transform:rotateY(0)}to{-o-transform:rotateY(360deg)}}@keyframes pace-theme-center-circle-spin{from{transform:rotateY(0)}to{transform:rotateY(360deg)}}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-fill-left.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background-color:rgba(34,153,221,.19999999999999996);position:fixed;z-index:-1;top:0;right:100%;bottom:0;width:100%}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-corner-indicator.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace .pace-activity{display:block;position:fixed;z-index:2000;top:0;right:0;width:300px;height:300px;background:#29d;-webkit-transition:-webkit-transform .3s;transition:transform .3s;-webkit-transform:translateX(100%) translateY(-100%) rotate(45deg);transform:translateX(100%) translateY(-100%) rotate(45deg);pointer-events:none}.pace.pace-active .pace-activity{-webkit-transform:translateX(50%) translateY(-50%) rotate(45deg);transform:translateX(50%) translateY(-50%) rotate(45deg)}.pace .pace-activity::after,.pace .pace-activity::before{-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;bottom:30px;left:50%;display:block;border:5px solid #fff;border-radius:50%;content:''}.pace .pace-activity::before{margin-left:-40px;width:80px;height:80px;border-right-color:rgba(0,0,0,.2);border-left-color:rgba(0,0,0,.2);-webkit-animation:pace-theme-corner-indicator-spin 3s linear infinite;animation:pace-theme-corner-indicator-spin 3s linear infinite}.pace .pace-activity::after{bottom:50px;margin-left:-20px;width:40px;height:40px;border-top-color:rgba(0,0,0,.2);border-bottom-color:rgba(0,0,0,.2);-webkit-animation:pace-theme-corner-indicator-spin 1s linear infinite;animation:pace-theme-corner-indicator-spin 1s linear infinite}@-webkit-keyframes pace-theme-corner-indicator-spin{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(359deg)}}@keyframes pace-theme-corner-indicator-spin{0%{transform:rotate(0)}100%{transform:rotate(359deg)}}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-flash.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#29d;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}.pace .pace-progress-inner{display:block;position:absolute;right:0;width:100px;height:100%;box-shadow:0 0 10px #29d,0 0 5px #29d;opacity:1;-webkit-transform:rotate(3deg) translate(0,-4px);-moz-transform:rotate(3deg) translate(0,-4px);-ms-transform:rotate(3deg) translate(0,-4px);-o-transform:rotate(3deg) translate(0,-4px);transform:rotate(3deg) translate(0,-4px)}.pace .pace-activity{display:block;position:fixed;z-index:2000;top:15px;right:15px;width:14px;height:14px;border:2px solid transparent;border-top-color:#29d;border-left-color:#29d;border-radius:10px;-webkit-animation:pace-spinner .4s linear infinite;-moz-animation:pace-spinner .4s linear infinite;-ms-animation:pace-spinner .4s linear infinite;-o-animation:pace-spinner .4s linear infinite;animation:pace-spinner .4s linear infinite}@-webkit-keyframes pace-spinner{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-moz-keyframes pace-spinner{0%{-moz-transform:rotate(0);transform:rotate(0)}100%{-moz-transform:rotate(360deg);transform:rotate(360deg)}}@-o-keyframes pace-spinner{0%{-o-transform:rotate(0);transform:rotate(0)}100%{-o-transform:rotate(360deg);transform:rotate(360deg)}}@-ms-keyframes pace-spinner{0%{-ms-transform:rotate(0);transform:rotate(0)}100%{-ms-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes pace-spinner{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-flat-top.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;position:fixed;top:0;left:0;width:100%;-webkit-transform:translate3d(0,-50px,0);-ms-transform:translate3d(0,-50px,0);transform:translate3d(0,-50px,0);-webkit-transition:-webkit-transform .5s ease-out;-ms-transition:-webkit-transform .5s ease-out;transition:transform .5s ease-out}.pace.pace-active{-webkit-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.pace .pace-progress{display:block;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:10px;background:#29d;pointer-events:none}
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-loading-bar.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;-o-box-sizing:border-box;box-sizing:border-box;-webkit-border-radius:10px;-moz-border-radius:10px;border-radius:10px;-webkit-background-clip:padding-box;-moz-background-clip:padding;background-clip:padding-box;z-index:2000;position:fixed;margin:auto;top:12px;left:0;right:0;bottom:0;width:200px;height:50px;overflow:hidden}.pace .pace-progress{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;-o-box-sizing:border-box;box-sizing:border-box;-webkit-border-radius:2px;-moz-border-radius:2px;border-radius:2px;-webkit-background-clip:padding-box;-moz-background-clip:padding;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);display:block;position:absolute;right:100%;margin-right:-7px;width:93%;top:7px;height:14px;font-size:12px;background:#29d;color:#29d;line-height:60px;font-weight:700;font-family:Helvetica,Arial,"Lucida Grande",sans-serif;-webkit-box-shadow:120px 0 #fff,240px 0 #fff;-ms-box-shadow:120px 0 #fff,240px 0 #fff;box-shadow:120px 0 #fff,240px 0 #fff}.pace .pace-progress:after{content:attr(data-progress-text);display:inline-block;position:fixed;width:45px;text-align:right;right:0;padding-right:16px;top:4px}.pace .pace-progress[data-progress-text="0%"]:after{right:-200px}.pace .pace-progress[data-progress-text="1%"]:after{right:-198.14px}.pace .pace-progress[data-progress-text="2%"]:after{right:-196.28px}.pace .pace-progress[data-progress-text="3%"]:after{right:-194.42px}.pace .pace-progress[data-progress-text="4%"]:after{right:-192.56px}.pace .pace-progress[data-progress-text="5%"]:after{right:-190.7px}.pace .pace-progress[data-progress-text="6%"]:after{right:-188.84px}.pace .pace-progress[data-progress-text="7%"]:after{right:-186.98px}.pace .pace-progress[data-progress-text="8%"]:after{right:-185.12px}.pace .pace-progress[data-progress-text="9%"]:after{right:-183.26px}.pace .pace-progress[data-progress-text="10%"]:after{right:-181.4px}.pace .pace-progress[data-progress-text="11%"]:after{right:-179.54px}.pace .pace-progress[data-progress-text="12%"]:after{right:-177.68px}.pace .pace-progress[data-progress-text="13%"]:after{right:-175.82px}.pace .pace-progress[data-progress-text="14%"]:after{right:-173.96px}.pace .pace-progress[data-progress-text="15%"]:after{right:-172.1px}.pace .pace-progress[data-progress-text="16%"]:after{right:-170.24px}.pace .pace-progress[data-progress-text="17%"]:after{right:-168.38px}.pace .pace-progress[data-progress-text="18%"]:after{right:-166.52px}.pace .pace-progress[data-progress-text="19%"]:after{right:-164.66px}.pace .pace-progress[data-progress-text="20%"]:after{right:-162.8px}.pace .pace-progress[data-progress-text="21%"]:after{right:-160.94px}.pace .pace-progress[data-progress-text="22%"]:after{right:-159.08px}.pace .pace-progress[data-progress-text="23%"]:after{right:-157.22px}.pace .pace-progress[data-progress-text="24%"]:after{right:-155.36px}.pace .pace-progress[data-progress-text="25%"]:after{right:-153.5px}.pace .pace-progress[data-progress-text="26%"]:after{right:-151.64px}.pace .pace-progress[data-progress-text="27%"]:after{right:-149.78px}.pace .pace-progress[data-progress-text="28%"]:after{right:-147.92px}.pace .pace-progress[data-progress-text="29%"]:after{right:-146.06px}.pace .pace-progress[data-progress-text="30%"]:after{right:-144.2px}.pace .pace-progress[data-progress-text="31%"]:after{right:-142.34px}.pace .pace-progress[data-progress-text="32%"]:after{right:-140.48px}.pace .pace-progress[data-progress-text="33%"]:after{right:-138.62px}.pace .pace-progress[data-progress-text="34%"]:after{right:-136.76px}.pace .pace-progress[data-progress-text="35%"]:after{right:-134.9px}.pace .pace-progress[data-progress-text="36%"]:after{right:-133.04px}.pace .pace-progress[data-progress-text="37%"]:after{right:-131.18px}.pace .pace-progress[data-progress-text="38%"]:after{right:-129.32px}.pace .pace-progress[data-progress-text="39%"]:after{right:-127.46px}.pace .pace-progress[data-progress-text="40%"]:after{right:-125.6px}.pace .pace-progress[data-progress-text="41%"]:after{right:-123.74px}.pace .pace-progress[data-progress-text="42%"]:after{right:-121.88px}.pace .pace-progress[data-progress-text="43%"]:after{right:-120.02px}.pace .pace-progress[data-progress-text="44%"]:after{right:-118.16px}.pace .pace-progress[data-progress-text="45%"]:after{right:-116.3px}.pace .pace-progress[data-progress-text="46%"]:after{right:-114.44px}.pace .pace-progress[data-progress-text="47%"]:after{right:-112.58px}.pace .pace-progress[data-progress-text="48%"]:after{right:-110.72px}.pace .pace-progress[data-progress-text="49%"]:after{right:-108.86px}.pace .pace-progress[data-progress-text="50%"]:after{right:-107px}.pace .pace-progress[data-progress-text="51%"]:after{right:-105.14px}.pace .pace-progress[data-progress-text="52%"]:after{right:-103.28px}.pace .pace-progress[data-progress-text="53%"]:after{right:-101.42px}.pace .pace-progress[data-progress-text="54%"]:after{right:-99.56px}.pace .pace-progress[data-progress-text="55%"]:after{right:-97.7px}.pace .pace-progress[data-progress-text="56%"]:after{right:-95.84px}.pace .pace-progress[data-progress-text="57%"]:after{right:-93.98px}.pace .pace-progress[data-progress-text="58%"]:after{right:-92.12px}.pace .pace-progress[data-progress-text="59%"]:after{right:-90.26px}.pace .pace-progress[data-progress-text="60%"]:after{right:-88.4px}.pace .pace-progress[data-progress-text="61%"]:after{right:-86.54px}.pace .pace-progress[data-progress-text="62%"]:after{right:-84.68px}.pace .pace-progress[data-progress-text="63%"]:after{right:-82.82px}.pace .pace-progress[data-progress-text="64%"]:after{right:-80.96px}.pace .pace-progress[data-progress-text="65%"]:after{right:-79.1px}.pace .pace-progress[data-progress-text="66%"]:after{right:-77.24px}.pace .pace-progress[data-progress-text="67%"]:after{right:-75.38px}.pace .pace-progress[data-progress-text="68%"]:after{right:-73.52px}.pace .pace-progress[data-progress-text="69%"]:after{right:-71.66px}.pace .pace-progress[data-progress-text="70%"]:after{right:-69.8px}.pace .pace-progress[data-progress-text="71%"]:after{right:-67.94px}.pace .pace-progress[data-progress-text="72%"]:after{right:-66.08px}.pace .pace-progress[data-progress-text="73%"]:after{right:-64.22px}.pace .pace-progress[data-progress-text="74%"]:after{right:-62.36px}.pace .pace-progress[data-progress-text="75%"]:after{right:-60.5px}.pace .pace-progress[data-progress-text="76%"]:after{right:-58.64px}.pace .pace-progress[data-progress-text="77%"]:after{right:-56.78px}.pace .pace-progress[data-progress-text="78%"]:after{right:-54.92px}.pace .pace-progress[data-progress-text="79%"]:after{right:-53.06px}.pace .pace-progress[data-progress-text="80%"]:after{right:-51.2px}.pace .pace-progress[data-progress-text="81%"]:after{right:-49.34px}.pace .pace-progress[data-progress-text="82%"]:after{right:-47.48px}.pace .pace-progress[data-progress-text="83%"]:after{right:-45.62px}.pace .pace-progress[data-progress-text="84%"]:after{right:-43.76px}.pace .pace-progress[data-progress-text="85%"]:after{right:-41.9px}.pace .pace-progress[data-progress-text="86%"]:after{right:-40.04px}.pace .pace-progress[data-progress-text="87%"]:after{right:-38.18px}.pace .pace-progress[data-progress-text="88%"]:after{right:-36.32px}.pace .pace-progress[data-progress-text="89%"]:after{right:-34.46px}.pace .pace-progress[data-progress-text="90%"]:after{right:-32.6px}.pace .pace-progress[data-progress-text="91%"]:after{right:-30.74px}.pace .pace-progress[data-progress-text="92%"]:after{right:-28.88px}.pace .pace-progress[data-progress-text="93%"]:after{right:-27.02px}.pace .pace-progress[data-progress-text="94%"]:after{right:-25.16px}.pace .pace-progress[data-progress-text="95%"]:after{right:-23.3px}.pace .pace-progress[data-progress-text="96%"]:after{right:-21.44px}.pace .pace-progress[data-progress-text="97%"]:after{right:-19.58px}.pace .pace-progress[data-progress-text="98%"]:after{right:-17.72px}.pace .pace-progress[data-progress-text="99%"]:after{right:-15.86px}.pace .pace-progress[data-progress-text="100%"]:after{right:-14px}.pace .pace-activity{position:absolute;width:100%;height:28px;z-index:2001;box-shadow:inset 0 0 0 2px #29d,inset 0 0 0 7px #FFF;border-radius:10px}.pace.pace-inactive{display:none}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-minimal.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#29d;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-mac-osx.min.css</url>
    <content><![CDATA[.pace,.pace .pace-progress{width:100%;height:12px;overflow:hidden}.pace,.pace .pace-activity{position:fixed;top:0;left:0}.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;z-index:2000;background:#fff}.pace-inactive{display:none}.pace .pace-progress{background-color:#0087E1;position:fixed;top:0;right:100%;-webkit-border-radius:0 0 4px;-moz-border-radius:0 0 4px;-o-border-radius:0 0 4px;border-radius:0 0 4px;-webkit-box-shadow:inset -1px 0 #00558F,inset 0 -1px #00558F,inset 0 2px rgba(255,255,255,.5),inset 0 6px rgba(255,255,255,.3);-moz-box-shadow:inset -1px 0 #00558F,inset 0 -1px #00558F,inset 0 2px rgba(255,255,255,.5),inset 0 6px rgba(255,255,255,.3);-o-box-shadow:inset -1px 0 #00558F,inset 0 -1px #00558F,inset 0 2px rgba(255,255,255,.5),inset 0 6px rgba(255,255,255,.3);box-shadow:inset -1px 0 #00558F,inset 0 -1px #00558F,inset 0 2px rgba(255,255,255,.5),inset 0 6px rgba(255,255,255,.3)}.pace .pace-activity{right:-28px;bottom:0;-webkit-background-image:radial-gradient(rgba(255,255,255,.65) 0,rgba(255,255,255,.15) 100%);-moz-background-image:radial-gradient(rgba(255,255,255,.65) 0,rgba(255,255,255,.15) 100%);-o-background-image:radial-gradient(rgba(255,255,255,.65) 0,rgba(255,255,255,.15) 100%);background-image:radial-gradient(rgba(255,255,255,.65) 0,rgba(255,255,255,.15) 100%);-webkit-background-size:28px 100%;-moz-background-size:28px 100%;-o-background-size:28px 100%;background-size:28px 100%;-webkit-animation:pace-theme-mac-osx-motion .5s linear infinite;-moz-animation:pace-theme-mac-osx-motion .5s linear infinite;-ms-animation:pace-theme-mac-osx-motion .5s linear infinite;-o-animation:pace-theme-mac-osx-motion .5s linear infinite;animation:pace-theme-mac-osx-motion .5s linear infinite}@-webkit-keyframes pace-theme-mac-osx-motion{0%{-webkit-transform:none;transform:none}100%{-webkit-transform:translate(-28px,0);transform:translate(-28px,0)}}@-moz-keyframes pace-theme-mac-osx-motion{0%{-moz-transform:none;transform:none}100%{-moz-transform:translate(-28px,0);transform:translate(-28px,0)}}@-o-keyframes pace-theme-mac-osx-motion{0%{-o-transform:none;transform:none}100%{-o-transform:translate(-28px,0);transform:translate(-28px,0)}}@-ms-keyframes pace-theme-mac-osx-motion{0%{-ms-transform:none;transform:none}100%{-ms-transform:translate(-28px,0);transform:translate(-28px,0)}}@keyframes pace-theme-mac-osx-motion{0%{transform:none}100%{transform:translate(-28px,0)}}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace.min.js</url>
    <content><![CDATA[/*! pace 1.0.2 */
(function(){var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X=[].slice,Y={}.hasOwnProperty,Z=function(a,b){function c(){this.constructor=a}for(var d in b)Y.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a},$=[].indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(b in this&&this[b]===a)return b;return-1};for(u={catchupTime:100,initialRate:.03,minTime:250,ghostTime:100,maxProgressPerFrame:20,easeFactor:1.25,startOnPageLoad:!0,restartOnPushState:!0,restartOnRequestAfter:500,target:"body",elements:{checkInterval:100,selectors:["body"]},eventLag:{minSamples:10,sampleCount:3,lagThreshold:3},ajax:{trackMethods:["GET"],trackWebSockets:!0,ignoreURLs:[]}},C=function(){var a;return null!=(a="undefined"!=typeof performance&&null!==performance&&"function"==typeof performance.now?performance.now():void 0)?a:+new Date},E=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame,t=window.cancelAnimationFrame||window.mozCancelAnimationFrame,null==E&&(E=function(a){return setTimeout(a,50)},t=function(a){return clearTimeout(a)}),G=function(a){var b,c;return b=C(),(c=function(){var d;return d=C()-b,d>=33?(b=C(),a(d,function(){return E(c)})):setTimeout(c,33-d)})()},F=function(){var a,b,c;return c=arguments[0],b=arguments[1],a=3<=arguments.length?X.call(arguments,2):[],"function"==typeof c[b]?c[b].apply(c,a):c[b]},v=function(){var a,b,c,d,e,f,g;for(b=arguments[0],d=2<=arguments.length?X.call(arguments,1):[],f=0,g=d.length;g>f;f++)if(c=d[f])for(a in c)Y.call(c,a)&&(e=c[a],null!=b[a]&&"object"==typeof b[a]&&null!=e&&"object"==typeof e?v(b[a],e):b[a]=e);return b},q=function(a){var b,c,d,e,f;for(c=b=0,e=0,f=a.length;f>e;e++)d=a[e],c+=Math.abs(d),b++;return c/b},x=function(a,b){var c,d,e;if(null==a&&(a="options"),null==b&&(b=!0),e=document.querySelector("[data-pace-"+a+"]")){if(c=e.getAttribute("data-pace-"+a),!b)return c;try{return JSON.parse(c)}catch(f){return d=f,"undefined"!=typeof console&&null!==console?console.error("Error parsing inline pace options",d):void 0}}},g=function(){function a(){}return a.prototype.on=function(a,b,c,d){var e;return null==d&&(d=!1),null==this.bindings&&(this.bindings={}),null==(e=this.bindings)[a]&&(e[a]=[]),this.bindings[a].push({handler:b,ctx:c,once:d})},a.prototype.once=function(a,b,c){return this.on(a,b,c,!0)},a.prototype.off=function(a,b){var c,d,e;if(null!=(null!=(d=this.bindings)?d[a]:void 0)){if(null==b)return delete this.bindings[a];for(c=0,e=[];c<this.bindings[a].length;)e.push(this.bindings[a][c].handler===b?this.bindings[a].splice(c,1):c++);return e}},a.prototype.trigger=function(){var a,b,c,d,e,f,g,h,i;if(c=arguments[0],a=2<=arguments.length?X.call(arguments,1):[],null!=(g=this.bindings)?g[c]:void 0){for(e=0,i=[];e<this.bindings[c].length;)h=this.bindings[c][e],d=h.handler,b=h.ctx,f=h.once,d.apply(null!=b?b:this,a),i.push(f?this.bindings[c].splice(e,1):e++);return i}},a}(),j=window.Pace||{},window.Pace=j,v(j,g.prototype),D=j.options=v({},u,window.paceOptions,x()),U=["ajax","document","eventLag","elements"],Q=0,S=U.length;S>Q;Q++)K=U[Q],D[K]===!0&&(D[K]=u[K]);i=function(a){function b(){return V=b.__super__.constructor.apply(this,arguments)}return Z(b,a),b}(Error),b=function(){function a(){this.progress=0}return a.prototype.getElement=function(){var a;if(null==this.el){if(a=document.querySelector(D.target),!a)throw new i;this.el=document.createElement("div"),this.el.className="pace pace-active",document.body.className=document.body.className.replace(/pace-done/g,""),document.body.className+=" pace-running",this.el.innerHTML='<div class="pace-progress">\n  <div class="pace-progress-inner"></div>\n</div>\n<div class="pace-activity"></div>',null!=a.firstChild?a.insertBefore(this.el,a.firstChild):a.appendChild(this.el)}return this.el},a.prototype.finish=function(){var a;return a=this.getElement(),a.className=a.className.replace("pace-active",""),a.className+=" pace-inactive",document.body.className=document.body.className.replace("pace-running",""),document.body.className+=" pace-done"},a.prototype.update=function(a){return this.progress=a,this.render()},a.prototype.destroy=function(){try{this.getElement().parentNode.removeChild(this.getElement())}catch(a){i=a}return this.el=void 0},a.prototype.render=function(){var a,b,c,d,e,f,g;if(null==document.querySelector(D.target))return!1;for(a=this.getElement(),d="translate3d("+this.progress+"%, 0, 0)",g=["webkitTransform","msTransform","transform"],e=0,f=g.length;f>e;e++)b=g[e],a.children[0].style[b]=d;return(!this.lastRenderedProgress||this.lastRenderedProgress|0!==this.progress|0)&&(a.children[0].setAttribute("data-progress-text",""+(0|this.progress)+"%"),this.progress>=100?c="99":(c=this.progress<10?"0":"",c+=0|this.progress),a.children[0].setAttribute("data-progress",""+c)),this.lastRenderedProgress=this.progress},a.prototype.done=function(){return this.progress>=100},a}(),h=function(){function a(){this.bindings={}}return a.prototype.trigger=function(a,b){var c,d,e,f,g;if(null!=this.bindings[a]){for(f=this.bindings[a],g=[],d=0,e=f.length;e>d;d++)c=f[d],g.push(c.call(this,b));return g}},a.prototype.on=function(a,b){var c;return null==(c=this.bindings)[a]&&(c[a]=[]),this.bindings[a].push(b)},a}(),P=window.XMLHttpRequest,O=window.XDomainRequest,N=window.WebSocket,w=function(a,b){var c,d,e;e=[];for(d in b.prototype)try{e.push(null==a[d]&&"function"!=typeof b[d]?"function"==typeof Object.defineProperty?Object.defineProperty(a,d,{get:function(){return b.prototype[d]},configurable:!0,enumerable:!0}):a[d]=b.prototype[d]:void 0)}catch(f){c=f}return e},A=[],j.ignore=function(){var a,b,c;return b=arguments[0],a=2<=arguments.length?X.call(arguments,1):[],A.unshift("ignore"),c=b.apply(null,a),A.shift(),c},j.track=function(){var a,b,c;return b=arguments[0],a=2<=arguments.length?X.call(arguments,1):[],A.unshift("track"),c=b.apply(null,a),A.shift(),c},J=function(a){var b;if(null==a&&(a="GET"),"track"===A[0])return"force";if(!A.length&&D.ajax){if("socket"===a&&D.ajax.trackWebSockets)return!0;if(b=a.toUpperCase(),$.call(D.ajax.trackMethods,b)>=0)return!0}return!1},k=function(a){function b(){var a,c=this;b.__super__.constructor.apply(this,arguments),a=function(a){var b;return b=a.open,a.open=function(d,e){return J(d)&&c.trigger("request",{type:d,url:e,request:a}),b.apply(a,arguments)}},window.XMLHttpRequest=function(b){var c;return c=new P(b),a(c),c};try{w(window.XMLHttpRequest,P)}catch(d){}if(null!=O){window.XDomainRequest=function(){var b;return b=new O,a(b),b};try{w(window.XDomainRequest,O)}catch(d){}}if(null!=N&&D.ajax.trackWebSockets){window.WebSocket=function(a,b){var d;return d=null!=b?new N(a,b):new N(a),J("socket")&&c.trigger("request",{type:"socket",url:a,protocols:b,request:d}),d};try{w(window.WebSocket,N)}catch(d){}}}return Z(b,a),b}(h),R=null,y=function(){return null==R&&(R=new k),R},I=function(a){var b,c,d,e;for(e=D.ajax.ignoreURLs,c=0,d=e.length;d>c;c++)if(b=e[c],"string"==typeof b){if(-1!==a.indexOf(b))return!0}else if(b.test(a))return!0;return!1},y().on("request",function(b){var c,d,e,f,g;return f=b.type,e=b.request,g=b.url,I(g)?void 0:j.running||D.restartOnRequestAfter===!1&&"force"!==J(f)?void 0:(d=arguments,c=D.restartOnRequestAfter||0,"boolean"==typeof c&&(c=0),setTimeout(function(){var b,c,g,h,i,k;if(b="socket"===f?e.readyState<2:0<(h=e.readyState)&&4>h){for(j.restart(),i=j.sources,k=[],c=0,g=i.length;g>c;c++){if(K=i[c],K instanceof a){K.watch.apply(K,d);break}k.push(void 0)}return k}},c))}),a=function(){function a(){var a=this;this.elements=[],y().on("request",function(){return a.watch.apply(a,arguments)})}return a.prototype.watch=function(a){var b,c,d,e;return d=a.type,b=a.request,e=a.url,I(e)?void 0:(c="socket"===d?new n(b):new o(b),this.elements.push(c))},a}(),o=function(){function a(a){var b,c,d,e,f,g,h=this;if(this.progress=0,null!=window.ProgressEvent)for(c=null,a.addEventListener("progress",function(a){return h.progress=a.lengthComputable?100*a.loaded/a.total:h.progress+(100-h.progress)/2},!1),g=["load","abort","timeout","error"],d=0,e=g.length;e>d;d++)b=g[d],a.addEventListener(b,function(){return h.progress=100},!1);else f=a.onreadystatechange,a.onreadystatechange=function(){var b;return 0===(b=a.readyState)||4===b?h.progress=100:3===a.readyState&&(h.progress=50),"function"==typeof f?f.apply(null,arguments):void 0}}return a}(),n=function(){function a(a){var b,c,d,e,f=this;for(this.progress=0,e=["error","open"],c=0,d=e.length;d>c;c++)b=e[c],a.addEventListener(b,function(){return f.progress=100},!1)}return a}(),d=function(){function a(a){var b,c,d,f;for(null==a&&(a={}),this.elements=[],null==a.selectors&&(a.selectors=[]),f=a.selectors,c=0,d=f.length;d>c;c++)b=f[c],this.elements.push(new e(b))}return a}(),e=function(){function a(a){this.selector=a,this.progress=0,this.check()}return a.prototype.check=function(){var a=this;return document.querySelector(this.selector)?this.done():setTimeout(function(){return a.check()},D.elements.checkInterval)},a.prototype.done=function(){return this.progress=100},a}(),c=function(){function a(){var a,b,c=this;this.progress=null!=(b=this.states[document.readyState])?b:100,a=document.onreadystatechange,document.onreadystatechange=function(){return null!=c.states[document.readyState]&&(c.progress=c.states[document.readyState]),"function"==typeof a?a.apply(null,arguments):void 0}}return a.prototype.states={loading:0,interactive:50,complete:100},a}(),f=function(){function a(){var a,b,c,d,e,f=this;this.progress=0,a=0,e=[],d=0,c=C(),b=setInterval(function(){var g;return g=C()-c-50,c=C(),e.push(g),e.length>D.eventLag.sampleCount&&e.shift(),a=q(e),++d>=D.eventLag.minSamples&&a<D.eventLag.lagThreshold?(f.progress=100,clearInterval(b)):f.progress=100*(3/(a+3))},50)}return a}(),m=function(){function a(a){this.source=a,this.last=this.sinceLastUpdate=0,this.rate=D.initialRate,this.catchup=0,this.progress=this.lastProgress=0,null!=this.source&&(this.progress=F(this.source,"progress"))}return a.prototype.tick=function(a,b){var c;return null==b&&(b=F(this.source,"progress")),b>=100&&(this.done=!0),b===this.last?this.sinceLastUpdate+=a:(this.sinceLastUpdate&&(this.rate=(b-this.last)/this.sinceLastUpdate),this.catchup=(b-this.progress)/D.catchupTime,this.sinceLastUpdate=0,this.last=b),b>this.progress&&(this.progress+=this.catchup*a),c=1-Math.pow(this.progress/100,D.easeFactor),this.progress+=c*this.rate*a,this.progress=Math.min(this.lastProgress+D.maxProgressPerFrame,this.progress),this.progress=Math.max(0,this.progress),this.progress=Math.min(100,this.progress),this.lastProgress=this.progress,this.progress},a}(),L=null,H=null,r=null,M=null,p=null,s=null,j.running=!1,z=function(){return D.restartOnPushState?j.restart():void 0},null!=window.history.pushState&&(T=window.history.pushState,window.history.pushState=function(){return z(),T.apply(window.history,arguments)}),null!=window.history.replaceState&&(W=window.history.replaceState,window.history.replaceState=function(){return z(),W.apply(window.history,arguments)}),l={ajax:a,elements:d,document:c,eventLag:f},(B=function(){var a,c,d,e,f,g,h,i;for(j.sources=L=[],g=["ajax","elements","document","eventLag"],c=0,e=g.length;e>c;c++)a=g[c],D[a]!==!1&&L.push(new l[a](D[a]));for(i=null!=(h=D.extraSources)?h:[],d=0,f=i.length;f>d;d++)K=i[d],L.push(new K(D));return j.bar=r=new b,H=[],M=new m})(),j.stop=function(){return j.trigger("stop"),j.running=!1,r.destroy(),s=!0,null!=p&&("function"==typeof t&&t(p),p=null),B()},j.restart=function(){return j.trigger("restart"),j.stop(),j.start()},j.go=function(){var a;return j.running=!0,r.render(),a=C(),s=!1,p=G(function(b,c){var d,e,f,g,h,i,k,l,n,o,p,q,t,u,v,w;for(l=100-r.progress,e=p=0,f=!0,i=q=0,u=L.length;u>q;i=++q)for(K=L[i],o=null!=H[i]?H[i]:H[i]=[],h=null!=(w=K.elements)?w:[K],k=t=0,v=h.length;v>t;k=++t)g=h[k],n=null!=o[k]?o[k]:o[k]=new m(g),f&=n.done,n.done||(e++,p+=n.tick(b));return d=p/e,r.update(M.tick(b,d)),r.done()||f||s?(r.update(100),j.trigger("done"),setTimeout(function(){return r.finish(),j.running=!1,j.trigger("hide")},Math.max(D.ghostTime,Math.max(D.minTime-(C()-a),0)))):c()})},j.start=function(a){v(D,a),j.running=!0;try{r.render()}catch(b){i=b}return document.querySelector(".pace")?(j.trigger("start"),j.go()):setTimeout(j.start,50)},"function"==typeof define&&define.amd?define(["pace"],function(){return j}):"object"==typeof exports?module.exports=j:D.startOnPageLoad&&j.start()}).call(this);]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-material.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;color:#29d}.pace-progress{position:fixed;z-index:2000;top:50%;left:50%;margin-left:-2.5rem;margin-top:-2.5rem;height:5rem;width:5rem;opacity:1;-webkit-transition:opacity .1s;transition:opacity .1s;-webkit-transform:translate3d(0,0,0)!important;-ms-transform:translate3d(0,0,0)!important;transform:translate3d(0,0,0)!important}.pace-inactive .pace-progress,.pace-progress[data-progress="00"]{opacity:0}.pace-progress:after{height:5rem;width:5rem;text-align:center;line-height:5rem;content:attr(data-progress);display:block;font-size:1.8rem;font-family:'Helvetica Neue',Helvetica,Arial,sans-serif;font-weight:300}.pace-progress .pace-progress-inner{overflow:hidden;position:absolute;width:2.5rem;height:5rem;-webkit-transform-origin:left center;-ms-transform-origin:left center;transform-origin:left center;-webkit-transition:-webkit-transform .1s;transition:transform .1s;left:2.5rem;top:0}.pace-progress .pace-progress-inner:after,.pace-progress .pace-progress-inner:before{position:absolute;width:5rem;height:5rem;content:' ';left:-2.5rem;top:0;box-sizing:border-box;border:1px solid;border-radius:5rem}.pace-progress .pace-progress-inner:before{border-right-color:transparent;border-bottom-color:transparent;-webkit-transform:rotate(135deg);-ms-transform:rotate(135deg);transform:rotate(135deg)}.pace-progress .pace-progress-inner:after{border-left-color:transparent;border-top-color:transparent;display:none;-webkit-transform:rotate(315deg);-ms-transform:rotate(315deg);transform:rotate(315deg)}.pace-progress[data-progress="00"] .pace-progress-inner:before{-webkit-transform:rotate(-45deg);-ms-transform:rotate(-45deg);transform:rotate(-45deg)}.pace-progress[data-progress="01"] .pace-progress-inner:before{-webkit-transform:rotate(-41deg);-ms-transform:rotate(-41deg);transform:rotate(-41deg)}.pace-progress[data-progress="02"] .pace-progress-inner:before{-webkit-transform:rotate(-38deg);-ms-transform:rotate(-38deg);transform:rotate(-38deg)}.pace-progress[data-progress="03"] .pace-progress-inner:before{-webkit-transform:rotate(-34deg);-ms-transform:rotate(-34deg);transform:rotate(-34deg)}.pace-progress[data-progress="04"] .pace-progress-inner:before{-webkit-transform:rotate(-31deg);-ms-transform:rotate(-31deg);transform:rotate(-31deg)}.pace-progress[data-progress="05"] .pace-progress-inner:before{-webkit-transform:rotate(-27deg);-ms-transform:rotate(-27deg);transform:rotate(-27deg)}.pace-progress[data-progress="06"] .pace-progress-inner:before{-webkit-transform:rotate(-23deg);-ms-transform:rotate(-23deg);transform:rotate(-23deg)}.pace-progress[data-progress="07"] .pace-progress-inner:before{-webkit-transform:rotate(-20deg);-ms-transform:rotate(-20deg);transform:rotate(-20deg)}.pace-progress[data-progress="08"] .pace-progress-inner:before{-webkit-transform:rotate(-16deg);-ms-transform:rotate(-16deg);transform:rotate(-16deg)}.pace-progress[data-progress="09"] .pace-progress-inner:before{-webkit-transform:rotate(-13deg);-ms-transform:rotate(-13deg);transform:rotate(-13deg)}.pace-progress[data-progress="10"] .pace-progress-inner:before{-webkit-transform:rotate(-9deg);-ms-transform:rotate(-9deg);transform:rotate(-9deg)}.pace-progress[data-progress="11"] .pace-progress-inner:before{-webkit-transform:rotate(-5deg);-ms-transform:rotate(-5deg);transform:rotate(-5deg)}.pace-progress[data-progress="12"] .pace-progress-inner:before{-webkit-transform:rotate(-2deg);-ms-transform:rotate(-2deg);transform:rotate(-2deg)}.pace-progress[data-progress="13"] .pace-progress-inner:before{-webkit-transform:rotate(2deg);-ms-transform:rotate(2deg);transform:rotate(2deg)}.pace-progress[data-progress="14"] .pace-progress-inner:before{-webkit-transform:rotate(5deg);-ms-transform:rotate(5deg);transform:rotate(5deg)}.pace-progress[data-progress="15"] .pace-progress-inner:before{-webkit-transform:rotate(9deg);-ms-transform:rotate(9deg);transform:rotate(9deg)}.pace-progress[data-progress="16"] .pace-progress-inner:before{-webkit-transform:rotate(13deg);-ms-transform:rotate(13deg);transform:rotate(13deg)}.pace-progress[data-progress="17"] .pace-progress-inner:before{-webkit-transform:rotate(16deg);-ms-transform:rotate(16deg);transform:rotate(16deg)}.pace-progress[data-progress="18"] .pace-progress-inner:before{-webkit-transform:rotate(20deg);-ms-transform:rotate(20deg);transform:rotate(20deg)}.pace-progress[data-progress="19"] .pace-progress-inner:before{-webkit-transform:rotate(23deg);-ms-transform:rotate(23deg);transform:rotate(23deg)}.pace-progress[data-progress="20"] .pace-progress-inner:before{-webkit-transform:rotate(27deg);-ms-transform:rotate(27deg);transform:rotate(27deg)}.pace-progress[data-progress="21"] .pace-progress-inner:before{-webkit-transform:rotate(31deg);-ms-transform:rotate(31deg);transform:rotate(31deg)}.pace-progress[data-progress="22"] .pace-progress-inner:before{-webkit-transform:rotate(34deg);-ms-transform:rotate(34deg);transform:rotate(34deg)}.pace-progress[data-progress="23"] .pace-progress-inner:before{-webkit-transform:rotate(38deg);-ms-transform:rotate(38deg);transform:rotate(38deg)}.pace-progress[data-progress="24"] .pace-progress-inner:before{-webkit-transform:rotate(41deg);-ms-transform:rotate(41deg);transform:rotate(41deg)}.pace-progress[data-progress="25"] .pace-progress-inner:before{-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);transform:rotate(45deg)}.pace-progress[data-progress="26"] .pace-progress-inner:before{-webkit-transform:rotate(49deg);-ms-transform:rotate(49deg);transform:rotate(49deg)}.pace-progress[data-progress="27"] .pace-progress-inner:before{-webkit-transform:rotate(52deg);-ms-transform:rotate(52deg);transform:rotate(52deg)}.pace-progress[data-progress="28"] .pace-progress-inner:before{-webkit-transform:rotate(56deg);-ms-transform:rotate(56deg);transform:rotate(56deg)}.pace-progress[data-progress="29"] .pace-progress-inner:before{-webkit-transform:rotate(59deg);-ms-transform:rotate(59deg);transform:rotate(59deg)}.pace-progress[data-progress="30"] .pace-progress-inner:before{-webkit-transform:rotate(63deg);-ms-transform:rotate(63deg);transform:rotate(63deg)}.pace-progress[data-progress="31"] .pace-progress-inner:before{-webkit-transform:rotate(67deg);-ms-transform:rotate(67deg);transform:rotate(67deg)}.pace-progress[data-progress="32"] .pace-progress-inner:before{-webkit-transform:rotate(70deg);-ms-transform:rotate(70deg);transform:rotate(70deg)}.pace-progress[data-progress="33"] .pace-progress-inner:before{-webkit-transform:rotate(74deg);-ms-transform:rotate(74deg);transform:rotate(74deg)}.pace-progress[data-progress="34"] .pace-progress-inner:before{-webkit-transform:rotate(77deg);-ms-transform:rotate(77deg);transform:rotate(77deg)}.pace-progress[data-progress="35"] .pace-progress-inner:before{-webkit-transform:rotate(81deg);-ms-transform:rotate(81deg);transform:rotate(81deg)}.pace-progress[data-progress="36"] .pace-progress-inner:before{-webkit-transform:rotate(85deg);-ms-transform:rotate(85deg);transform:rotate(85deg)}.pace-progress[data-progress="37"] .pace-progress-inner:before{-webkit-transform:rotate(88deg);-ms-transform:rotate(88deg);transform:rotate(88deg)}.pace-progress[data-progress="38"] .pace-progress-inner:before{-webkit-transform:rotate(92deg);-ms-transform:rotate(92deg);transform:rotate(92deg)}.pace-progress[data-progress="39"] .pace-progress-inner:before{-webkit-transform:rotate(95deg);-ms-transform:rotate(95deg);transform:rotate(95deg)}.pace-progress[data-progress="40"] .pace-progress-inner:before{-webkit-transform:rotate(99deg);-ms-transform:rotate(99deg);transform:rotate(99deg)}.pace-progress[data-progress="41"] .pace-progress-inner:before{-webkit-transform:rotate(103deg);-ms-transform:rotate(103deg);transform:rotate(103deg)}.pace-progress[data-progress="42"] .pace-progress-inner:before{-webkit-transform:rotate(106deg);-ms-transform:rotate(106deg);transform:rotate(106deg)}.pace-progress[data-progress="43"] .pace-progress-inner:before{-webkit-transform:rotate(110deg);-ms-transform:rotate(110deg);transform:rotate(110deg)}.pace-progress[data-progress="44"] .pace-progress-inner:before{-webkit-transform:rotate(113deg);-ms-transform:rotate(113deg);transform:rotate(113deg)}.pace-progress[data-progress="45"] .pace-progress-inner:before{-webkit-transform:rotate(117deg);-ms-transform:rotate(117deg);transform:rotate(117deg)}.pace-progress[data-progress="46"] .pace-progress-inner:before{-webkit-transform:rotate(121deg);-ms-transform:rotate(121deg);transform:rotate(121deg)}.pace-progress[data-progress="47"] .pace-progress-inner:before{-webkit-transform:rotate(124deg);-ms-transform:rotate(124deg);transform:rotate(124deg)}.pace-progress[data-progress="48"] .pace-progress-inner:before{-webkit-transform:rotate(128deg);-ms-transform:rotate(128deg);transform:rotate(128deg)}.pace-progress[data-progress="49"] .pace-progress-inner:before{-webkit-transform:rotate(131deg);-ms-transform:rotate(131deg);transform:rotate(131deg)}.pace-progress[data-progress="50"] .pace-progress-inner:before{-webkit-transform:rotate(135deg);-ms-transform:rotate(135deg);transform:rotate(135deg)}.pace-progress[data-progress="50"] .pace-progress-inner:after{-webkit-transform:rotate(315deg);-ms-transform:rotate(315deg);transform:rotate(315deg);display:block}.pace-progress[data-progress="51"] .pace-progress-inner:after{-webkit-transform:rotate(319deg);-ms-transform:rotate(319deg);transform:rotate(319deg);display:block}.pace-progress[data-progress="52"] .pace-progress-inner:after{-webkit-transform:rotate(322deg);-ms-transform:rotate(322deg);transform:rotate(322deg);display:block}.pace-progress[data-progress="53"] .pace-progress-inner:after{-webkit-transform:rotate(326deg);-ms-transform:rotate(326deg);transform:rotate(326deg);display:block}.pace-progress[data-progress="54"] .pace-progress-inner:after{-webkit-transform:rotate(329deg);-ms-transform:rotate(329deg);transform:rotate(329deg);display:block}.pace-progress[data-progress="55"] .pace-progress-inner:after{-webkit-transform:rotate(333deg);-ms-transform:rotate(333deg);transform:rotate(333deg);display:block}.pace-progress[data-progress="56"] .pace-progress-inner:after{-webkit-transform:rotate(337deg);-ms-transform:rotate(337deg);transform:rotate(337deg);display:block}.pace-progress[data-progress="57"] .pace-progress-inner:after{-webkit-transform:rotate(340deg);-ms-transform:rotate(340deg);transform:rotate(340deg);display:block}.pace-progress[data-progress="58"] .pace-progress-inner:after{-webkit-transform:rotate(344deg);-ms-transform:rotate(344deg);transform:rotate(344deg);display:block}.pace-progress[data-progress="59"] .pace-progress-inner:after{-webkit-transform:rotate(347deg);-ms-transform:rotate(347deg);transform:rotate(347deg);display:block}.pace-progress[data-progress="60"] .pace-progress-inner:after{-webkit-transform:rotate(351deg);-ms-transform:rotate(351deg);transform:rotate(351deg);display:block}.pace-progress[data-progress="61"] .pace-progress-inner:after{-webkit-transform:rotate(355deg);-ms-transform:rotate(355deg);transform:rotate(355deg);display:block}.pace-progress[data-progress="62"] .pace-progress-inner:after{-webkit-transform:rotate(358deg);-ms-transform:rotate(358deg);transform:rotate(358deg);display:block}.pace-progress[data-progress="63"] .pace-progress-inner:after{-webkit-transform:rotate(362deg);-ms-transform:rotate(362deg);transform:rotate(362deg);display:block}.pace-progress[data-progress="64"] .pace-progress-inner:after{-webkit-transform:rotate(365deg);-ms-transform:rotate(365deg);transform:rotate(365deg);display:block}.pace-progress[data-progress="65"] .pace-progress-inner:after{-webkit-transform:rotate(369deg);-ms-transform:rotate(369deg);transform:rotate(369deg);display:block}.pace-progress[data-progress="66"] .pace-progress-inner:after{-webkit-transform:rotate(373deg);-ms-transform:rotate(373deg);transform:rotate(373deg);display:block}.pace-progress[data-progress="67"] .pace-progress-inner:after{-webkit-transform:rotate(376deg);-ms-transform:rotate(376deg);transform:rotate(376deg);display:block}.pace-progress[data-progress="68"] .pace-progress-inner:after{-webkit-transform:rotate(380deg);-ms-transform:rotate(380deg);transform:rotate(380deg);display:block}.pace-progress[data-progress="69"] .pace-progress-inner:after{-webkit-transform:rotate(383deg);-ms-transform:rotate(383deg);transform:rotate(383deg);display:block}.pace-progress[data-progress="70"] .pace-progress-inner:after{-webkit-transform:rotate(387deg);-ms-transform:rotate(387deg);transform:rotate(387deg);display:block}.pace-progress[data-progress="71"] .pace-progress-inner:after{-webkit-transform:rotate(391deg);-ms-transform:rotate(391deg);transform:rotate(391deg);display:block}.pace-progress[data-progress="72"] .pace-progress-inner:after{-webkit-transform:rotate(394deg);-ms-transform:rotate(394deg);transform:rotate(394deg);display:block}.pace-progress[data-progress="73"] .pace-progress-inner:after{-webkit-transform:rotate(398deg);-ms-transform:rotate(398deg);transform:rotate(398deg);display:block}.pace-progress[data-progress="74"] .pace-progress-inner:after{-webkit-transform:rotate(401deg);-ms-transform:rotate(401deg);transform:rotate(401deg);display:block}.pace-progress[data-progress="75"] .pace-progress-inner:after{-webkit-transform:rotate(405deg);-ms-transform:rotate(405deg);transform:rotate(405deg);display:block}.pace-progress[data-progress="76"] .pace-progress-inner:after{-webkit-transform:rotate(409deg);-ms-transform:rotate(409deg);transform:rotate(409deg);display:block}.pace-progress[data-progress="77"] .pace-progress-inner:after{-webkit-transform:rotate(412deg);-ms-transform:rotate(412deg);transform:rotate(412deg);display:block}.pace-progress[data-progress="78"] .pace-progress-inner:after{-webkit-transform:rotate(416deg);-ms-transform:rotate(416deg);transform:rotate(416deg);display:block}.pace-progress[data-progress="79"] .pace-progress-inner:after{-webkit-transform:rotate(419deg);-ms-transform:rotate(419deg);transform:rotate(419deg);display:block}.pace-progress[data-progress="80"] .pace-progress-inner:after{-webkit-transform:rotate(423deg);-ms-transform:rotate(423deg);transform:rotate(423deg);display:block}.pace-progress[data-progress="81"] .pace-progress-inner:after{-webkit-transform:rotate(427deg);-ms-transform:rotate(427deg);transform:rotate(427deg);display:block}.pace-progress[data-progress="82"] .pace-progress-inner:after{-webkit-transform:rotate(430deg);-ms-transform:rotate(430deg);transform:rotate(430deg);display:block}.pace-progress[data-progress="83"] .pace-progress-inner:after{-webkit-transform:rotate(434deg);-ms-transform:rotate(434deg);transform:rotate(434deg);display:block}.pace-progress[data-progress="84"] .pace-progress-inner:after{-webkit-transform:rotate(437deg);-ms-transform:rotate(437deg);transform:rotate(437deg);display:block}.pace-progress[data-progress="85"] .pace-progress-inner:after{-webkit-transform:rotate(441deg);-ms-transform:rotate(441deg);transform:rotate(441deg);display:block}.pace-progress[data-progress="86"] .pace-progress-inner:after{-webkit-transform:rotate(445deg);-ms-transform:rotate(445deg);transform:rotate(445deg);display:block}.pace-progress[data-progress="87"] .pace-progress-inner:after{-webkit-transform:rotate(448deg);-ms-transform:rotate(448deg);transform:rotate(448deg);display:block}.pace-progress[data-progress="88"] .pace-progress-inner:after{-webkit-transform:rotate(452deg);-ms-transform:rotate(452deg);transform:rotate(452deg);display:block}.pace-progress[data-progress="89"] .pace-progress-inner:after{-webkit-transform:rotate(455deg);-ms-transform:rotate(455deg);transform:rotate(455deg);display:block}.pace-progress[data-progress="90"] .pace-progress-inner:after{-webkit-transform:rotate(459deg);-ms-transform:rotate(459deg);transform:rotate(459deg);display:block}.pace-progress[data-progress="91"] .pace-progress-inner:after{-webkit-transform:rotate(463deg);-ms-transform:rotate(463deg);transform:rotate(463deg);display:block}.pace-progress[data-progress="92"] .pace-progress-inner:after{-webkit-transform:rotate(466deg);-ms-transform:rotate(466deg);transform:rotate(466deg);display:block}.pace-progress[data-progress="93"] .pace-progress-inner:after{-webkit-transform:rotate(470deg);-ms-transform:rotate(470deg);transform:rotate(470deg);display:block}.pace-progress[data-progress="94"] .pace-progress-inner:after{-webkit-transform:rotate(473deg);-ms-transform:rotate(473deg);transform:rotate(473deg);display:block}.pace-progress[data-progress="95"] .pace-progress-inner:after{-webkit-transform:rotate(477deg);-ms-transform:rotate(477deg);transform:rotate(477deg);display:block}.pace-progress[data-progress="96"] .pace-progress-inner:after{-webkit-transform:rotate(481deg);-ms-transform:rotate(481deg);transform:rotate(481deg);display:block}.pace-progress[data-progress="97"] .pace-progress-inner:after{-webkit-transform:rotate(484deg);-ms-transform:rotate(484deg);transform:rotate(484deg);display:block}.pace-progress[data-progress="98"] .pace-progress-inner:after{-webkit-transform:rotate(488deg);-ms-transform:rotate(488deg);transform:rotate(488deg);display:block}.pace-progress[data-progress="99"] .pace-progress-inner:after{-webkit-transform:rotate(491deg);-ms-transform:rotate(491deg);transform:rotate(491deg);display:block}.pace-progress[data-progress="100"] .pace-progress-inner:after{-webkit-transform:rotate(495deg);-ms-transform:rotate(495deg);transform:rotate(495deg);display:block}.pace-progress[data-progress="00"] .pace-progress-inner{-webkit-transform:rotate(0);-ms-transform:rotate(0);transform:rotate(0)}.pace-progress[data-progress="01"] .pace-progress-inner{-webkit-transform:rotate(4deg);-ms-transform:rotate(4deg);transform:rotate(4deg)}.pace-progress[data-progress="02"] .pace-progress-inner{-webkit-transform:rotate(7deg);-ms-transform:rotate(7deg);transform:rotate(7deg)}.pace-progress[data-progress="03"] .pace-progress-inner{-webkit-transform:rotate(11deg);-ms-transform:rotate(11deg);transform:rotate(11deg)}.pace-progress[data-progress="04"] .pace-progress-inner{-webkit-transform:rotate(14deg);-ms-transform:rotate(14deg);transform:rotate(14deg)}.pace-progress[data-progress="05"] .pace-progress-inner{-webkit-transform:rotate(18deg);-ms-transform:rotate(18deg);transform:rotate(18deg)}.pace-progress[data-progress="06"] .pace-progress-inner{-webkit-transform:rotate(22deg);-ms-transform:rotate(22deg);transform:rotate(22deg)}.pace-progress[data-progress="07"] .pace-progress-inner{-webkit-transform:rotate(25deg);-ms-transform:rotate(25deg);transform:rotate(25deg)}.pace-progress[data-progress="08"] .pace-progress-inner{-webkit-transform:rotate(29deg);-ms-transform:rotate(29deg);transform:rotate(29deg)}.pace-progress[data-progress="09"] .pace-progress-inner{-webkit-transform:rotate(32deg);-ms-transform:rotate(32deg);transform:rotate(32deg)}.pace-progress[data-progress="10"] .pace-progress-inner{-webkit-transform:rotate(36deg);-ms-transform:rotate(36deg);transform:rotate(36deg)}.pace-progress[data-progress="11"] .pace-progress-inner{-webkit-transform:rotate(40deg);-ms-transform:rotate(40deg);transform:rotate(40deg)}.pace-progress[data-progress="12"] .pace-progress-inner{-webkit-transform:rotate(43deg);-ms-transform:rotate(43deg);transform:rotate(43deg)}.pace-progress[data-progress="13"] .pace-progress-inner{-webkit-transform:rotate(47deg);-ms-transform:rotate(47deg);transform:rotate(47deg)}.pace-progress[data-progress="14"] .pace-progress-inner{-webkit-transform:rotate(50deg);-ms-transform:rotate(50deg);transform:rotate(50deg)}.pace-progress[data-progress="15"] .pace-progress-inner{-webkit-transform:rotate(54deg);-ms-transform:rotate(54deg);transform:rotate(54deg)}.pace-progress[data-progress="16"] .pace-progress-inner{-webkit-transform:rotate(58deg);-ms-transform:rotate(58deg);transform:rotate(58deg)}.pace-progress[data-progress="17"] .pace-progress-inner{-webkit-transform:rotate(61deg);-ms-transform:rotate(61deg);transform:rotate(61deg)}.pace-progress[data-progress="18"] .pace-progress-inner{-webkit-transform:rotate(65deg);-ms-transform:rotate(65deg);transform:rotate(65deg)}.pace-progress[data-progress="19"] .pace-progress-inner{-webkit-transform:rotate(68deg);-ms-transform:rotate(68deg);transform:rotate(68deg)}.pace-progress[data-progress="20"] .pace-progress-inner{-webkit-transform:rotate(72deg);-ms-transform:rotate(72deg);transform:rotate(72deg)}.pace-progress[data-progress="21"] .pace-progress-inner{-webkit-transform:rotate(76deg);-ms-transform:rotate(76deg);transform:rotate(76deg)}.pace-progress[data-progress="22"] .pace-progress-inner{-webkit-transform:rotate(79deg);-ms-transform:rotate(79deg);transform:rotate(79deg)}.pace-progress[data-progress="23"] .pace-progress-inner{-webkit-transform:rotate(83deg);-ms-transform:rotate(83deg);transform:rotate(83deg)}.pace-progress[data-progress="24"] .pace-progress-inner{-webkit-transform:rotate(86deg);-ms-transform:rotate(86deg);transform:rotate(86deg)}.pace-progress[data-progress="25"] .pace-progress-inner{-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);transform:rotate(90deg)}.pace-progress[data-progress="26"] .pace-progress-inner{-webkit-transform:rotate(94deg);-ms-transform:rotate(94deg);transform:rotate(94deg)}.pace-progress[data-progress="27"] .pace-progress-inner{-webkit-transform:rotate(97deg);-ms-transform:rotate(97deg);transform:rotate(97deg)}.pace-progress[data-progress="28"] .pace-progress-inner{-webkit-transform:rotate(101deg);-ms-transform:rotate(101deg);transform:rotate(101deg)}.pace-progress[data-progress="29"] .pace-progress-inner{-webkit-transform:rotate(104deg);-ms-transform:rotate(104deg);transform:rotate(104deg)}.pace-progress[data-progress="30"] .pace-progress-inner{-webkit-transform:rotate(108deg);-ms-transform:rotate(108deg);transform:rotate(108deg)}.pace-progress[data-progress="31"] .pace-progress-inner{-webkit-transform:rotate(112deg);-ms-transform:rotate(112deg);transform:rotate(112deg)}.pace-progress[data-progress="32"] .pace-progress-inner{-webkit-transform:rotate(115deg);-ms-transform:rotate(115deg);transform:rotate(115deg)}.pace-progress[data-progress="33"] .pace-progress-inner{-webkit-transform:rotate(119deg);-ms-transform:rotate(119deg);transform:rotate(119deg)}.pace-progress[data-progress="34"] .pace-progress-inner{-webkit-transform:rotate(122deg);-ms-transform:rotate(122deg);transform:rotate(122deg)}.pace-progress[data-progress="35"] .pace-progress-inner{-webkit-transform:rotate(126deg);-ms-transform:rotate(126deg);transform:rotate(126deg)}.pace-progress[data-progress="36"] .pace-progress-inner{-webkit-transform:rotate(130deg);-ms-transform:rotate(130deg);transform:rotate(130deg)}.pace-progress[data-progress="37"] .pace-progress-inner{-webkit-transform:rotate(133deg);-ms-transform:rotate(133deg);transform:rotate(133deg)}.pace-progress[data-progress="38"] .pace-progress-inner{-webkit-transform:rotate(137deg);-ms-transform:rotate(137deg);transform:rotate(137deg)}.pace-progress[data-progress="39"] .pace-progress-inner{-webkit-transform:rotate(140deg);-ms-transform:rotate(140deg);transform:rotate(140deg)}.pace-progress[data-progress="40"] .pace-progress-inner{-webkit-transform:rotate(144deg);-ms-transform:rotate(144deg);transform:rotate(144deg)}.pace-progress[data-progress="41"] .pace-progress-inner{-webkit-transform:rotate(148deg);-ms-transform:rotate(148deg);transform:rotate(148deg)}.pace-progress[data-progress="42"] .pace-progress-inner{-webkit-transform:rotate(151deg);-ms-transform:rotate(151deg);transform:rotate(151deg)}.pace-progress[data-progress="43"] .pace-progress-inner{-webkit-transform:rotate(155deg);-ms-transform:rotate(155deg);transform:rotate(155deg)}.pace-progress[data-progress="44"] .pace-progress-inner{-webkit-transform:rotate(158deg);-ms-transform:rotate(158deg);transform:rotate(158deg)}.pace-progress[data-progress="45"] .pace-progress-inner{-webkit-transform:rotate(162deg);-ms-transform:rotate(162deg);transform:rotate(162deg)}.pace-progress[data-progress="46"] .pace-progress-inner{-webkit-transform:rotate(166deg);-ms-transform:rotate(166deg);transform:rotate(166deg)}.pace-progress[data-progress="47"] .pace-progress-inner{-webkit-transform:rotate(169deg);-ms-transform:rotate(169deg);transform:rotate(169deg)}.pace-progress[data-progress="48"] .pace-progress-inner{-webkit-transform:rotate(173deg);-ms-transform:rotate(173deg);transform:rotate(173deg)}.pace-progress[data-progress="49"] .pace-progress-inner{-webkit-transform:rotate(176deg);-ms-transform:rotate(176deg);transform:rotate(176deg)}.pace-progress[data-progress="50"] .pace-progress-inner{-webkit-transform:rotate(180deg);-ms-transform:rotate(180deg);transform:rotate(180deg)}.pace-progress[data-progress="51"] .pace-progress-inner{-webkit-transform:rotate(184deg);-ms-transform:rotate(184deg);transform:rotate(184deg);overflow:visible}.pace-progress[data-progress="52"] .pace-progress-inner{-webkit-transform:rotate(187deg);-ms-transform:rotate(187deg);transform:rotate(187deg);overflow:visible}.pace-progress[data-progress="53"] .pace-progress-inner{-webkit-transform:rotate(191deg);-ms-transform:rotate(191deg);transform:rotate(191deg);overflow:visible}.pace-progress[data-progress="54"] .pace-progress-inner{-webkit-transform:rotate(194deg);-ms-transform:rotate(194deg);transform:rotate(194deg);overflow:visible}.pace-progress[data-progress="55"] .pace-progress-inner{-webkit-transform:rotate(198deg);-ms-transform:rotate(198deg);transform:rotate(198deg);overflow:visible}.pace-progress[data-progress="56"] .pace-progress-inner{-webkit-transform:rotate(202deg);-ms-transform:rotate(202deg);transform:rotate(202deg);overflow:visible}.pace-progress[data-progress="57"] .pace-progress-inner{-webkit-transform:rotate(205deg);-ms-transform:rotate(205deg);transform:rotate(205deg);overflow:visible}.pace-progress[data-progress="58"] .pace-progress-inner{-webkit-transform:rotate(209deg);-ms-transform:rotate(209deg);transform:rotate(209deg);overflow:visible}.pace-progress[data-progress="59"] .pace-progress-inner{-webkit-transform:rotate(212deg);-ms-transform:rotate(212deg);transform:rotate(212deg);overflow:visible}.pace-progress[data-progress="60"] .pace-progress-inner{-webkit-transform:rotate(216deg);-ms-transform:rotate(216deg);transform:rotate(216deg);overflow:visible}.pace-progress[data-progress="61"] .pace-progress-inner{-webkit-transform:rotate(220deg);-ms-transform:rotate(220deg);transform:rotate(220deg);overflow:visible}.pace-progress[data-progress="62"] .pace-progress-inner{-webkit-transform:rotate(223deg);-ms-transform:rotate(223deg);transform:rotate(223deg);overflow:visible}.pace-progress[data-progress="63"] .pace-progress-inner{-webkit-transform:rotate(227deg);-ms-transform:rotate(227deg);transform:rotate(227deg);overflow:visible}.pace-progress[data-progress="64"] .pace-progress-inner{-webkit-transform:rotate(230deg);-ms-transform:rotate(230deg);transform:rotate(230deg);overflow:visible}.pace-progress[data-progress="65"] .pace-progress-inner{-webkit-transform:rotate(234deg);-ms-transform:rotate(234deg);transform:rotate(234deg);overflow:visible}.pace-progress[data-progress="66"] .pace-progress-inner{-webkit-transform:rotate(238deg);-ms-transform:rotate(238deg);transform:rotate(238deg);overflow:visible}.pace-progress[data-progress="67"] .pace-progress-inner{-webkit-transform:rotate(241deg);-ms-transform:rotate(241deg);transform:rotate(241deg);overflow:visible}.pace-progress[data-progress="68"] .pace-progress-inner{-webkit-transform:rotate(245deg);-ms-transform:rotate(245deg);transform:rotate(245deg);overflow:visible}.pace-progress[data-progress="69"] .pace-progress-inner{-webkit-transform:rotate(248deg);-ms-transform:rotate(248deg);transform:rotate(248deg);overflow:visible}.pace-progress[data-progress="70"] .pace-progress-inner{-webkit-transform:rotate(252deg);-ms-transform:rotate(252deg);transform:rotate(252deg);overflow:visible}.pace-progress[data-progress="71"] .pace-progress-inner{-webkit-transform:rotate(256deg);-ms-transform:rotate(256deg);transform:rotate(256deg);overflow:visible}.pace-progress[data-progress="72"] .pace-progress-inner{-webkit-transform:rotate(259deg);-ms-transform:rotate(259deg);transform:rotate(259deg);overflow:visible}.pace-progress[data-progress="73"] .pace-progress-inner{-webkit-transform:rotate(263deg);-ms-transform:rotate(263deg);transform:rotate(263deg);overflow:visible}.pace-progress[data-progress="74"] .pace-progress-inner{-webkit-transform:rotate(266deg);-ms-transform:rotate(266deg);transform:rotate(266deg);overflow:visible}.pace-progress[data-progress="75"] .pace-progress-inner{-webkit-transform:rotate(270deg);-ms-transform:rotate(270deg);transform:rotate(270deg);overflow:visible}.pace-progress[data-progress="76"] .pace-progress-inner{-webkit-transform:rotate(274deg);-ms-transform:rotate(274deg);transform:rotate(274deg);overflow:visible}.pace-progress[data-progress="77"] .pace-progress-inner{-webkit-transform:rotate(277deg);-ms-transform:rotate(277deg);transform:rotate(277deg);overflow:visible}.pace-progress[data-progress="78"] .pace-progress-inner{-webkit-transform:rotate(281deg);-ms-transform:rotate(281deg);transform:rotate(281deg);overflow:visible}.pace-progress[data-progress="79"] .pace-progress-inner{-webkit-transform:rotate(284deg);-ms-transform:rotate(284deg);transform:rotate(284deg);overflow:visible}.pace-progress[data-progress="80"] .pace-progress-inner{-webkit-transform:rotate(288deg);-ms-transform:rotate(288deg);transform:rotate(288deg);overflow:visible}.pace-progress[data-progress="81"] .pace-progress-inner{-webkit-transform:rotate(292deg);-ms-transform:rotate(292deg);transform:rotate(292deg);overflow:visible}.pace-progress[data-progress="82"] .pace-progress-inner{-webkit-transform:rotate(295deg);-ms-transform:rotate(295deg);transform:rotate(295deg);overflow:visible}.pace-progress[data-progress="83"] .pace-progress-inner{-webkit-transform:rotate(299deg);-ms-transform:rotate(299deg);transform:rotate(299deg);overflow:visible}.pace-progress[data-progress="84"] .pace-progress-inner{-webkit-transform:rotate(302deg);-ms-transform:rotate(302deg);transform:rotate(302deg);overflow:visible}.pace-progress[data-progress="85"] .pace-progress-inner{-webkit-transform:rotate(306deg);-ms-transform:rotate(306deg);transform:rotate(306deg);overflow:visible}.pace-progress[data-progress="86"] .pace-progress-inner{-webkit-transform:rotate(310deg);-ms-transform:rotate(310deg);transform:rotate(310deg);overflow:visible}.pace-progress[data-progress="87"] .pace-progress-inner{-webkit-transform:rotate(313deg);-ms-transform:rotate(313deg);transform:rotate(313deg);overflow:visible}.pace-progress[data-progress="88"] .pace-progress-inner{-webkit-transform:rotate(317deg);-ms-transform:rotate(317deg);transform:rotate(317deg);overflow:visible}.pace-progress[data-progress="89"] .pace-progress-inner{-webkit-transform:rotate(320deg);-ms-transform:rotate(320deg);transform:rotate(320deg);overflow:visible}.pace-progress[data-progress="90"] .pace-progress-inner{-webkit-transform:rotate(324deg);-ms-transform:rotate(324deg);transform:rotate(324deg);overflow:visible}.pace-progress[data-progress="91"] .pace-progress-inner{-webkit-transform:rotate(328deg);-ms-transform:rotate(328deg);transform:rotate(328deg);overflow:visible}.pace-progress[data-progress="92"] .pace-progress-inner{-webkit-transform:rotate(331deg);-ms-transform:rotate(331deg);transform:rotate(331deg);overflow:visible}.pace-progress[data-progress="93"] .pace-progress-inner{-webkit-transform:rotate(335deg);-ms-transform:rotate(335deg);transform:rotate(335deg);overflow:visible}.pace-progress[data-progress="94"] .pace-progress-inner{-webkit-transform:rotate(338deg);-ms-transform:rotate(338deg);transform:rotate(338deg);overflow:visible}.pace-progress[data-progress="95"] .pace-progress-inner{-webkit-transform:rotate(342deg);-ms-transform:rotate(342deg);transform:rotate(342deg);overflow:visible}.pace-progress[data-progress="96"] .pace-progress-inner{-webkit-transform:rotate(346deg);-ms-transform:rotate(346deg);transform:rotate(346deg);overflow:visible}.pace-progress[data-progress="97"] .pace-progress-inner{-webkit-transform:rotate(349deg);-ms-transform:rotate(349deg);transform:rotate(349deg);overflow:visible}.pace-progress[data-progress="98"] .pace-progress-inner{-webkit-transform:rotate(353deg);-ms-transform:rotate(353deg);transform:rotate(353deg);overflow:visible}.pace-progress[data-progress="99"] .pace-progress-inner{-webkit-transform:rotate(356deg);-ms-transform:rotate(356deg);transform:rotate(356deg);overflow:visible}.pace-progress[data-progress="100"] .pace-progress-inner{-webkit-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg);overflow:visible}
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/README.html</url>
    <content><![CDATA[<h1 align="center"><a href="https://github.com/HubSpot/pace" target="_blank" rel="noopener">Progress bar</a> for <a href="https://github.com/theme-next" target="_blank" rel="noopener">NexT</a></h1>

<h1 align="center">Installation</h1>

<h2>If you want to use the CDN instead of clone this repo, please jump to the Step 3.</h2>

<h2 align="center">Step 1 &rarr; Go to NexT dir</h2>

<p>Change dir to <strong>NexT</strong> directory. There must be <code>layout</code>, <code>source</code>, <code>languages</code> and other directories:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes/next</span><br><span class="line">$ ls</span><br><span class="line">_config.yml  crowdin.yml  docs  gulpfile.js  languages  layout  LICENSE.md  package.json  README.md  scripts  <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<h2 align="center">Step 2 &rarr; Get module</h2>

<p>Install module to <code>source/lib</code> directory:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pace <span class="built_in">source</span>/lib/pace</span><br></pre></td></tr></table></figure>

<h2 align="center">Step 3 &rarr; Set it up</h2>

<p>Enable module in <strong>NexT</strong> <code>_config.yml</code> file and select your theme:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Themes list:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class="line">  <span class="comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">minimal</span></span><br></pre></td></tr></table></figure>

<p><strong>And, if you wants to use the CDN, then need to set:</strong> (you also need to find your corresponding theme css link in <a href="https://www.jsdelivr.com/package/npm/pace-js?path=themes" target="_blank" rel="noopener">jsdelivr</a>)</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">pace:</span> <span class="string">//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js</span></span><br><span class="line">  <span class="attr">pace_css:</span> <span class="string">//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css</span></span><br></pre></td></tr></table></figure>

<h1 align="center">Update</h1>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes/next/<span class="built_in">source</span>/lib/pace</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
