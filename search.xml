<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1. Two Sum</title>
    <url>/2020/05/30/1-Two-Sum/</url>
    <content><![CDATA[<p>hashmap O(n) time O(n) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            x = target - num</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">return</span> [d[x], i]</span><br><span class="line">            d[num] = i</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            x = target - nums[i]</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">return</span> [d[x], i]</span><br><span class="line">            d[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (m.count(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;m[x], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hm.find(target - nums[i]); <span class="comment">// 为了解决数组中有相同数的问题，在每次插新数之前先进行查找，查找无果之后再插数，这样只需要扫描一遍即可</span></span><br><span class="line">            <span class="keyword">if</span> (it != hm.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;min(it-&gt;second, i), max(it-&gt;second, i)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hm[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
        <tag>Hash table</tag>
      </tags>
  </entry>
  <entry>
    <title>10. Regular Expression Matching</title>
    <url>/2020/05/30/10-Regular-Expression-Matching/</url>
    <content><![CDATA[<p>O(mn) time O(m+n) space<br>只有p[n - 1]为*那种情况才有可能需要向两个方向递归（其他单向递归的时间复杂度不会超过这个），一个方向m层，另外一个方向n层，对于每一层都有可能向另外一个方向递归，所以时间复杂度是O(mn)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">        f = [[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            f[<span class="number">0</span>][i] = (p[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">and</span> f[<span class="number">0</span>][i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">2</span>] <span class="keyword">or</span> (f[i - <span class="number">1</span>][j] <span class="keyword">and</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] <span class="keyword">or</span> p[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] <span class="keyword">and</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> f[m][n]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isMatch(s, s.length(), p, p.length()); <span class="comment">// 从后往前分析</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> m, <span class="keyword">const</span> <span class="built_in">string</span> &amp;p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 两个空串肯定匹配</span></span><br><span class="line">        <span class="keyword">if</span> (m != <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果s不空p空肯定不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> &amp;&amp; n != <span class="number">0</span>) <span class="keyword">return</span> p[n - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; isMatch(s, m, p, n - <span class="number">2</span>); <span class="comment">// 如果s空p不空，则只有可能p是类似a*a*a*这样的</span></span><br><span class="line">        <span class="keyword">if</span> (p[n - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">return</span> (s[m - <span class="number">1</span>] == p[n - <span class="number">2</span>] || p[n - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; isMatch(s, m - <span class="number">1</span>, p, n) || isMatch(s, m, p, n - <span class="number">2</span>); <span class="comment">// 如果p以*结尾，则(1)要不s[m - 1]跟p[n - 2]匹配（包括p[n - 2]是.的情况）并且s[0:m-1)和p[0:n)匹配（这里之所以是p[0:n)不是p[0:n-2)是因为s[0:m-1)未必能跟p[0:n-2)匹配但是有可能跟p[0:n)匹配，比如s是xxxzz，p是xxxz*，xxx跟xxxz不匹配但是xxxz*可以跟xxxz匹配，所以这里要用整个p去尝试匹配s[0:m-1)）(2)要不s[0:m)跟p[0:n - 2)匹配</span></span><br><span class="line">        <span class="keyword">return</span> (s[m - <span class="number">1</span>] == p[n - <span class="number">1</span>] || p[n - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; isMatch(s, m - <span class="number">1</span>, p, n - <span class="number">1</span>); <span class="comment">// 如果p不以*结尾，则s[m - 1]跟p[n - 1]匹配（或者p[n - 1]为.）并且s[0:m-1)跟p[0:n-1)匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp O(mn) time O(mn) space<br>这道题中”a*”的意思是若干个a</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; f(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            f[<span class="number">0</span>][j] = (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &amp;&amp; f[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">2</span>] || f[i - <span class="number">1</span>][j] &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), m = p.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 两个空串肯定匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>]; <span class="comment">// 前一个字符p[j - 2]相当于循环节，所以要继承前前个结果，即循环节之前的匹配结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">// 如果字符相同或者正则字符是.直接继承之前两个串的匹配结果</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>] || (dp[i - <span class="number">1</span>][j] &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>)); <span class="comment">// 因为p[j - 2]是循环节，所以要检查前前个结果dp[i][j - 2]，即循环节之前的匹配结果；另外，如果之前的字符串s[0:i-2]已经和p[0:j-1]匹配，即dp[i - 1][j]为true，那么就要看当前字符是否和正则字符（循环节p[j-2]）匹配；这里一定要考虑清楚逻辑！！用OR是对的，ifelse可能出问题</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>String match</tag>
      </tags>
  </entry>
  <entry>
    <title>1004. Max Consecutive Ones III</title>
    <url>/2020/12/06/1004-Max-Consecutive-Ones-III/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>sliding window<br>find the longest subarray with at most K zeros</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, cnt = <span class="number">0</span>; r &lt; A.size(); ++r) &#123;</span><br><span class="line">            cnt += (A[r] == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (cnt &gt; K) &#123;</span><br><span class="line">                cnt -= (A[l++] == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, r + <span class="number">1</span> - l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, n = A.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[r] == <span class="number">0</span>) --K;</span><br><span class="line">            <span class="keyword">if</span> (K &lt; <span class="number">0</span> &amp;&amp; A[l++] == <span class="number">0</span>) ++K; <span class="comment">// 必须把K &lt; 0放前头，K &lt; 0说明0太多了，需要剔除一些（因为1是不会对K变小做贡献的）直到把K变成非负为止（或者r指针到头了）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(nlogn) time O(1) space<br>bisection + sliding window</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">auto</span> ret = isValid(A, K, m);<span class="comment">//cout&lt;&lt;&quot;m = &quot;&lt;&lt;m&lt;&lt;&quot;, ret = &quot;&lt;&lt;ret&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                lo = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> K, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, cnt = <span class="number">0</span>; r &lt; A.size(); ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[r] == <span class="number">0</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= K &amp;&amp; r - l + <span class="number">1</span> == m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; cnt &gt; K) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[l++] == <span class="number">0</span>) --cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>1060. Missing Element in Sorted Array</title>
    <url>/2020/12/01/1060-Missing-Element-in-Sorted-Array/</url>
    <content><![CDATA[<p>bisection O(logn) time O(1) space<br>在数组中找missing number的『下界』，找下界的好处是最后确定缺哪个数直接计算即可，比找上界省事</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(nums), l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (l + <span class="number">1</span> + r) / <span class="number">2</span>; <span class="comment">// 找下界为了避免死循环要+1</span></span><br><span class="line">            <span class="keyword">if</span> (nums[m] - nums[<span class="number">0</span>] - m &lt; k) &#123; <span class="comment">// (nums[m] - nums[0]) - (m - 0)得到nums[0]和nums[m]中间缺了几个数，如果少于k个说明nums[m]可能是下界</span></span><br><span class="line">                l = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] + l + k; <span class="comment">// 从nums[0]开始出现了l个数缺k个数，即nums[l] + k - (nums[l] - nums[0] - l)，从nums[l]开始数第k - (nums[l] - nums[0] - l)个数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>二分遍历整个数组，找出missing element在数组中的上界<br>对于一个数nums[m]，如果nums[m] - nums[0] - m &gt;= k，则所求的missing element小于nums[m]，nums[m]是一个备选上界，否则肯定大于nums[m]并且nums[m]一定不是一个上界<br>找到上界nums[l]以后，分情况讨论</p>
<ol>
<li>如果nums[l]是一个真上界，则missing element在(nums[l - 1], nums[l])之间，即k - (nums[l - 1] - nums[0] - (l - 1)) = k + nums[0] + l - 1，即从nums[0]开始跳过数组内的l - 1个数后找出第k个缺失的数</li>
<li>如果nums[l]是一个假上界，即数组里所有数都要比所求的missing element小，则应为k - (nums[l] - nums[0] - l) = k + nums[0] + l，即从nums[0]开始跳过数组内的l个数后找出第k个缺失的数</li>
</ol>
<p>综合起来为k + nums[0] + l - isValid(nums, l, k)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isValid(nums, m, k)) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] + k + l - isValid(nums, l, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[m] - nums[<span class="number">0</span>] - m &gt;= k; <span class="comment">// 说明nums[m]比较大，第k个missing的数可以在nums[m]之内，即nums[0], ..., nums[0] + m, ..., nums[m]，所以nums[m] - (nums[0] + m) &gt;= k</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>11. Container With Most Water</title>
    <url>/2020/05/30/11-Container-With-Most-Water/</url>
    <content><![CDATA[<p>two pointers O(n)<br>这道题和maximum square不一样<br>思路和trapping most water类似，都是维护左右两个指针从外往里找短板，当前最大面积更新后，短板必须要更新成更长的板</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        l, r, res = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mn = <span class="built_in">min</span>(height[l], height[r])</span><br><span class="line">            res = <span class="built_in">max</span>(res, mn * (r - l))</span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> height[l] &lt;= mn:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> height[r] &lt;= mn:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mn = min(height[l], height[r]);</span><br><span class="line">            res = max(res, mn * (r - l));</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; height[l] &lt;= mn) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; height[r] &lt;= mn) &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>1197. Minimum Knight Moves</title>
    <url>/2020/12/05/1197-Minimum-Knight-Moves/</url>
    <content><![CDATA[<p>bfs<br>有数学方法 不实际</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKnightMoves</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">abs</span>(x), y = <span class="built_in">abs</span>(y);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">using</span> tdii = tuple&lt;<span class="keyword">double</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;tdii, <span class="built_in">vector</span>&lt;tdii&gt;, greater&lt;tdii&gt;&gt; q;</span><br><span class="line">        q.emplace(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [_, xx, yy] = q.top(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (xx == x &amp;&amp; yy == y) <span class="keyword">return</span> m[x * <span class="number">1000</span> + y];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = xx + dx[i], ny = yy + dy[i], k = nx * <span class="number">1000</span> + ny;</span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">-1</span> || ny &lt; <span class="number">-1</span> || <span class="built_in">abs</span>(nx) + <span class="built_in">abs</span>(ny) &gt; <span class="number">300</span> || m.count(k)) <span class="keyword">continue</span>;</span><br><span class="line">                m[k] = m[xx * <span class="number">1000</span> + yy] + <span class="number">1</span>;</span><br><span class="line">                q.emplace(m[k] + dist(nx, ny, x, y), nx, ny);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>((xx - x) * (xx - x) + (yy - y) * (yy - y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用这个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hashmap for pair</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;a) &#123; <span class="keyword">return</span> hash&lt;<span class="keyword">long</span>&gt;&#123;&#125;(a.first) ^ hash&lt;<span class="keyword">long</span>&gt;&#123;&#125;((<span class="keyword">long</span>)a.second &lt;&lt; <span class="number">32</span>); &#125;;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; m(<span class="number">101</span>, cmp);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKnightMoves</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">abs</span>(x), y = <span class="built_in">abs</span>(y); <span class="comment">// 所有坐标调整为第一象限quadrant</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, dx[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q&#123;&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [xx, yy] = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (xx == x &amp;&amp; yy == y) <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = xx + dx[j], ny = yy + dy[j], k = nx * <span class="number">1000</span> + ny; <span class="comment">// 这里乘1000因为x和y的绝对值都不超过300</span></span><br><span class="line">                    <span class="keyword">if</span> (nx &lt; <span class="number">-1</span> || ny &lt; <span class="number">-1</span> || <span class="built_in">abs</span>(nx) + <span class="built_in">abs</span>(ny) &gt; <span class="number">300</span> || s.count(k)) <span class="keyword">continue</span>; <span class="comment">// 这里检查nx和ny是否小于-1是因为到(1, 1)最少步数必须跨象限先到(2, -1)或者(-1, 2)，其他所有走法都比这个差，实际上从0开始跨象限最多到-1到不了-2即从1到-1因为走日字步长最多为2</span></span><br><span class="line">                    q.emplace(nx, ny);</span><br><span class="line">                    s.insert(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKnightMoves</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">abs</span>(x) * <span class="number">1000</span> + <span class="built_in">abs</span>(y);</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, dx[] = &#123;<span class="number">1000</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">1000</span>, <span class="number">-1000</span>, <span class="number">-2000</span>, <span class="number">-2000</span>, <span class="number">-1000</span>&#125;, dy[] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q&#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (u == t) <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> v = u + dx[j] + dy[j];</span><br><span class="line">                    <span class="keyword">if</span> (v &lt; <span class="number">0</span> || s.count(v)) <span class="keyword">continue</span>;</span><br><span class="line">                    q.emplace(v);</span><br><span class="line">                    s.insert(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Chessboard</tag>
        <tag>Breadth first search</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>12. Integer to Roman</title>
    <url>/2020/05/30/12-Integer-to-Roman/</url>
    <content><![CDATA[<p>O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;MM&#x27;</span>, <span class="string">&#x27;MMM&#x27;</span>]</span><br><span class="line">C = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;CC&#x27;</span>, <span class="string">&#x27;CCC&#x27;</span>, <span class="string">&#x27;CD&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;DC&#x27;</span>, <span class="string">&#x27;DCC&#x27;</span>, <span class="string">&#x27;DCCC&#x27;</span>, <span class="string">&#x27;CM&#x27;</span>]</span><br><span class="line">X = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;XX&#x27;</span>, <span class="string">&#x27;XXX&#x27;</span>, <span class="string">&#x27;XL&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;LX&#x27;</span>, <span class="string">&#x27;LXX&#x27;</span>, <span class="string">&#x27;LXXX&#x27;</span>, <span class="string">&#x27;XC&#x27;</span>]</span><br><span class="line">I = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;II&#x27;</span>, <span class="string">&#x27;III&#x27;</span>, <span class="string">&#x27;IV&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;VI&#x27;</span>, <span class="string">&#x27;VII&#x27;</span>, <span class="string">&#x27;VIII&#x27;</span>, <span class="string">&#x27;IX&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> M[num // <span class="number">1000</span>] + C[num % <span class="number">1000</span> // <span class="number">100</span>] + X[num % <span class="number">100</span> // <span class="number">10</span>] + I[num % <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> M[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MMM&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> C[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DC&quot;</span>, <span class="string">&quot;DCC&quot;</span>, <span class="string">&quot;DCCC&quot;</span>, <span class="string">&quot;CM&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> X[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;XX&quot;</span>, <span class="string">&quot;XXX&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;LX&quot;</span>, <span class="string">&quot;LXX&quot;</span>, <span class="string">&quot;LXXX&quot;</span>, <span class="string">&quot;XC&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> I[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> M[num / <span class="number">1000</span>] + C[num % <span class="number">1000</span> / <span class="number">100</span>] + X[num % <span class="number">100</span> / <span class="number">10</span>] + I[num % <span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Integer</tag>
        <tag>Roman</tag>
      </tags>
  </entry>
  <entry>
    <title>124. Binary Tree Maximum Path Sum</title>
    <url>/2020/11/22/124-Binary-Tree-Maximum-Path-Sum/</url>
    <content><![CDATA[<p>O(n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode *root, <span class="keyword">int</span> &amp;res)</span> </span>&#123; <span class="comment">// 以root结尾的最大和path的最大和</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = max(<span class="number">0</span>, helper(root-&gt;left, res)); <span class="comment">// 如果返回的最大和是负数，则直接用0代替</span></span><br><span class="line">        <span class="keyword">int</span> r = max(<span class="number">0</span>, helper(root-&gt;right, res));</span><br><span class="line">        res = max(res, root-&gt;val + l + r); <span class="comment">// 更新res</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + max(l, r); <span class="comment">// 返回包括root在内的最大路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Postorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>1249. Minimum Remove to Make Valid Parentheses</title>
    <url>/2020/11/22/1249-Minimum-Remove-to-Make-Valid-Parentheses/</url>
    <content><![CDATA[<p>跟<a href="https://leetcode.com/problems/remove-invalid-parentheses/">301. Remove Invalid Parentheses</a>不完全一样<br>跟<a href="https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/">921. Minimum Add to Make Parentheses Valid</a>结合起来看<br>O(n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minRemoveToMakeValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        s = remove(s, <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>); <span class="comment">// 一定要先从后往前删，再从前往后删，因为s要翻转两次</span></span><br><span class="line">        <span class="keyword">return</span> remove(s, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">char</span> lp, <span class="keyword">char</span> rp)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = s.length(), i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            cnt += s[i] == rp ? <span class="number">-1</span> : (s[i] == lp);</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) &#123; <span class="comment">// 说明找到一个无法匹配的『右括号』</span></span><br><span class="line">                cnt = <span class="number">0</span>; <span class="comment">// 重置</span></span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 跳过</span></span><br><span class="line">            &#125;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minRemoveToMakeValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        reverse(begin(s), end(s));</span><br><span class="line">        s = remove(s, <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        reverse(begin(s), end(s));</span><br><span class="line">        <span class="keyword">return</span> remove(s, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">char</span> lp, <span class="keyword">char</span> rp)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            cnt += s[i] == rp ? <span class="number">-1</span> : (s[i] == lp);</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Parentheses</tag>
      </tags>
  </entry>
  <entry>
    <title>125. Valid Palindrome</title>
    <url>/2020/11/22/125-Valid-Palindrome/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = s.length() - <span class="number">1</span>; l &lt; r; ++l, --r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !<span class="built_in">isalnum</span>(s[l])) ++l;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !<span class="built_in">isalnum</span>(s[r])) --r;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[l]) != <span class="built_in">tolower</span>(s[r])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !<span class="built_in">isalnum</span>(s[l])) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !<span class="built_in">isalnum</span>(s[r])) &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[l]) != <span class="built_in">tolower</span>(s[r])) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// uniform case!!</span></span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Palindrome</tag>
      </tags>
  </entry>
  <entry>
    <title>126. Word Ladder II</title>
    <url>/2020/12/13/126-Word-Ladder-II/</url>
    <content><![CDATA[<p>bfs + dfs O(nm) n是单词个数 m是单词平均长度<br>这道题的本质是求单源最短路径，应该使用dijkstra算法，这样可以只记录到每个点最短的那些路径，避免把较长的路径也记录下来<br>dijkstra把从beginWord到其他词（包括endWord）的所有最短路径都找出来（用邻接表）<br>再用dfs把到endWord的所有最短路径打印出来</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; findLadders(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; d; <span class="comment">// 记录源点到每个点的最短距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;u : wordList) &#123;</span><br><span class="line">            d[u] = INT_MAX; <span class="comment">// 初始化源点到每个点的距离都是无穷大</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; next;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q; <span class="comment">// dijkstra算法本来应该使用优先队列，但是这道题里每次入队列的单词到beginWord的转换步数都是大于等于队列内的其他单词的，所以普通队列即可</span></span><br><span class="line">        q.push(beginWord);</span><br><span class="line">        d[beginWord] = <span class="number">0</span>; <span class="comment">// 初始化源点到其自己的距离为0</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (u == endWord) <span class="keyword">break</span>; <span class="comment">// 因为只要步数一样就写入图里，所以相当于按层遍历的，最短的可以达到endWord这一层的所有边都已经写到图里了，所以当查看下一层的时候第一次找到endWord就可以跳出循环了</span></span><br><span class="line">            <span class="keyword">auto</span> v = u;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;c : v) &#123; <span class="comment">// relax</span></span><br><span class="line">                <span class="keyword">auto</span> t = c;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> x = <span class="string">&#x27;a&#x27;</span>; x &lt;= <span class="string">&#x27;z&#x27;</span>; ++x) &#123;</span><br><span class="line">                    c = x;</span><br><span class="line">                    <span class="keyword">if</span> (x == t || d.count(v) == <span class="number">0</span> || d[v] &lt; d[u] + <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// d[v] &lt; d[u] + 1的意思是v已经访问过了且源点到v的距离应该小于等于源点到u的距离，即v在之前已经可以用更少的转换步数得到，则现在通过u转换得到v的步数不是更少的</span></span><br><span class="line">                    <span class="keyword">if</span> (d[v] &gt; d[u] + <span class="number">1</span>) &#123;</span><br><span class="line">                        d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">                        q.push(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                    next[u].push_back(v); <span class="comment">// 这里只要u-&gt;v不会让到v的最短距离变长就记录下来（因为要找『所有』最短距离，即使d[v] == d[u] + 1也要记录下来），另外因为bfs导致永远是较近的点先被放入，所以一定不会出现先加入『长边』再加入『短边』的情况</span></span><br><span class="line">                &#125;</span><br><span class="line">                c = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        v.push_back(beginWord);</span><br><span class="line">        dfs(beginWord, endWord, next, v, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;w, <span class="keyword">const</span> <span class="built_in">string</span> &amp;e, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;next, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (w == e) &#123;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;n : next[w]) &#123;</span><br><span class="line">            v.push_back(n);</span><br><span class="line">            dfs(n, e, next, v, res);</span><br><span class="line">            v.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; findLadders(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : wordList) &#123;</span><br><span class="line">            d[w] = INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">        q.push(beginWord);</span><br><span class="line">        d[beginWord] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (u == endWord) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">auto</span> v = u;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> &amp;c : v) &#123;</span><br><span class="line">                <span class="keyword">char</span> t = c;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> x = <span class="string">&#x27;a&#x27;</span>; x &lt;= <span class="string">&#x27;z&#x27;</span>; ++x) &#123;</span><br><span class="line">                    c = x;</span><br><span class="line">                    <span class="keyword">if</span> (x == t || !d.count(v) || d[v] &lt; d[u] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[v] &gt; d[u] + <span class="number">1</span>) &#123;</span><br><span class="line">                        d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">                        q.push(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                    next[u].push_back(v);</span><br><span class="line">                &#125;</span><br><span class="line">                c = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vs.push_back(beginWord);</span><br><span class="line">        dfs(beginWord, endWord);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;b, <span class="keyword">const</span> <span class="built_in">string</span> &amp;e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == e) &#123;</span><br><span class="line">            res.push_back(vs);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;n : next[b]) &#123;</span><br><span class="line">            vs.push_back(n);</span><br><span class="line">            dfs(n, e);</span><br><span class="line">            vs.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; next;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Depth first search</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>127. Word Ladder</title>
    <url>/2020/12/13/127-Word-Ladder/</url>
    <content><![CDATA[<p>bfs O(nm)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">s</span><span class="params">(begin(wordList), end(wordList))</span></span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q&#123;&#123;beginWord&#125;&#125;;</span><br><span class="line">        s.erase(beginWord); <span class="comment">// 如果beginWord在字典里则将其删去</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> w = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (w == endWord) <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> &amp;c : w) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> t = c;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> x = <span class="string">&#x27;a&#x27;</span>; x &lt;= <span class="string">&#x27;z&#x27;</span>; ++x) &#123;</span><br><span class="line">                        c = x;</span><br><span class="line">                        <span class="keyword">if</span> (!s.count(w) || t == x) <span class="keyword">continue</span>;</span><br><span class="line">                        s.erase(w);</span><br><span class="line">                        q.push(w);</span><br><span class="line">                    &#125;</span><br><span class="line">                    c = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>bfs O(nm) n是单词个数 m是单词平均长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">        q.push(beginWord);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">int</span> n = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> w = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (w == endWord) <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">int</span> m = wordList.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (j &lt; m &amp;&amp; isSimilar(w, wordList[j])) &#123;</span><br><span class="line">                        q.push(wordList[j]);</span><br><span class="line">                        swap(wordList[j], wordList[m - <span class="number">1</span>]);</span><br><span class="line">                        wordList.pop_back();</span><br><span class="line">                        --m;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSimilar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s1.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cnt += (s1[i] != s2[i]);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title>13. Roman to Integer</title>
    <url>/2020/05/31/13-Roman-to-Integer/</url>
    <content><![CDATA[<p>O(n)<br>一般罗马数字都是从大到小排列，如果发现当前数字小于下一个，如IV，则减去当前数字，即-1 + 5 = 4</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;M&#x27;</span>: <span class="number">1000</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> d[s[i - <span class="number">1</span>]] &lt; d[s[i]]:</span><br><span class="line">                res -= d[s[i - <span class="number">1</span>]] * <span class="number">2</span></span><br><span class="line">            res += d[s[i]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;M&#x27;</span>: <span class="number">1000</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        res, n = <span class="number">0</span>, <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &lt; n <span class="keyword">and</span> d[s[i]] &lt; d[s[i + <span class="number">1</span>]]:</span><br><span class="line">                res -= d[s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += d[s[i]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; m[s[i]] &lt; m[s[i + <span class="number">1</span>]]) &#123;</span><br><span class="line">                res -= m[s[i]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += m[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; m[s[i]] &gt; m[s[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">                res -= m[s[i - <span class="number">1</span>]] * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += m[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Integer</tag>
        <tag>Roman</tag>
      </tags>
  </entry>
  <entry>
    <title>133. Clone Graph</title>
    <url>/2020/11/29/133-Clone-Graph/</url>
    <content><![CDATA[<p>DFS O(n) time O(n) space<br>这道题一定要preorder先cache再递归，因为有可能存在环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span> (nodes.count(node)) <span class="keyword">return</span> nodes[node];</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="keyword">new</span> Node;</span><br><span class="line">        nodes[node] = res; <span class="comment">// 一定要先cache！！</span></span><br><span class="line">        res-&gt;val = node-&gt;val;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : node-&gt;neighbors) &#123;</span><br><span class="line">            res-&gt;neighbors.push_back(cloneGraph(n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node *, Node *&gt; nodes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>BFS</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node *, Node *&gt; nodes&#123;&#123;node, <span class="keyword">new</span> Node(node-&gt;val, &#123;&#125;)&#125;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node *&gt; q&#123;&#123;node&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> x = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> n : x-&gt;neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!nodes.count(n)) &#123;</span><br><span class="line">                    nodes[n] = <span class="keyword">new</span> Node(n-&gt;val, &#123;&#125;);</span><br><span class="line">                    q.push(n);</span><br><span class="line">                &#125;</span><br><span class="line">                nodes[x]-&gt;neighbors.push_back(nodes[n]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes[node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Depth first search</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>138. Copy List with Random Pointer</title>
    <url>/2020/12/04/138-Copy-List-with-Random-Pointer/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>1-&gt;2-&gt;3-&gt;null变成1-&gt;1’-&gt;2-&gt;2’-&gt;3-&gt;3’-&gt;null<br>新节点的random = 老节点的random的next，即将老节点和老节点的random的关系赋给新节点和新节点的random<br>将新老节点分开即可<br>分三步：</p>
<ol>
<li>copy next</li>
<li>redirect random</li>
<li>split</li>
</ol>
<p>切记2跟3不能混做，因为random可能往回指</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _next, Node* _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next) &#123;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> Node(p-&gt;val, p-&gt;next, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next) &#123;</span><br><span class="line">            p-&gt;next-&gt;random = p-&gt;random ? p-&gt;random-&gt;next : <span class="literal">nullptr</span>; <span class="comment">// 一定要注意判空！！</span></span><br><span class="line">        &#125;</span><br><span class="line">        Node dummy_head(-1, nullptr, nullptr), *tail = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            tail-&gt;next = p-&gt;next;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            p-&gt;next = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> n = <span class="keyword">new</span> RandomListNode(p-&gt;label);</span><br><span class="line">            n-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next) &#123;</span><br><span class="line">            p-&gt;next-&gt;random = p-&gt;random ? p-&gt;random-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        RandomListNode dummy_head(0), *tail = &amp;dummy_head, *p = head;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            tail-&gt;next = p-&gt;next;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            p-&gt;next = tail-&gt;next;</span><br><span class="line">            p = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> curr = head; curr; curr = curr-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = <span class="keyword">new</span> RandomListNode(curr-&gt;label);</span><br><span class="line">            node-&gt;next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = node;</span><br><span class="line">            curr = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> curr = head; curr; curr = curr-&gt;next-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;random) &#123;</span><br><span class="line">                curr-&gt;next-&gt;random = curr-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">RandomListNode <span class="title">dummy_head</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy_head.next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> curr = head, succ = &amp;dummy_head; curr; curr = curr-&gt;next) &#123;</span><br><span class="line">            succ-&gt;next = curr-&gt;next;</span><br><span class="line">            succ = succ-&gt;next;</span><br><span class="line">            curr-&gt;next = succ-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>hashmap O(n) time O(n) space 先复制，再连</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;RandomListNode *, RandomListNode *&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            m[p] = <span class="keyword">new</span> RandomListNode(p-&gt;label);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            m[p]-&gt;next = p-&gt;next ? m[p-&gt;next] : <span class="literal">nullptr</span>;</span><br><span class="line">            m[p]-&gt;random = p-&gt;random ? m[p-&gt;random] : <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head ? m[head] : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;RandomListNode *, RandomListNode *&gt; hm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node = head; node; node = node-&gt;next) &#123;</span><br><span class="line">            hm[node] = <span class="keyword">new</span> RandomListNode(node-&gt;label);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : hm) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.first-&gt;next) hm[p.first]-&gt;next = hm[p.first-&gt;next];</span><br><span class="line">            <span class="keyword">if</span> (p.first-&gt;random) hm[p.first]-&gt;random = hm[p.first-&gt;random];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hm[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>139. Word Break</title>
    <url>/2020/11/30/139-Word-Break/</url>
    <content><![CDATA[<p>dp dfs + memo top-down<br>这个题应该要注意到可能会有大量重复，所以一定可以用memo优化！！所以肯定是一个dp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : wordDict) &#123;</span><br><span class="line">            table.insert(string_view&#123;w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(string_view&#123;s&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(string_view sv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sv.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (m.count(sv)) <span class="keyword">return</span> m[sv];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = size(sv), i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table.count(sv.substr(<span class="number">0</span>, i)) &amp;&amp; dfs(sv.substr(i))) <span class="keyword">return</span> m[sv] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[sv] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;string_view&gt; table;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;string_view, <span class="keyword">bool</span>&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        ws = <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;(wordDict.begin(), wordDict.end());</span><br><span class="line">        <span class="keyword">return</span> dfs(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (m.count(s)) <span class="keyword">return</span> m[s];</span><br><span class="line">        <span class="built_in">string</span> prefix;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            prefix += s[i];</span><br><span class="line">            <span class="keyword">if</span> (ws.count(prefix) &amp;&amp; dfs(s.substr(i + <span class="number">1</span>))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[s] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; m;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; ws;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类似palindrom partition bottom-up<br>划分型dp O(s.length<sup>3</sup>) m是单词平均长度<br>f[i]表示前i个字母组成的字符串<br>最后一步是f[0]到f[n-1]都已经知道了是否能break，遍历一遍看哪种break可以让f[n]为true<br>所以转移方程是遍历0到n，分别计算每一种划分f[0]到f[n]<br>f[i] = (f[j] 并且字典里能找到s[j:i] where 0 &lt;= j &lt; i)，即前j个字符和前i个字符之间是s[j:i]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">dict</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>; <span class="comment">// 用一个hashset存单词方便查找</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// 表示前n个字母是否符合要求，注意f[0]一定要为true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i] = f[j] &amp;&amp; (dict.count(s.substr(j, i - j)) &gt; <span class="number">0</span>)) <span class="keyword">break</span>; <span class="comment">// 注意及时break否则就白找了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用这个<br>string_view把复杂度降到O(s.length<sup>2</sup>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;string_view&gt; dict;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : wordDict) &#123;</span><br><span class="line">            dict.insert(string_view&#123;w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        string_view sv&#123;s&#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = size(sv);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i] = f[j] &amp;&amp; (dict.count(sv.substr(j, i - j)) &gt; <span class="number">0</span>)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">dict</span><span class="params">(begin(wordDict), end(wordDict))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i] = (f[j] &amp;&amp; dict.count(s.substr(j, i - j)))) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外一种方法<br>O(s.length * wordDict.size * word.length) time<br>如果wordDict较小且word.length较短，则整体复杂度比常规dp要小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : wordDict) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i] &amp;&amp; s.substr(i, min(n, w.length())) == w) &#123;</span><br><span class="line">                    f[i + w.length()] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>14. Longest Common Prefix</title>
    <url>/2020/05/31/14-Longest-Common-Prefix/</url>
    <content><![CDATA[<p>O(mn) time<br>vertical scan</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: List[<span class="built_in">str</span>]</span>) -&gt; str:</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">zip</span>(*strs):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(x)) != <span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">            res += x[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: List[<span class="built_in">str</span>]</span>) -&gt; str:</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">zip</span>(*strs):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">all</span>(c == x[<span class="number">0</span>] <span class="keyword">for</span> c <span class="keyword">in</span> x):</span><br><span class="line">                res += x[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>horizontal scan<br>循环依次检查即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: List[<span class="built_in">str</span>]</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs: <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        res = strs[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(strs)):</span><br><span class="line">            res = self.resolve(res, strs[i])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">resolve</span>(<span class="params">self, A, B</span>):</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(<span class="built_in">len</span>(A), <span class="built_in">len</span>(B))):</span><br><span class="line">            <span class="keyword">if</span> A[i] != B[i]: <span class="keyword">break</span></span><br><span class="line">            res += A[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>trie</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.children = &#123;&#125;</span><br><span class="line">        self.is_end = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> p.children:</span><br><span class="line">                p.children[c] = TrieNode()</span><br><span class="line">            p = p.children[c]</span><br><span class="line">        p.is_end = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;first approach&#x27;&#x27;&#x27;</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(p.children) == <span class="number">1</span>:</span><br><span class="line">            k, v = <span class="built_in">list</span>(p.children.items())[<span class="number">0</span>]</span><br><span class="line">            res += k</span><br><span class="line">            p = v</span><br><span class="line">            <span class="keyword">if</span> p.is_end: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search1</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;second approach&#x27;&#x27;&#x27;</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(p.children) == <span class="number">1</span>:</span><br><span class="line">            res += <span class="built_in">list</span>(p.children.keys())[<span class="number">0</span>]</span><br><span class="line">            p = <span class="built_in">list</span>(p.children.values())[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> p.is_end: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search2</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;third approach&#x27;&#x27;&#x27;</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(p.children) == <span class="number">1</span>:</span><br><span class="line">            res += <span class="built_in">next</span>(<span class="built_in">iter</span>(p.children))</span><br><span class="line">            p = <span class="built_in">next</span>(<span class="built_in">iter</span>(p.children.values()))</span><br><span class="line">            <span class="keyword">if</span> p.is_end: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: List[<span class="built_in">str</span>]</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">            self.add(s)</span><br><span class="line">        <span class="keyword">return</span> self.search()</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.empty()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n = strs.size();</span><br><span class="line">        <span class="built_in">string</span> res = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n &amp;&amp; !res.empty(); ++i) &#123;</span><br><span class="line">            res = helper(res, strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;p, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = min(p.length(), s.length());</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; p[i] == s[i]; ++i) &#123;</span><br><span class="line">            res += p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>trie</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode*&gt; children;</span><br><span class="line">        <span class="keyword">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    TrieNode *root = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : strs) &#123;</span><br><span class="line">            add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !p-&gt;isEnd &amp;&amp; p-&gt;children.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;&amp;[c, n] = *begin(p-&gt;children);</span><br><span class="line">            res += c;</span><br><span class="line">            p = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children.count(c)) &#123;</span><br><span class="line">                p-&gt;children[c] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(mnlogn) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.empty()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        sort(begin(strs), end(strs));</span><br><span class="line">        <span class="keyword">int</span> n = min(strs.front().length(), strs.back().length());</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; strs.front()[i] == strs.back()[i]; ++i) &#123;</span><br><span class="line">            res += strs.front()[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>140. Word Break II</title>
    <url>/2020/12/02/140-Word-Break-II/</url>
    <content><![CDATA[<p>记忆化搜索 memo+dfs O(n^3)<br>这道题不需要用trie，太麻烦！<br>因为字符串没法简单的做backtracking所以采用后缀式搜索来避免<br>cache的时候用下标做key即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">d</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, <span class="number">0</span>, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> b, <span class="keyword">const</span> <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.count(b)) <span class="keyword">return</span> cache[b];</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (b == n) <span class="keyword">return</span> &#123;<span class="string">&quot;&quot;</span>&#125;; <span class="comment">// 切记要返回一个空串不能是空集！！</span></span><br><span class="line">        <span class="built_in">string</span> w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; n; ++i) &#123;</span><br><span class="line">            w += s[i];</span><br><span class="line">            <span class="keyword">if</span> (d.count(w)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;suffix : dfs(s, i + <span class="number">1</span>, d)) &#123;</span><br><span class="line">                    cache[b].push_back(suffix.empty() ? w : w + <span class="string">&#x27; &#x27;</span> + suffix); <span class="comment">// 注意suffix有可能是空串！！</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[b];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; cache;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Postorder traversal</tag>
        <tag>String</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>1428. Leftmost Column with at Least a One</title>
    <url>/2020/11/22/1428-Leftmost-Column-with-at-Least-a-One/</url>
    <content><![CDATA[<p>从右上往左下方向找边缘 O(m+n) time O(1) space<br>复杂度要不是m要不是n，最多是m+n</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the BinaryMatrix&#x27;s API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class BinaryMatrix &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     int get(int row, int col);</span></span><br><span class="line"><span class="comment"> *     vector&lt;int&gt; dimensions();</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leftMostColumnWithOne</span><span class="params">(BinaryMatrix &amp;binaryMatrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;dim = binaryMatrix.dimensions();</span><br><span class="line">        <span class="keyword">int</span> m = dim[<span class="number">0</span>], n = dim[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>, r = <span class="number">0</span>, c = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; m &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (binaryMatrix.get(r, c)) &#123;</span><br><span class="line">                res = c--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the BinaryMatrix&#x27;s API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class BinaryMatrix &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     int get(int row, int col);</span></span><br><span class="line"><span class="comment"> *     vector&lt;int&gt; dimensions();</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leftMostColumnWithOne</span><span class="params">(BinaryMatrix &amp;binaryMatrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;dim = binaryMatrix.dimensions();</span><br><span class="line">        <span class="keyword">int</span> m = dim[<span class="number">0</span>], n = dim[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = n, r = <span class="number">0</span>, c = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; m &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (binaryMatrix.get(r, c)) &#123;</span><br><span class="line">                res = min(res, c);</span><br><span class="line">                --c;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == n ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>146. LRU Cache</title>
    <url>/2020/12/05/146-LRU-Cache/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) : capacity(capacity) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.count(key)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = cache[key];</span><br><span class="line">        history.splice(begin(history), history, it);</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.count(key)) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = cache[key];</span><br><span class="line">            history.splice(begin(history), history, it);</span><br><span class="line">            it-&gt;second = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (capacity == size(cache)) &#123;</span><br><span class="line">            <span class="keyword">auto</span> key_to_delete = history.back().first;</span><br><span class="line">            history.pop_back();</span><br><span class="line">            cache.erase(key_to_delete);</span><br><span class="line">        &#125;</span><br><span class="line">        cache[key] = history.emplace(begin(history), key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; cache;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; history;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) : m_capacity(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">it</span><span class="params">(cache.find(key))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (it == cache.end()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        history.splice(history.begin(), history, it-&gt;second); <span class="comment">// 把找到的键值对放到链表首表明是最新被访问的</span></span><br><span class="line">        <span class="keyword">return</span> it-&gt;second-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">it</span><span class="params">(cache.find(key))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (it != cache.end()) &#123;</span><br><span class="line">            history.splice(history.begin(), history, it-&gt;second);</span><br><span class="line">            it-&gt;second-&gt;second = value;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// cache不需要增加新的键值对，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cache.size() == m_capacity) &#123; <span class="comment">// 一定要先删后加！！！</span></span><br><span class="line">            <span class="keyword">auto</span> key_to_be_deleted = history.back().first;</span><br><span class="line">            history.pop_back(); <span class="comment">// 弹出最近最少被访问的键值对</span></span><br><span class="line">            cache.erase(key_to_be_deleted);</span><br><span class="line">        &#125;</span><br><span class="line">        history.emplace_front(key, value); <span class="comment">// 把最新的键值对插入链表首</span></span><br><span class="line">        cache[key] = history.begin();</span><br><span class="line">        <span class="comment">// cache[key] = history.insert(begin(history), &#123;key, value&#125;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;::iterator&gt; cache;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; history;</span><br><span class="line">    <span class="keyword">size_t</span> m_capacity;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Cache</tag>
        <tag>Data structure design</tag>
      </tags>
  </entry>
  <entry>
    <title>1498. Number of Subsequences That Satisfy the Given Sum Condition</title>
    <url>/2020/12/06/1498-Number-of-Subsequences-That-Satisfy-the-Given-Sum-Condition/</url>
    <content><![CDATA[<p>two pointer O(nlogn) time O(n) space<br>这道题找的是subsequence不是subarray！！！<br>举例nums = [5,2,4,1,7,6,8], target = 11<br>对于1来说因为最大的数是8使得两数之和小于target11 所以除了自身必须要在subsequence里 其他任何数（包括8）都可在可不在所选的subsequence里 所以这样的subsequence共有2<sup>6</sup>个<br>对于5来说 除了7和8不能选 其他不小于5的数都可选 这样的数只有6一个 所以这样的subsequence共有2个<br>所以这道题的答案跟每个数的原始位置没有任何关系！！！直接排序即可！！！然后按照two sum去做</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(begin(nums), end(nums));</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, n = nums.size(), r = n - <span class="number">1</span>, M = <span class="number">1e9</span> + <span class="number">7</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pow2</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            pow2[i] = (pow2[i - <span class="number">1</span>] * <span class="number">2</span>) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] + nums[r] &lt;= target) &#123;</span><br><span class="line">                res = (res + pow2[r - l++]) % M;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>1499. Max Value of Equation</title>
    <url>/2020/12/01/1499-Max-Value-of-Equation/</url>
    <content><![CDATA[<p>deque O(n) time O(n) space<br>先把equation拆成后边（x+y）和前边（x-y）之差，即(x<sub>j</sub> + y<sub>j</sub>) - (x<sub>i</sub> - y<sub>i</sub>)，对于每个(x<sub>j</sub> + y<sub>j</sub>)只需要知道前边最小的(x<sub>i</sub> - y<sub>i</sub>)即可，又因为有一个限制条件|x<sub>i</sub> - x<sub>j</sub>| &lt;= k，说明需要用sliding window，参考<a href="https://leetcode.com/problems/sliding-window-maximum/">239. Sliding Window Maximum</a>用deque维护一个升序，每次先把不符合限制条件|x<sub>i</sub> - x<sub>j</sub>| &lt;= k的i从前边剔除，然后计算结果，再插入j并在尾部剔除较大的不符合要求的下标以保持升序<br>另外要注意如果k过小，有可能没有结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxValueOfEquation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = size(points), i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty() &amp;&amp; points[i][<span class="number">0</span>] - points[q.front()][<span class="number">0</span>] &gt; k) &#123;</span><br><span class="line">                q.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!q.empty()) &#123;</span><br><span class="line">                res = max(res, points[i][<span class="number">0</span>] + points[i][<span class="number">1</span>] - (points[q.front()][<span class="number">0</span>] - points[q.front()][<span class="number">1</span>])); <span class="comment">// 注意这道题一定要先计算再push新数，因为i &lt; j</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty() &amp;&amp; points[q.back()][<span class="number">0</span>] - points[q.back()][<span class="number">1</span>] &gt;= points[i][<span class="number">0</span>] - points[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                q.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            q.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
        <tag>Deque</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 3Sum</title>
    <url>/2020/05/31/15-3Sum/</url>
    <content><![CDATA[<p>two pointers O(n<sup>2</sup>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i - <span class="number">1</span>] == nums[i]: <span class="keyword">continue</span></span><br><span class="line">            t = -nums[i]</span><br><span class="line">            l, r = i + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                s = nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> s == t:</span><br><span class="line">                    res.append([nums[i], nums[l], nums[r]])</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l - <span class="number">1</span>] == nums[l]: l += <span class="number">1</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]: r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &lt; t:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l - <span class="number">1</span>] == nums[l]: l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]: r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">long</span> t = -(<span class="keyword">long</span>)nums[i];</span><br><span class="line">            <span class="keyword">int</span> l = i + <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">long</span> s = (<span class="keyword">long</span>)nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">                    res.push_back(&#123;nums[i], nums[l], nums[r]&#125;);</span><br><span class="line">                    <span class="keyword">do</span> &#123; ++l; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">do</span> &#123; --r; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; t) &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123; ++l; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123; --r; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>1570. Dot Product of Two Sparse Vectors</title>
    <url>/2020/11/22/1570-Dot-Product-of-Two-Sparse-Vectors/</url>
    <content><![CDATA[<p>拉链法 或者 加 二分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseVector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    SparseVector(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]) &#123;</span><br><span class="line">                v.emplace_back(i, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIdx</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v[i].first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v[i].second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> e, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::lower_bound(begin(v) + b, begin(v) + e, idx, [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p, <span class="keyword">int</span> idx)&#123; <span class="keyword">return</span> p.first &lt; idx; &#125;) - begin(v); <span class="comment">// 这个lambda相当于实现一个less，即找到第一个不小于的为止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the dotProduct of two sparse vectors</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dotProduct</span><span class="params">(SparseVector&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, m = getDim(), n = vec.getDim(); i &lt; m &amp;&amp; j &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">int</span> ii = getIdx(i), ij = vec.getIdx(j);</span><br><span class="line">            <span class="keyword">if</span> (ii == ij) &#123;</span><br><span class="line">                res += getNum(i++) * vec.getNum(j++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ii &lt; ij) &#123;</span><br><span class="line">                i = lower_bound(i + <span class="number">1</span>, m, ij);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = vec.lower_bound(j + <span class="number">1</span>, n, ii);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your SparseVector object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// SparseVector v1(nums1);</span></span><br><span class="line"><span class="comment">// SparseVector v2(nums2);</span></span><br><span class="line"><span class="comment">// int ans = v1.dotProduct(v2);</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
        <tag>Merging</tag>
      </tags>
  </entry>
  <entry>
    <title>158. Read N Characters Given Read4 II - Call multiple times</title>
    <url>/2020/11/22/158-Read-N-Characters-Given-Read4-II-Call-multiple-times/</url>
    <content><![CDATA[<p>跟<a href="https://leetcode.com/problems/read-n-characters-given-read4/">157. Read N Characters Given Read4</a>的区别是前一次read过的剩余字符下次read的时候直接写进buf</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The read4 API is defined in the parent class Reader4.</span></span><br><span class="line"><span class="comment"> *     int read4(char *buf4);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param buf Destination buffer</span></span><br><span class="line"><span class="comment">     * @param n   Number of characters to read</span></span><br><span class="line"><span class="comment">     * @return    The number of actual characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (b != e &amp;&amp; cnt &lt; n) &#123;</span><br><span class="line">            buf[cnt++] = buf4[b++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n) <span class="keyword">return</span> cnt;</span><br><span class="line">        b = <span class="number">0</span>;</span><br><span class="line">        e = read4(buf4);</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="number">0</span>) <span class="keyword">return</span> cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt + read(buf + cnt, n - cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf4[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of the read4 API.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read4</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param buf Destination buffer</span></span><br><span class="line"><span class="comment">     * @param n   Number of characters to read</span></span><br><span class="line"><span class="comment">     * @return    The number of actual characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; e &amp;&amp; cnt &lt; n) &#123; <span class="comment">// 在全局buffer的边界之内尽可能多的读字符</span></span><br><span class="line">            buf[cnt++] = t[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == e) i = e = <span class="number">0</span>; <span class="comment">// 如果全局buffer里到边界的所有字符都被读走，则重置下标和边界</span></span><br><span class="line">        <span class="keyword">if</span> (cnt == n) <span class="keyword">return</span> cnt; <span class="comment">// 如果已经读够了需要的字符，则返回</span></span><br><span class="line">        e = read4(t);</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="number">0</span>) <span class="keyword">return</span> cnt; <span class="comment">// 如果还需要继续读字符但是读出的字符数为0</span></span><br><span class="line">        <span class="keyword">return</span> cnt + read(buf + cnt, n - cnt); <span class="comment">// 如果还需要继续读字符，递归</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, e = <span class="number">0</span>; <span class="comment">// 维护全局buffer的下标和右边界（不一定为4）</span></span><br><span class="line">    <span class="keyword">char</span> t[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>16. 3Sum Closest</title>
    <url>/2020/05/31/16-3Sum-Closest/</url>
    <content><![CDATA[<p>two pointers O(n<sup>2</sup>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n, d, res = <span class="built_in">len</span>(nums), <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i - <span class="number">1</span>] == nums[i]: <span class="keyword">continue</span></span><br><span class="line">            l, r, t = i + <span class="number">1</span>, n - <span class="number">1</span>, target - nums[i]</span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                s = nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(s - t) &lt; d:</span><br><span class="line">                    d, res = <span class="built_in">abs</span>(s - t), s + nums[i]</span><br><span class="line">                <span class="keyword">if</span> s &lt; t:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l - <span class="number">1</span>] == nums[l]:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &gt; t:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> diff = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i + <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(sum - t) &lt; diff) &#123;</span><br><span class="line">                    diff = <span class="built_in">abs</span>(sum - t);</span><br><span class="line">                    res = nums[i] + sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum == t) &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; t) &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123; ++l; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123; --r; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">do</span> &#123; ++i; &#125; <span class="keyword">while</span> (i &lt; n &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>163. Missing Ranges</title>
    <url>/2020/12/06/163-Missing-Ranges/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findMissingRanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        nums.push_back(upper); <span class="comment">// padding好处理，而且nums可能是空的</span></span><br><span class="line">        <span class="keyword">long</span> l = lower;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = lower_bound(begin(nums), end(nums), lower);</span><br><span class="line">            it != upper_bound(begin(nums), end(nums), upper);</span><br><span class="line">            ++it) &#123;</span><br><span class="line">            <span class="keyword">long</span> u = it == prev(end(nums)) ? *it : *it - <span class="number">1L</span>; <span class="comment">// 注意integer overflow，比如[-2147483648, 0]</span></span><br><span class="line">            <span class="keyword">if</span> (l == u) &#123;</span><br><span class="line">                res.push_back(to_string(l));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &lt; u) &#123;</span><br><span class="line">                res.push_back(to_string(l) + <span class="string">&quot;-&gt;&quot;</span> + to_string(u));</span><br><span class="line">            &#125;</span><br><span class="line">            l = *it + <span class="number">1L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findMissingRanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(nums);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        nums.push_back(upper); <span class="comment">// padding好处理，而且nums可能是空的</span></span><br><span class="line">        <span class="keyword">long</span> l = lower;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">long</span> u = i == n ? nums[i] : ((<span class="keyword">long</span>)nums[i] - <span class="number">1</span>); <span class="comment">// 注意integer overflow，比如[-2147483648, 0]</span></span><br><span class="line">            <span class="keyword">if</span> (l == u) &#123;</span><br><span class="line">                res.push_back(to_string(l));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &lt; u) &#123;</span><br><span class="line">                res.push_back(to_string(l) + <span class="string">&quot;-&gt;&quot;</span> + to_string(u));</span><br><span class="line">            &#125;</span><br><span class="line">            l = (<span class="keyword">long</span>)nums[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n) time O(n) space<br>先按照<a href="https://leetcode.com/problems/summary-ranges/">228. Summary Ranges</a>总结现有区间，然后再找出missing区间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findMissingRanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">long</span>, <span class="keyword">long</span>&gt;&gt; v;</span><br><span class="line">        v.emplace_back(LONG_MIN, lower - <span class="number">1L</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">auto</span> add = [&amp;v](<span class="keyword">long</span> x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v.back().second + <span class="number">1</span> &lt; x) &#123;</span><br><span class="line">                v.emplace_back(x, x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v.back().second = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = lower_bound(begin(nums), end(nums), lower);</span><br><span class="line">            it != upper_bound(begin(nums), end(nums), upper);</span><br><span class="line">            ++it) &#123;</span><br><span class="line">            add(*it);</span><br><span class="line">        &#125;</span><br><span class="line">        add(upper + <span class="number">1L</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size(v); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i - <span class="number">1</span>].second + <span class="number">2</span> &lt; v[i].first) &#123;</span><br><span class="line">                res.push_back(to_string(v[i - <span class="number">1</span>].second + <span class="number">1</span>) + <span class="string">&quot;-&gt;&quot;</span> + to_string(v[i].first - <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(to_string(v[i].first - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Ranges</tag>
      </tags>
  </entry>
  <entry>
    <title>1662. Check If Two String Arrays are Equivalent</title>
    <url>/2020/12/08/1662-Check-If-Two-String-Arrays-are-Equivalent/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">arrayStringsAreEqual</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; word1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">0</span>, i2 = <span class="number">0</span>, m = size(word1), n = size(word2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j1 = <span class="number">0</span>, j2 = <span class="number">0</span>; i1 &lt; m &amp;&amp; i2 &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[i1][j1] != word2[i2][j2]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (++j1 == size(word1[i1])) &#123;</span><br><span class="line">                ++i1;</span><br><span class="line">                j1 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++j2 == size(word2[i2])) &#123;</span><br><span class="line">                ++i2;</span><br><span class="line">                j2 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i1 == m &amp;&amp; i2 == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>1674. Minimum Moves to Make Array Complementary</title>
    <url>/2020/12/12/1674-Minimum-Moves-to-Make-Array-Complementary/</url>
    <content><![CDATA[<p>O(n+limit) time O(limit) space<br>这道题首先要仔细观察limit的取值范围，发现跟n是一样的，说明limit可能会影响复杂度，同时还要注意nums每个数都不超过limit，所以可以先从暴力解下手，对于每一个pair，sum变成[2, limit*2]之间任何一个数的最小步数是定值：</p>
<ul>
<li>[2, min(a, b)]是2个数都要减小</li>
<li>[min(a, b) + 1, a + b - 1]是较大的1个数要减小</li>
<li>[a + b, a + b]是两个数都不用动</li>
<li>[a + b + 1, max(a, b) + limit]是较小的1个数要变大</li>
<li>[max(a, b) + limit + 1, limit * 2]是2个数都要变大</li>
</ul>
<p>暴力解需要对每一个pair都计算变成每个可能值的变化步数，复杂度过高，通过观察可以发现从2到limit*2一共只有5种可能且变化非常规律分成了5段，对应每一段的变化数是一样的，我们要做的就是把所有pair的不同变化通过某种方式累计起来，这个时候可以想到扫描线，但是单纯的扫描实际变化步数非常不方便，一个trick是利用presum来统计相邻两段区间变化步数的delta，这样就不需要维护完整的实际变化步数，可以很方便的累计到一个数组里，然后利用扫描线即可快速得到完整的累计实际变化步数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(limit * <span class="number">2</span> + <span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> n = size(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i * <span class="number">2</span> &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = nums[i], b = nums[n - <span class="number">1</span> - i];</span><br><span class="line">            f[<span class="number">2</span>] += <span class="number">2</span>;</span><br><span class="line">            --f[min(a, b) + <span class="number">1</span>];</span><br><span class="line">            --f[a + b];</span><br><span class="line">            ++f[a + b + <span class="number">1</span>];</span><br><span class="line">            ++f[max(a, b) + limit + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = n, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= limit * <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            res = min(res, cnt += f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sweep line</tag>
        <tag>Prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>17. Letter Combinations of a Phone Number</title>
    <url>/2020/05/31/17-Letter-Combinations-of-a-Phone-Number/</url>
    <content><![CDATA[<p>iterative O(3<sup>n</sup>) time</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>, <span class="string">&#x27;mno&#x27;</span>, <span class="string">&#x27;pqrs&#x27;</span>, <span class="string">&#x27;tuv&#x27;</span>, <span class="string">&#x27;wxyz&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools <span class="keyword">as</span> it</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: <span class="keyword">return</span> []</span><br><span class="line">        chars = [m[<span class="built_in">int</span>(d)] <span class="keyword">for</span> d <span class="keyword">in</span> digits]</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;&#x27;</span>.join(p) <span class="keyword">for</span> p <span class="keyword">in</span> it.product(*chars)]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>, <span class="string">&#x27;mno&#x27;</span>, <span class="string">&#x27;pqrs&#x27;</span>, <span class="string">&#x27;tuv&#x27;</span>, <span class="string">&#x27;wxyz&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> res, d : [s + c <span class="keyword">for</span> s <span class="keyword">in</span> res <span class="keyword">for</span> c <span class="keyword">in</span> m[d]], <span class="built_in">map</span>(<span class="built_in">int</span>, digits), [<span class="string">&#x27;&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>用这个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>, <span class="string">&#x27;mno&#x27;</span>, <span class="string">&#x27;pqrs&#x27;</span>, <span class="string">&#x27;tuv&#x27;</span>, <span class="string">&#x27;wxyz&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: <span class="keyword">return</span> []</span><br><span class="line">        res = [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">map</span>(<span class="built_in">int</span>, digits):</span><br><span class="line">            res = [s + c <span class="keyword">for</span> s <span class="keyword">in</span> res <span class="keyword">for</span> c <span class="keyword">in</span> m[d]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>, <span class="string">&#x27;mno&#x27;</span>, <span class="string">&#x27;pqrs&#x27;</span>, <span class="string">&#x27;tuv&#x27;</span>, <span class="string">&#x27;wxyz&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: <span class="keyword">return</span> []</span><br><span class="line">        res = [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> digits:</span><br><span class="line">            t = []</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> res:</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> m[<span class="built_in">int</span>(d)]:</span><br><span class="line">                    t.append(s + c)</span><br><span class="line">            res = t</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>dfs</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>, <span class="string">&#x27;mno&#x27;</span>, <span class="string">&#x27;pqrs&#x27;</span>, <span class="string">&#x27;tuv&#x27;</span>, <span class="string">&#x27;wxyz&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(digits) == <span class="number">1</span>: <span class="keyword">return</span> <span class="built_in">list</span>(m[<span class="built_in">int</span>(digits)])</span><br><span class="line">        res = self.letterCombinations(digits[: -<span class="number">1</span>]) <span class="comment"># 前边的结果已经出来了，只需要计算当前的最后一个字符即可</span></span><br><span class="line">        <span class="keyword">return</span> [s + c <span class="keyword">for</span> s <span class="keyword">in</span> res <span class="keyword">for</span> c <span class="keyword">in</span> m[<span class="built_in">int</span>(digits[-<span class="number">1</span>])]]</span><br></pre></td></tr></table></figure>
<p>iterative</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> m[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param digits: A digital string</span></span><br><span class="line"><span class="comment">     * @return: all posible letter combinations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> &amp;digits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (digits.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        res.push_back(<span class="string">&quot;&quot;</span>); <span class="comment">// 一定要放一个空串！！！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> d : digits) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : res) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c : m[d - <span class="string">&#x27;0&#x27;</span>]) &#123;</span><br><span class="line">                    t.push_back(s + c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.swap(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>recursive O(3^n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> m[] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @param digits: A digital string</span></span><br><span class="line"><span class="comment">     * @return: all posible letter combinations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> &amp;digits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (digits.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        dfs(<span class="string">&quot;&quot;</span>, digits, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">string</span> &amp;d, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == d.length()) &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : m[d[s.length()] - <span class="string">&#x27;0&#x27;</span>]) &#123;</span><br><span class="line">            dfs(s + c, d, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Brute force</tag>
        <tag>Combination</tag>
      </tags>
  </entry>
  <entry>
    <title>173. Binary Search Tree Iterator</title>
    <url>/2020/11/27/173-Binary-Search-Tree-Iterator/</url>
    <content><![CDATA[<p>amortized O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BSTIterator(TreeNode *root) &#123;</span><br><span class="line">        pushAllLeft(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !s.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">node</span><span class="params">(s.top())</span></span>;</span><br><span class="line">        s.pop();</span><br><span class="line">        pushAllLeft(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushAllLeft</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator will be called like this:</span></span><br><span class="line"><span class="comment"> * BSTIterator i = BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>preorder iterator</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BSTIterator(TreeNode *root) &#123;</span><br><span class="line">        s.push(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !s.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = s.top(); s.pop();</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">            s.push(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">            s.push(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator will be called like this:</span></span><br><span class="line"><span class="comment"> * BSTIterator i = BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search tree</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>18. 4Sum</title>
    <url>/2020/05/31/18-4Sum/</url>
    <content><![CDATA[<p>左右夹逼O(n<sup>3</sup>) time O(1) space<br>kSum的复杂度下界是O(n^(k-1))</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        n, res = <span class="built_in">len</span>(nums), []</span><br><span class="line">        <span class="comment"># mx = nums[-1]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># if nums[i] + 3 * mx &lt; target: continue</span></span><br><span class="line">            <span class="comment"># if 4 * nums[i] &gt; target: break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i - <span class="number">1</span>] == nums[i]: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># if nums[i] + nums[j] + 2 * mx &lt; target: continue</span></span><br><span class="line">                <span class="comment"># if nums[i] + 3 * nums[j] &gt; target: break</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j - <span class="number">1</span>] == nums[j]: <span class="keyword">continue</span></span><br><span class="line">                l, r, t = j + <span class="number">1</span>, n - <span class="number">1</span>, target - nums[i] - nums[j]</span><br><span class="line">                <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                    s = nums[l] + nums[r]</span><br><span class="line">                    <span class="keyword">if</span> s == t:</span><br><span class="line">                        res.append([nums[i], nums[j], nums[l], nums[r]])</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l - <span class="number">1</span>] == nums[l]: l += <span class="number">1</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]: r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> s &lt; t:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l - <span class="number">1</span>] == nums[l]: l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]: r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 注意跳过重复的数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 注意跳过重复的数</span></span><br><span class="line">                <span class="keyword">int</span> l = j + <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> t = target - nums[i] - nums[j];</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                    <span class="keyword">int</span> s = nums[l] + nums[r];</span><br><span class="line">                    <span class="keyword">if</span> (s &lt; t) &#123;</span><br><span class="line">                        <span class="keyword">do</span> &#123; ++l; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="number">1</span>]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; t) &#123;</span><br><span class="line">                        <span class="keyword">do</span> &#123; --r; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="number">1</span>]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.push_back(&#123;nums[i], nums[j], nums[l], nums[r]&#125;);</span><br><span class="line">                        <span class="keyword">do</span> &#123; ++l; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="number">1</span>]);</span><br><span class="line">                        <span class="keyword">do</span> &#123; --r; &#125; <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>19. Remove Nth Node From End of List</title>
    <url>/2020/05/31/19-Remove-Nth-Node-From-End-of-List/</url>
    <content><![CDATA[<p>O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        slow, fast = dummy, head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            slow, fast = slow.<span class="built_in">next</span>, fast.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy_head = <span class="number">0</span>;</span><br><span class="line">        dummy_head.next = head;</span><br><span class="line">        <span class="keyword">auto</span> fast = head, slow = &amp;dummy_head; <span class="comment">// slow指向head的前一个，这样最后slow指向要删的node的前一个，方便删除，比如[1]删倒数第1</span></span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy_head = <span class="number">0</span>;</span><br><span class="line">        dummy_head.next = head;</span><br><span class="line">        <span class="keyword">auto</span> fast = head, slow = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (--n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="function">ListNode <span class="title">dummy_head</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy_head.next = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span> &amp;&amp; fast) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) <span class="keyword">return</span> head; <span class="comment">// 要考虑链表长度不足n</span></span><br><span class="line">        ListNode *slow = head, *prev = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev-&gt;next = slow-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">front</span><span class="params">(head)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">behind</span><span class="params">(&amp;head)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (front) &#123;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (--n &lt; <span class="number">0</span>)</span><br><span class="line">                behind = &amp;(*behind)-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">to_be_deleted</span><span class="params">(*behind)</span></span>;</span><br><span class="line">        *behind = (*behind)-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> to_be_deleted;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
        <tag>Hare and tortoise</tag>
      </tags>
  </entry>
  <entry>
    <title>199. Binary Tree Right Side View</title>
    <url>/2020/11/22/199-Binary-Tree-Right-Side-View/</url>
    <content><![CDATA[<p>bfs O(n) time O(n) space<br>bfs逐层遍历每次取最后一个即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">list</span>&lt;TreeNode *&gt; q; <span class="comment">// q&#123;&#123;root&#125;&#125;;</span></span><br><span class="line">        q.push_back(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            res.push_back(q.back()-&gt;val);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = q.front(); q.pop_front();</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left) &#123; <span class="comment">// 因为要直接access node一定不能把nullptr放进去</span></span><br><span class="line">                    q.push_back(p-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                    q.push_back(p-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>2. Add Two Numbers</title>
    <url>/2020/05/30/2-Add-Two-Numbers/</url>
    <content><![CDATA[<p>O(max(m, n)) time</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        tail = dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> c:</span><br><span class="line">            a = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            b = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            l1 = l1.<span class="built_in">next</span> <span class="keyword">if</span> l1 <span class="keyword">else</span> l1</span><br><span class="line">            l2 = l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">else</span> l2</span><br><span class="line">            c, s = <span class="built_in">divmod</span>(a + b + c, <span class="number">10</span>)</span><br><span class="line">            tail.<span class="built_in">next</span> = ListNode(s)</span><br><span class="line">            tail = tail.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        tail = dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> c != <span class="number">0</span>:</span><br><span class="line">            a = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            b = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            l1 = l1.<span class="built_in">next</span> <span class="keyword">if</span> l1 <span class="keyword">else</span> l1</span><br><span class="line">            l2 = l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">else</span> l2</span><br><span class="line">            s = a + b + c</span><br><span class="line">            tail.<span class="built_in">next</span> = ListNode(s % <span class="number">10</span>)</span><br><span class="line">            tail = tail.<span class="built_in">next</span></span><br><span class="line">            c = s // <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        ListNode dummy_head(0), *tail = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> b = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">            <span class="keyword">int</span> s = a + b + c;</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> ListNode(s % <span class="number">10</span>);</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            c = s / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        ListNode *n1 = l1, *n2 = l2, dummy_head(<span class="number">-1</span>), *t = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">while</span> (n1 || n2 || c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            a = n1 ? n1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            b = n2 ? n2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> s = a + b + c;</span><br><span class="line">            t-&gt;next = <span class="keyword">new</span> ListNode(s % <span class="number">10</span>);</span><br><span class="line">            t = t-&gt;next;</span><br><span class="line">            c = s / <span class="number">10</span>;</span><br><span class="line">            n1 = n1 ? n1-&gt;next : n1;</span><br><span class="line">            n2 = n2 ? n2-&gt;next : n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
        <tag>Addition</tag>
      </tags>
  </entry>
  <entry>
    <title>20. Valid Parentheses</title>
    <url>/2020/05/31/20-Valid-Parentheses/</url>
    <content><![CDATA[<p>stack O(n) time O(n) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stk <span class="keyword">or</span> d[c] != stk[-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stk.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stk += c <span class="comment"># 注意这里c是一个字符所以可以用+=</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stk</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; m = &#123;&#123;<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>&#125;, &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>&#125;, &#123;<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.count(c)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stk.empty() &amp;&amp; stk.back() == m[c]) &#123;</span><br><span class="line">                    stk.pop_back();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; hm&#123;&#123;<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>&#125;, &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>&#125;, &#123;<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hm.count(c)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stk.empty() || stk.top() != hm[c]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.empty(); <span class="comment">// 注意最后要判空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>200. Number of Islands</title>
    <url>/2020/12/06/200-Number-of-Islands/</url>
    <content><![CDATA[<p>Union-find O(mn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty() || grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[] = &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n * m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; n; ++row) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; m; ++col) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[row][col] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> x = row * m + col;</span><br><span class="line">                uf.add(x);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isValid(grid, row + dy[i], col + dx[i])) &#123;</span><br><span class="line">                        <span class="keyword">int</span> y = (row + dy[i]) * m + col + dx[i];</span><br><span class="line">                        uf.make_union(x, y);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || col &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[row][col] == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">        UnionFind(<span class="keyword">int</span> n) : count(<span class="number">0</span>) &#123;</span><br><span class="line">            parent.resize(n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            parent[x] = x;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">make_union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> parent_x = find(x);</span><br><span class="line">            <span class="keyword">int</span> parent_y = find(y);</span><br><span class="line">            <span class="keyword">if</span> (parent_x != parent_y) &#123;</span><br><span class="line">                parent[parent_x] = parent_y;</span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">                parent[x] = parent[parent[x]];</span><br><span class="line">                x = parent[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>DFS O(mn) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty() || grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                    dfs(grid, i, j, dy, dx, n, m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> dy[], <span class="keyword">int</span> dx[], <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= n || j &gt;= m || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            dfs(grid, i + dy[k], j + dx[k], dy, dx, n, m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty() || grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dfs(grid, r, c);</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || grid[r][c] != <span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Depth first search</tag>
        <tag>Island</tag>
        <tag>Union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>207. Course Schedule</title>
    <url>/2020/12/12/207-Course-Schedule/</url>
    <content><![CDATA[<p>topological sort<br>O(V+E) time O(V+E) space<br>dfs</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        visited.resize(numCourses);</span><br><span class="line">        g.resize(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : prerequisites) &#123;</span><br><span class="line">            g[p[<span class="number">1</span>]].push_back(p[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span> &amp;&amp; !dfs(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[x]) <span class="keyword">return</span> visited[x] == <span class="number">1</span>;</span><br><span class="line">        visited[x] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y : g[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(y)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g; <span class="comment">// 邻接链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Depth first search</tag>
        <tag>Topological sort</tag>
      </tags>
  </entry>
  <entry>
    <title>21. Merge Two Sorted Lists</title>
    <url>/2020/05/31/21-Merge-Two-Sorted-Lists/</url>
    <content><![CDATA[<p>iterative O(m+n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        tail = dummy = ListNode()</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                tail.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tail.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            tail = tail.<span class="built_in">next</span></span><br><span class="line">        tail.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy_head(0), *p = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>recusive O(m+n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
        <tag>Merging</tag>
      </tags>
  </entry>
  <entry>
    <title>211. Design Add and Search Words Data Structure</title>
    <url>/2020/11/22/211-Design-Add-and-Search-Words-Data-Structure/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        TrieNode *children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="keyword">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TrieNode *root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    WordDictionary() : root(<span class="keyword">new</span> TrieNode) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : word) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children[k]) &#123;</span><br><span class="line">                p-&gt;children[k] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;children[k];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character &#x27;.&#x27; to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> search(word, <span class="number">0</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;w, <span class="keyword">int</span> i, TrieNode *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == w.length()) <span class="keyword">return</span> p-&gt;isEnd;</span><br><span class="line">        <span class="keyword">if</span> (w[i] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> search(w, i + <span class="number">1</span>, p-&gt;children[w[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (search(w, i + <span class="number">1</span>, p-&gt;children[k])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary* obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addWord(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>215. Kth Largest Element in an Array</title>
    <url>/2020/11/22/215-Kth-Largest-Element-in-an-Array/</url>
    <content><![CDATA[<p>quickselect O(n) on avg</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = partition(nums, l, r);</span><br><span class="line">            <span class="keyword">if</span> (m == k - <span class="number">1</span>) <span class="keyword">return</span> nums[m];</span><br><span class="line">            <span class="keyword">if</span> (m &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;l, l + (r - l) / <span class="number">2</span>, r&#125;;</span><br><span class="line">        swap(A[l], A[v[rand() % <span class="number">3</span>]]);</span><br><span class="line">        <span class="keyword">int</span> j = l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[l]) &#123;</span><br><span class="line">                swap(A[i], A[j++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(A[--j], A[l]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = partition(nums, l, r);</span><br><span class="line">            <span class="keyword">if</span> (i == k - <span class="number">1</span>) <span class="keyword">return</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">                r = i - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;l, (l + r) / <span class="number">2</span>, r&#125;;</span><br><span class="line">        swap(nums[l], nums[v[rand() % <span class="number">3</span>]]);</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[l];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] &lt;= pivot) &#123; <span class="comment">// 因为是求第k大所以要降序</span></span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[l] = nums[r];</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] &gt;= pivot) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[r] = nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l] = pivot;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>; <span class="comment">// 左右闭区间</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123; <span class="comment">// 要考虑l == r的情况</span></span><br><span class="line">            <span class="keyword">auto</span> i = partition(nums, l, r);</span><br><span class="line">            <span class="keyword">if</span> (i == k - <span class="number">1</span>) &#123; <span class="comment">// k是从1开始的</span></span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">                l = i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">int</span> l = left, r = right;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] &lt;= pivot) --r;</span><br><span class="line">            nums[l] = nums[r];</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] &gt;= pivot) ++l;</span><br><span class="line">            nums[r] = nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l] = pivot;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(nlogk) 最小堆里永远保存k个数，堆顶的数是当前第k大的数，如果一个数比堆顶的数大，则入堆，堆自动调整后，将堆顶多余的第k+1大的数弹出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h.size() &lt; k) &#123;</span><br><span class="line">                h.push(n);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h.top() &lt; n) &#123;</span><br><span class="line">                h.pop();</span><br><span class="line">                h.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Quickselect</tag>
      </tags>
  </entry>
  <entry>
    <title>22. Generate Parentheses</title>
    <url>/2020/05/31/22-Generate-Parentheses/</url>
    <content><![CDATA[<p>backtracking O(2<sup>n</sup>) time<br>思路是只要左括号比右括号多就是合法的！！！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[str]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">gen</span>(<span class="params">s, l, r</span>):</span></span><br><span class="line">            <span class="keyword">if</span> l &lt; <span class="number">0</span> <span class="keyword">or</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> l &gt; r: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">and</span> <span class="keyword">not</span> r:</span><br><span class="line">                res.append(s) <span class="comment"># 注意这里不能用res += s因为s是Iterable会逐个追加，想整体追加要用append</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            gen(s + <span class="string">&#x27;(&#x27;</span>, l - <span class="number">1</span>, r) <span class="comment"># 这里底层内存需要进行字符串复制，但是没办法，Python字符串literal不能修改，也不提供StringBuilder</span></span><br><span class="line">            gen(s + <span class="string">&#x27;)&#x27;</span>, l, r - <span class="number">1</span>)</span><br><span class="line">        gen(<span class="string">&#x27;&#x27;</span>, n, n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        dfs(s, n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nl &lt; <span class="number">0</span> || nr &lt; <span class="number">0</span> || nl &gt; nr) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (nl == <span class="number">0</span> &amp;&amp; nr == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(s += <span class="string">&#x27;(&#x27;</span>, nl - <span class="number">1</span>, nr);</span><br><span class="line">        s.pop_back();</span><br><span class="line">        dfs(s += <span class="string">&#x27;)&#x27;</span>, nl, nr - <span class="number">1</span>);</span><br><span class="line">        s.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        nl = nr = n;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        dfs(s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nl == <span class="number">0</span> &amp;&amp; nr == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nl == <span class="number">0</span>) &#123;</span><br><span class="line">            --nr;</span><br><span class="line">            dfs(s += <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            ++nr;</span><br><span class="line">            s.pop_back();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nl == nr) &#123;</span><br><span class="line">            --nl;</span><br><span class="line">            dfs(s += <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            ++nl;</span><br><span class="line">            s.pop_back();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --nl;</span><br><span class="line">            dfs(s += <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            ++nl;</span><br><span class="line">            s.pop_back();</span><br><span class="line">            --nr;</span><br><span class="line">            dfs(s += <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            ++nr;</span><br><span class="line">            s.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nl, nr;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果需要轴对称</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        dfs(s, n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> nl, <span class="keyword">int</span> nr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nl &lt; <span class="number">0</span> || nr &lt; <span class="number">0</span> || nl &gt; nr) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (nl + nr == n) &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    res.back() += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.back() += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(s += <span class="string">&#x27;(&#x27;</span>, nl - <span class="number">1</span>, nr);</span><br><span class="line">        s.pop_back();</span><br><span class="line">        dfs(s += <span class="string">&#x27;)&#x27;</span>, nl, nr - <span class="number">1</span>);</span><br><span class="line">        s.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>224. Basic Calculator</title>
    <url>/2020/12/12/224-Basic-Calculator/</url>
    <content><![CDATA[<p>O(n) time<br>简化版的通用解法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        s += <span class="string">&quot;+&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> calc(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> &amp;i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> op = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="keyword">long</span> n = s.size(), num = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                num = calc(s, ++i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                res += (<span class="number">44</span> - op) * num; <span class="comment">// 因为没有*/所以不需要curRes来进行局部运算，直接用res累加即可</span></span><br><span class="line">                op = c;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        s += <span class="string">&quot;+&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> calc(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> &amp;i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> op = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="keyword">long</span> n = s.size(), num = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n &amp;&amp; op != <span class="string">&#x27;)&#x27;</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                num = calc(s, ++i);</span><br><span class="line">                --i; <span class="comment">// 因为最后循环终止条件是op != &#x27;)&#x27;所以当op为&#x27;)&#x27;时i已经指向下一个符号，所以需要回退一个</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                res += (<span class="number">44</span> - op) * num; <span class="comment">// 因为没有*/所以不需要curRes来进行局部运算，直接用res累加即可</span></span><br><span class="line">                op = c;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为只有加减法，维护两个栈，一个放当前的『和』，一个放加减法（1和-1）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        s += <span class="string">&#x27; &#x27;</span>; <span class="comment">// padding</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; operands, operators;</span><br><span class="line">        long sign(1), res(0), num(0);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 用long防止溢出</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += sign * num;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: sign = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: sign = <span class="number">-1</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: &#123;</span><br><span class="line">                        operands.push(res);</span><br><span class="line">                        operators.push(sign);</span><br><span class="line">                        res = <span class="number">0</span>; <span class="comment">// 开始括号内的新计算所以reset两个变量res和sign</span></span><br><span class="line">                        sign = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: &#123;</span><br><span class="line">                        res = operands.top() + operators.top() * res;</span><br><span class="line">                        operands.pop();</span><br><span class="line">                        operators.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Stack</tag>
        <tag>Calculator</tag>
      </tags>
  </entry>
  <entry>
    <title>227. Basic Calculator II</title>
    <url>/2020/12/13/227-Basic-Calculator-II/</url>
    <content><![CDATA[<p>O(n) time<br>因为没有括号，所以不需要递归<br>整体思路是用加减把算式分隔开，把连续的乘除集中处理，op表示前一步运算，c表示当前处理的运算，每次不管c是加减乘除哪种运算都用local来跟num进行op的运算并把局部结果保存在local里，如果c是乘除则local继续处理运算（连续的乘除运算），如果c是加减则可以进行分割，把当前的局部结果累加到global里</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> global = <span class="number">0</span>, local = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> op = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        s += <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: local += num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: local -= num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: local *= num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: local /= num; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    global += local;</span><br><span class="line">                    local = <span class="number">0</span>; <span class="comment">// local归零并不会影响后边的计算，因为当前的c是加减，所以下一步运算一定是0+/-num并得到一个新的local，如果c是乘除则不修改local，因为下一步运算是乘除，local被用了要清零</span></span><br><span class="line">                &#125;</span><br><span class="line">                op = c;</span><br><span class="line">                num = <span class="number">0</span>; <span class="comment">// num被用了要清零</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> global;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, opnd = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(<span class="string">&#x27;+&#x27;</span> + s + <span class="string">&#x27;+&#x27;</span>)</span></span>; <span class="comment">// 开头结尾都要加+来触发输入和累加更新res</span></span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="keyword">while</span> (input &gt;&gt; op) &#123;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span> || op == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                res += opnd;</span><br><span class="line">                <span class="keyword">if</span> (input &gt;&gt; opnd) &#123;</span><br><span class="line">                    opnd *= (<span class="number">44</span> - op); <span class="comment">// +的ASCII码是43，-的ASCII码是45</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> opnd2;</span><br><span class="line">                input &gt;&gt; opnd2;</span><br><span class="line">                <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    opnd *= opnd2;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    opnd /= opnd2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Stack</tag>
        <tag>Calculator</tag>
      </tags>
  </entry>
  <entry>
    <title>23. Merge k Sorted Lists</title>
    <url>/2020/05/31/23-Merge-k-Sorted-Lists/</url>
    <content><![CDATA[<p>归并 两两inplace merge O(nlogk) k是lists数 n是所有node数 O(1) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">a, b</span>):</span></span><br><span class="line">            tail = dummy = ListNode()</span><br><span class="line">            <span class="keyword">while</span> a <span class="keyword">and</span> b:</span><br><span class="line">                <span class="keyword">if</span> a.val &lt; b.val:</span><br><span class="line">                    tail.<span class="built_in">next</span> = a</span><br><span class="line">                    a = a.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tail.<span class="built_in">next</span> = b</span><br><span class="line">                    b = b.<span class="built_in">next</span></span><br><span class="line">                tail = tail.<span class="built_in">next</span></span><br><span class="line">            tail.<span class="built_in">next</span> = a <span class="keyword">if</span> a <span class="keyword">else</span> b</span><br><span class="line">            <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">        step, n = <span class="number">1</span>, <span class="built_in">len</span>(lists)</span><br><span class="line">        <span class="keyword">while</span> step &lt; n:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n, step &lt;&lt; <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i + step &gt;= n: <span class="keyword">break</span></span><br><span class="line">                lists[i] = merge(lists[i], lists[i + step])</span><br><span class="line">            step &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> merge = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;</span><br><span class="line">            ListNode dummy_head(<span class="number">0</span>), *tail = &amp;dummy_head;</span><br><span class="line">            <span class="keyword">while</span> (a &amp;&amp; b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a-&gt;val &lt; b-&gt;val) &#123;</span><br><span class="line">                    tail-&gt;next = a;</span><br><span class="line">                    a = a-&gt;next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tail-&gt;next = b;</span><br><span class="line">                    b = b-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail-&gt;next = a ? a : b;</span><br><span class="line">            <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = lists.size(), step = <span class="number">1</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + step &lt; n; i += (step &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">                lists[i] = merge(lists[i], lists[i + step]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = lists.size(), step = <span class="number">1</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + step &lt; n; i += (step &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">                lists[i] = merge(lists[i], lists[i + step]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">merge</span><span class="params">(ListNode *a, ListNode *b)</span> </span>&#123;</span><br><span class="line">        ListNode dummy_head(0), *tail = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">while</span> (a &amp;&amp; b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a-&gt;val &lt; b-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = a;</span><br><span class="line">                a = a-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = b;</span><br><span class="line">                b = b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = a ? a : b;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>external sort O(nlogk) n is the number of all nodes, k is the number of linked lists</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line">ListNode.__lt__ = <span class="keyword">lambda</span> x, y: x.val &lt; y.val <span class="comment"># ListNode无法直接比较，用val替代也不行，必须重载__lt__</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        q = PriorityQueue()</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">if</span> l:</span><br><span class="line">                q.put(l)</span><br><span class="line">        tail = dummy = ListNode()</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            l = q.get()</span><br><span class="line">            tail.<span class="built_in">next</span> = l</span><br><span class="line">            tail = l</span><br><span class="line">            l = l.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> l:</span><br><span class="line">                q.put(l)</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;a, <span class="keyword">const</span> <span class="keyword">auto</span> &amp;b) &#123; <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; &#125;;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;ListNode *, <span class="built_in">vector</span>&lt;ListNode *&gt;, <span class="keyword">decltype</span>(cmp)&gt; q(cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> l : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l) &#123;</span><br><span class="line">                q.push(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy_head(0), *tail = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> l = q.top(); q.pop();</span><br><span class="line">            tail-&gt;next = l;</span><br><span class="line">            tail = l;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l) &#123;</span><br><span class="line">                q.push(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
        <tag>Merging</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>236. Lowest Common Ancestor of a Binary Tree</title>
    <url>/2020/12/02/236-Lowest-Common-Ancestor-of-a-Binary-Tree/</url>
    <content><![CDATA[<p>O(n) 分治</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 在root为根的二叉树中找A,B的LCA:</span></span><br><span class="line">    <span class="comment">// 如果找到了就返回这个LCA</span></span><br><span class="line">    <span class="comment">// 如果只碰到A，就返回A</span></span><br><span class="line">    <span class="comment">// 如果只碰到B，就返回B</span></span><br><span class="line">    <span class="comment">// 如果都没有，就返回null</span></span><br><span class="line">		<span class="comment">// 这里默认树上一定有p和q，所以不一定要真的把p和q都找到，假设只找到了其中一个，没找到另一个，说明找到的这个就是lca，另一个一定在以找到的这个点为根的树上</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">auto</span> l = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">auto</span> r = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (l &amp;&amp; r) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> l ? l : r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        TreeNode *res;</span><br><span class="line">        lca(root, p, q, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lca</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q, TreeNode *&amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root || root == p || root == q) &#123;</span><br><span class="line">            res = root;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *l, *r;</span><br><span class="line">        lca(root-&gt;left, p, q, l);</span><br><span class="line">        lca(root-&gt;right, p, q, r);</span><br><span class="line">        <span class="keyword">if</span> (!l) &#123;</span><br><span class="line">            res = r;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!r) &#123;</span><br><span class="line">            res = l;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Postorder traversal</tag>
        <tag>Binary tree</tag>
        <tag>Divide and conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>238. Product of Array Except Self</title>
    <url>/2020/11/22/238-Product-of-Array-Except-Self/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>input: 1 2 3 4<br>res: 1 1 1 1<br>--&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line">-------</span><br><span class="line">1 1 1 1</span><br><span class="line">  1 1 1</span><br><span class="line">    2 2</span><br><span class="line">	  3</span><br></pre></td></tr></table></figure>
<p>&lt;–</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line">-------</span><br><span class="line">1 1 1 1</span><br><span class="line">4 1 1 1</span><br><span class="line">3 4 2 2</span><br><span class="line">2 3 4 3</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, p = <span class="number">1</span>; i &gt;= <span class="number">0</span>; p *= nums[i--]) &#123;</span><br><span class="line">            res[i] *= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">1</span>; i &lt; n; p *= nums[i++]) &#123;</span><br><span class="line">            res[i] *= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, p = <span class="number">1</span>; i &gt;= <span class="number">0</span>; p *= nums[i--]) &#123;</span><br><span class="line">            res[i] *= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p = nums[i - <span class="number">1</span>]; i &lt; n; p *= nums[i++]) &#123;</span><br><span class="line">            res[i] *= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>, p = nums[i + <span class="number">1</span>]; i &gt;= <span class="number">0</span>; p *= nums[i--]) &#123;</span><br><span class="line">            res[i] *= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            p *= nums[i - <span class="number">1</span>];</span><br><span class="line">            res[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            p *= nums[i + <span class="number">1</span>];</span><br><span class="line">            res[i] *= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>24. Swap Nodes in Pairs</title>
    <url>/2020/05/31/24-Swap-Nodes-in-Pairs/</url>
    <content><![CDATA[<p>recursive O(n) time O(n) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        curr = head.<span class="built_in">next</span></span><br><span class="line">        succ = self.swapPairs(curr.<span class="built_in">next</span>)</span><br><span class="line">        curr.<span class="built_in">next</span> = head</span><br><span class="line">        head.<span class="built_in">next</span> = succ</span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> next = head-&gt;next, ret = swapPairs(next-&gt;next);</span><br><span class="line">        next-&gt;next = head;</span><br><span class="line">        head-&gt;next = ret;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>iterative O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        prev, curr = dummy, head</span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span>:</span><br><span class="line">            succ = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = succ.<span class="built_in">next</span></span><br><span class="line">            succ.<span class="built_in">next</span> = prev.<span class="built_in">next</span></span><br><span class="line">            prev.<span class="built_in">next</span> = succ</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = curr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy_head(0), *prev = &amp;dummy_head, *curr = head;</span><br><span class="line">        dummy_head.next = curr;</span><br><span class="line">        <span class="keyword">while</span> (curr &amp;&amp; curr-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> succ = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = succ-&gt;next;</span><br><span class="line">            succ-&gt;next = prev-&gt;next;</span><br><span class="line">            prev-&gt;next = succ;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>247. Strobogrammatic Number II</title>
    <url>/2020/12/06/247-Strobogrammatic-Number-II/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>双指针，从两头往中间枚举所有可能即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findStrobogrammatic</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(n, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        v = &#123;<span class="string">&quot;16896891&quot;</span>, <span class="string">&quot;018810&quot;</span>, <span class="string">&quot;0168968910&quot;</span>&#125;;</span><br><span class="line">        dfs(s, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            k = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = size(v[k]), i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; j; ++i, --j) &#123;</span><br><span class="line">            s[l] = v[k][i];</span><br><span class="line">            s[r] = v[k][j];</span><br><span class="line">            dfs(s, l + <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res, v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findStrobogrammatic</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(n, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        find(s, <span class="number">0</span>, n - <span class="number">1</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; l) &#123; <span class="comment">// 如果指针交错，添加结果</span></span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> chars;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123; <span class="comment">// 如果指针相遇，只有可能是180，包括n为1的情况</span></span><br><span class="line">            chars = <span class="string">&quot;180081&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l == <span class="number">0</span>) &#123; <span class="comment">// 如果指针在两头，则不可能是0</span></span><br><span class="line">            chars = <span class="string">&quot;18696981&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果指针在其他位置，则都有可能</span></span><br><span class="line">            chars = <span class="string">&quot;1869006981&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = chars.length() - <span class="number">1</span>; i &lt; j; ++i, --j) &#123;</span><br><span class="line">            s[l] = chars[i];</span><br><span class="line">            s[r] = chars[j];</span><br><span class="line">            find(s, l + <span class="number">1</span>, r - <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>249. Group Shifted Strings</title>
    <url>/2020/11/28/249-Group-Shifted-Strings/</url>
    <content><![CDATA[<p>O(C) time O(<br>normalize每个单词存到hashmap里</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupStrings(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strings) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : strings) &#123;</span><br><span class="line">            m[norm(s)].push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;[_, v] : m) &#123;</span><br><span class="line">            res.push_back(move(v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">norm</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; <span class="comment">// 返回以ASCII码0为基准的字符串</span></span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">26</span> - s[<span class="number">0</span>]; <span class="comment">// 不关心&#x27;a&#x27;，只关心每个字符和s[0]的offset</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;c : s) &#123;</span><br><span class="line">            c = (c + offset) % <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupStrings(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strings) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : strings) &#123;</span><br><span class="line">            m[norm(s)].push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;[_, v] : m) &#123;</span><br><span class="line">            res.push_back(move(v)); <span class="comment">// 转成右值直接move过去避免copy</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">norm</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; <span class="comment">// 返回值并不需要是一个正常的纯英文可读字符串</span></span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">26</span> + <span class="string">&#x27;a&#x27;</span> - s[<span class="number">0</span>]; <span class="comment">// 这里假设以ASCII码0为基准 最后所有的&#x27;a&#x27;都变成0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;c : s) &#123;</span><br><span class="line">            c = (c - <span class="string">&#x27;a&#x27;</span> + offset) % <span class="number">26</span>; <span class="comment">// 减&#x27;a&#x27;以后以字符0为基准 实际上因为是Galois Field不减&#x27;a&#x27;也行 但是不好描述</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupStrings(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strings) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m; <span class="comment">// 存下标就行，最后整理再放字符串</span></span><br><span class="line">        <span class="keyword">int</span> n = strings.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            m[norm(strings[i])].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[_, v] : m) &#123;</span><br><span class="line">            res.push_back(&#123;&#125;);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : v) &#123;</span><br><span class="line">                res.back().push_back(strings[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">norm</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">26</span> + <span class="string">&#x27;a&#x27;</span> - s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> &amp;c : s) &#123;</span><br><span class="line">            c = (c + offset) % <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupStrings(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strings) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : strings) &#123;</span><br><span class="line">            m[norm(s)].push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;[_, v] : m) &#123;</span><br><span class="line">            res.push_back(&#123;&#125;);</span><br><span class="line">            res.back().swap(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">norm</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; <span class="comment">// 输出以&#x27;a&#x27;为基准的真正可读字符串</span></span><br><span class="line">        <span class="keyword">int</span> offset = <span class="string">&#x27;a&#x27;</span> - s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;c : s) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = c + offset;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                c = <span class="string">&#x27;a&#x27;</span> + (t - <span class="string">&#x27;a&#x27;</span>) + <span class="number">26</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>25. Reverse Nodes in k-Group</title>
    <url>/2020/05/31/25-Reverse-Nodes-in-k-Group/</url>
    <content><![CDATA[<p>recursive O(n)<br>这个更清楚</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        curr, prev = head, self.reverseKGroup(p, k)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            succ = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = succ</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; k &amp;&amp; p; ++i) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> prev = reverseKGroup(p, k), curr = head;</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> succ = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = succ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">int</span> t = k; <span class="comment">// 这里不能用k因为后边还得用</span></span><br><span class="line">        <span class="keyword">while</span> (t-- &gt; <span class="number">0</span> &amp;&amp; p) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= <span class="number">0</span>) <span class="keyword">return</span> head; <span class="comment">// 这里检查尾部较短的部分，必须统计t因为p为nullptr时也可能需要reverse，并且t == 0也是有可能的因为t最后还要--</span></span><br><span class="line">        <span class="keyword">auto</span> prev = reverseKGroup(p, k), curr = head; <span class="comment">// 一个正常的翻转链表操作</span></span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> succ = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = succ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; k &amp;&amp; p; ++i, p = p-&gt;next);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> prev = reverseKGroup(p, k), curr = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> succ = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = succ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>252. Meeting Rooms</title>
    <url>/2020/12/12/252-Meeting-Rooms/</url>
    <content><![CDATA[<p>O(nlogn) time O(n) space<br>要clarify一下start和end如果重合怎么算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canAttendMeetings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(begin(intervals), end(intervals));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size(intervals); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i - <span class="number">1</span>][<span class="number">1</span>] &gt; intervals[i][<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canAttendMeetings</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> Interval &amp;a, <span class="keyword">const</span> Interval &amp;b) &#123;<span class="keyword">return</span> a.start &lt; b.start;&#125;;</span><br><span class="line">        sort(begin(intervals), end(intervals), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i - <span class="number">1</span>].end &gt; intervals[i].start) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canAttendMeetings</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> Interval &amp;a, <span class="keyword">const</span> Interval &amp;b) &#123;<span class="keyword">return</span> a.start &lt; b.start;&#125;;</span><br><span class="line">        sort(begin(intervals), end(intervals), cmp);</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.start &lt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            end = i.end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canAttendMeetings</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i : intervals) &#123;</span><br><span class="line">            ++m[i.start];</span><br><span class="line">            --m[i.end];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;p : m) &#123;</span><br><span class="line">            cnt += p.second;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sweep line</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>253. Meeting Rooms II</title>
    <url>/2020/12/13/253-Meeting-Rooms-II/</url>
    <content><![CDATA[<p>O(nlogn) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i : intervals) &#123;</span><br><span class="line">            ++m[i[<span class="number">0</span>]];</span><br><span class="line">            --m[i[<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [_, c] : m) &#123;</span><br><span class="line">            res = max(res, cnt += c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sweep line</tag>
      </tags>
  </entry>
  <entry>
    <title>26. Remove Duplicates from Sorted Array</title>
    <url>/2020/05/31/26-Remove-Duplicates-from-Sorted-Array/</url>
    <content><![CDATA[<p>O(n) time</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> nums[i] != x:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                nums[i] = x</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[j]) &#123;</span><br><span class="line">                nums[++i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用这个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">1</span> <span class="keyword">or</span> nums[i - <span class="number">1</span>] &lt; x:</span><br><span class="line">                nums[i] = x</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">1</span> || x &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[i++] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>快慢指针解法O(n)<br><a href="http://www.cnblogs.com/grandyang/p/4329128.html">题解</a><br>快指针fast遍历整个数组，遇到和slow不相同的数，就把nums[fast]赋给slow的下一个，同时慢指针slow向前一步</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[last] != nums[i]) &#123;</span><br><span class="line">                nums[++last] = nums[i]; <span class="comment">// 先加加再写就可以了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last + <span class="number">1</span>; <span class="comment">// 因为last是下标，所以要返回last + 1才是个数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>朴素解法O(n)<br>在每个位置从当前位置开始向后找到第一个比当前位置之前一个数更大的数赋给当前位置，每次向后找的时候就从之前找到的那个更大的数的位置继续向后找即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, j = i;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123; ++j; &#125; <span class="keyword">while</span> (j &lt; n &amp;&amp; nums[j] &lt;= nums[i - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (j &lt; n) nums[i] = nums[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = i; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hare and tortoise</tag>
      </tags>
  </entry>
  <entry>
    <title>269. Alien Dictionary</title>
    <url>/2020/11/22/269-Alien-Dictionary/</url>
    <content><![CDATA[<p>build graph O(mn) time<br>topological sort O(v+e) time<br>这里[“ab”, “abc”]以及[“z”, “z”]都是合法的，返回任一结果即可，但是[“abc”, “ab”]是非法的，必须返回空串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">alienOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : words) &#123; <span class="comment">// 这个必须是deep copy因为后边要修改</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!g.count(c)) &#123;</span><br><span class="line">                    g[c] = &#123;&#125;; <span class="comment">// 需要对unordered_set初始化否则结果不完整会丢字符</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> n = min(u.length(), v.length()), i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; n; ++i) &#123; <span class="comment">// 比较前后两个字符串的每个字符，如果发现不一样的加一条边</span></span><br><span class="line">                <span class="keyword">if</span> (u[i] != v[i]) &#123;</span><br><span class="line">                    g[u[i]].insert(v[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == n &amp;&amp; u.length() &gt; v.length()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// [&quot;abc&quot;, &quot;ab&quot;]非法</span></span><br><span class="line">            u.swap(v);</span><br><span class="line">        &#125;</span><br><span class="line">        visited.resize(<span class="number">128</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [c, _] : g) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isAcyclic(c)) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(rbegin(s), rend(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAcyclic</span><span class="params">(<span class="keyword">char</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[u]) <span class="keyword">return</span> visited[u] == <span class="number">1</span>;</span><br><span class="line">        visited[u] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isAcyclic(v)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s += u;</span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;&gt; g; <span class="comment">// 用unordered_set去重</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; visited; <span class="comment">// -1 0 1节省空间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">alienOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (words.size() == <span class="number">1</span>) <span class="keyword">return</span> words[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b) &#123;<span class="keyword">return</span> a.length() &lt; b.length();&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = words.size(), m = max_element(begin(words), end(words), cmp)-&gt;length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">isOrdered</span><span class="params">(n - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isOrdered[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (words[i].length() &lt;= j) &#123;</span><br><span class="line">                        isOrdered[i] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (words[i][j] != words[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">                        isOrdered[i] = <span class="literal">true</span>;</span><br><span class="line">                        g[words[i][j]].insert(words[i + <span class="number">1</span>][j]);</span><br><span class="line">                        <span class="keyword">if</span> (g.count(words[i + <span class="number">1</span>][j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                            g[words[i + <span class="number">1</span>][j]] = &#123;&#125;;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; words[i].length() &amp;&amp; g.count(words[i][j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    g[words[i][j]] = &#123;&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; words[i + <span class="number">1</span>].length() &amp;&amp; g.count(words[i + <span class="number">1</span>][j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    g[words[i + <span class="number">1</span>][j]] = &#123;&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited.resize(<span class="number">128</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;p : g) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ts(p.first)) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            res += s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ts</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[ch] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited[ch] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        visited[ch] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;c : g[ch]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ts(c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(ch);</span><br><span class="line">        visited[ch] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;&gt; g;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Topological sort</tag>
      </tags>
  </entry>
  <entry>
    <title>27. Remove Element</title>
    <url>/2020/05/31/27-Remove-Element/</url>
    <content><![CDATA[<p>O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> x != val:</span><br><span class="line">                nums[i] = x</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x != val) &#123;</span><br><span class="line">                nums[i++] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">                swap(nums[i], nums[--n]);</span><br><span class="line">                nums.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hare and tortoise</tag>
      </tags>
  </entry>
  <entry>
    <title>270. Closest Binary Search Tree Value</title>
    <url>/2020/12/01/270-Closest-Binary-Search-Tree-Value/</url>
    <content><![CDATA[<p>iterative O(h) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = root-&gt;val;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(root-&gt;val - target) &lt; <span class="built_in">fabs</span>(res - target)) &#123;</span><br><span class="line">                res = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;val &gt; target ? root-&gt;left : root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>recursive O(h) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        res = root-&gt;val;</span><br><span class="line">        dfs(root, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(root-&gt;val - target) &lt; <span class="built_in">fabs</span>(res - target)) &#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;val &gt; target ? dfs(root-&gt;left, target) : dfs(root-&gt;right, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n) time O(h) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        res = root-&gt;val;</span><br><span class="line">        dfs(root, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(root-&gt;val - target) &lt; <span class="built_in">fabs</span>(res - target)) &#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, target);</span><br><span class="line">        dfs(root-&gt;right, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
        <tag>Binary search tree</tag>
      </tags>
  </entry>
  <entry>
    <title>273. Integer to English Words</title>
    <url>/2020/11/22/273-Integer-to-English-Words/</url>
    <content><![CDATA[<p>recursive</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="number">1e9</span>, <span class="string">&quot;Billion&quot;</span>&#125;, &#123;<span class="number">1e6</span>, <span class="string">&quot;Million&quot;</span>&#125;, &#123;<span class="number">1e3</span>, <span class="string">&quot;Thousand&quot;</span>&#125;, &#123;<span class="number">100</span>, <span class="string">&quot;Hundred&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">90</span>, <span class="string">&quot;Ninety&quot;</span>&#125;, &#123;<span class="number">80</span>, <span class="string">&quot;Eighty&quot;</span>&#125;, &#123;<span class="number">70</span>, <span class="string">&quot;Seventy&quot;</span>&#125;, &#123;<span class="number">60</span>, <span class="string">&quot;Sixty&quot;</span>&#125;, &#123;<span class="number">50</span>, <span class="string">&quot;Fifty&quot;</span>&#125;, &#123;<span class="number">40</span>, <span class="string">&quot;Forty&quot;</span>&#125;, &#123;<span class="number">30</span>, <span class="string">&quot;Thirty&quot;</span>&#125;, &#123;<span class="number">20</span>, <span class="string">&quot;Twenty&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">19</span>, <span class="string">&quot;Nineteen&quot;</span>&#125;, &#123;<span class="number">18</span>, <span class="string">&quot;Eighteen&quot;</span>&#125;, &#123;<span class="number">17</span>, <span class="string">&quot;Seventeen&quot;</span>&#125;, &#123;<span class="number">16</span>, <span class="string">&quot;Sixteen&quot;</span>&#125;, &#123;<span class="number">15</span>, <span class="string">&quot;Fifteen&quot;</span>&#125;, &#123;<span class="number">14</span>, <span class="string">&quot;Fourteen&quot;</span>&#125;, &#123;<span class="number">13</span>, <span class="string">&quot;Thirteen&quot;</span>&#125;, &#123;<span class="number">12</span>, <span class="string">&quot;Twelve&quot;</span>&#125;, &#123;<span class="number">11</span>, <span class="string">&quot;Eleven&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="string">&quot;Ten&quot;</span>&#125;, &#123;<span class="number">9</span>, <span class="string">&quot;Nine&quot;</span>&#125;, &#123;<span class="number">8</span>, <span class="string">&quot;Eight&quot;</span>&#125;, &#123;<span class="number">7</span>, <span class="string">&quot;Seven&quot;</span>&#125;, &#123;<span class="number">6</span>, <span class="string">&quot;Six&quot;</span>&#125;, &#123;<span class="number">5</span>, <span class="string">&quot;Five&quot;</span>&#125;, &#123;<span class="number">4</span>, <span class="string">&quot;Four&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;Three&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;Two&quot;</span>&#125;, &#123;<span class="number">1</span>, <span class="string">&quot;One&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="string">&quot;Zero&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">numberToWords</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1e9</span>, <span class="number">1e6</span>, <span class="number">1e3</span>, <span class="number">100</span>&#125;; <span class="comment">// 100以上的数统一处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= x) &#123;</span><br><span class="line">                res.append(numberToWords(num / x)).append(<span class="string">&quot; &quot;</span>).append(m[x]);</span><br><span class="line">                num %= x;</span><br><span class="line">                <span class="keyword">return</span> num &gt; <span class="number">0</span> ? res.append(<span class="string">&quot; &quot;</span>).append(numberToWords(num)) : res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">20</span>) &#123; <span class="comment">// 100以内20以上的数统一处理</span></span><br><span class="line">            res.append(m[num - num % <span class="number">10</span>]);</span><br><span class="line">            num %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> num &gt; <span class="number">0</span> ? res.append(<span class="string">&quot; &quot;</span>).append(numberToWords(num)) : res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[num]; <span class="comment">// 20以内的数直接查表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m = &#123;</span><br><span class="line">    &#123;<span class="number">1e9</span>, <span class="string">&quot;Billion&quot;</span>&#125;, &#123;<span class="number">1e6</span>, <span class="string">&quot;Million&quot;</span>&#125;, &#123;<span class="number">1e3</span>, <span class="string">&quot;Thousand&quot;</span>&#125;, &#123;<span class="number">100</span>, <span class="string">&quot;Hundred&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">90</span>, <span class="string">&quot;Ninety&quot;</span>&#125;, &#123;<span class="number">80</span>, <span class="string">&quot;Eighty&quot;</span>&#125;, &#123;<span class="number">70</span>, <span class="string">&quot;Seventy&quot;</span>&#125;, &#123;<span class="number">60</span>, <span class="string">&quot;Sixty&quot;</span>&#125;, &#123;<span class="number">50</span>, <span class="string">&quot;Fifty&quot;</span>&#125;, &#123;<span class="number">40</span>, <span class="string">&quot;Forty&quot;</span>&#125;, &#123;<span class="number">30</span>, <span class="string">&quot;Thirty&quot;</span>&#125;, &#123;<span class="number">20</span>, <span class="string">&quot;Twenty&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">19</span>, <span class="string">&quot;Nineteen&quot;</span>&#125;, &#123;<span class="number">18</span>, <span class="string">&quot;Eighteen&quot;</span>&#125;, &#123;<span class="number">17</span>, <span class="string">&quot;Seventeen&quot;</span>&#125;, &#123;<span class="number">16</span>, <span class="string">&quot;Sixteen&quot;</span>&#125;, &#123;<span class="number">15</span>, <span class="string">&quot;Fifteen&quot;</span>&#125;, &#123;<span class="number">14</span>, <span class="string">&quot;Fourteen&quot;</span>&#125;, &#123;<span class="number">13</span>, <span class="string">&quot;Thirteen&quot;</span>&#125;, &#123;<span class="number">12</span>, <span class="string">&quot;Twelve&quot;</span>&#125;, &#123;<span class="number">11</span>, <span class="string">&quot;Eleven&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="string">&quot;Ten&quot;</span>&#125;, &#123;<span class="number">9</span>, <span class="string">&quot;Nine&quot;</span>&#125;, &#123;<span class="number">8</span>, <span class="string">&quot;Eight&quot;</span>&#125;, &#123;<span class="number">7</span>, <span class="string">&quot;Seven&quot;</span>&#125;, &#123;<span class="number">6</span>, <span class="string">&quot;Six&quot;</span>&#125;, &#123;<span class="number">5</span>, <span class="string">&quot;Five&quot;</span>&#125;, &#123;<span class="number">4</span>, <span class="string">&quot;Four&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;Three&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;Two&quot;</span>&#125;, &#123;<span class="number">1</span>, <span class="string">&quot;One&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="string">&quot;Zero&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">numberToWords</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1000000000</span>, <span class="number">1000000</span>, <span class="number">1000</span>, <span class="number">100</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> it = lower_bound(begin(v), end(v), num, greater&lt;&gt;()); it != end(v)) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = *it;</span><br><span class="line">            res.append(numberToWords(num / x).append(<span class="string">&quot; &quot;</span>).append(m[x]));</span><br><span class="line">            num %= x;</span><br><span class="line">            <span class="keyword">return</span> num &gt; <span class="number">0</span> ? res.append(<span class="string">&quot; &quot;</span>).append(numberToWords(num)) : res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">20</span>) &#123;</span><br><span class="line">            res.append(m[num - num % <span class="number">10</span>]);</span><br><span class="line">            num %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> num &gt; <span class="number">0</span> ? res.append(<span class="string">&quot; &quot;</span>).append(numberToWords(num)) : res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Integer</tag>
      </tags>
  </entry>
  <entry>
    <title>278. First Bad Version</title>
    <url>/2020/11/26/278-First-Bad-Version/</url>
    <content><![CDATA[<p>binary search O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of isBadVersion API.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBadVersion</span><span class="params">(<span class="keyword">int</span> version)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(m)) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>28. Implement strStr()</title>
    <url>/2020/05/31/28-Implement-strStr/</url>
    <content><![CDATA[<p>rolling hash O(h + n)<br>hash = (hash * base + ord(c)) % modulus<br>modulus 必须是一个大质数（比 ord(c)要大，否则 C++会算出负数，Python 不会）来避免过多的 collision<br>必须要解决 hash collision，反例<br>“gytisyz”<br>“aaaaaab”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        h, n = <span class="built_in">len</span>(haystack), <span class="built_in">len</span>(needle)</span><br><span class="line">        <span class="keyword">if</span> h &lt; n: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        highest_power, hh, nh = <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        M, B = <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>, <span class="number">256</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            highest_power = (highest_power * B) % M</span><br><span class="line">            hh = (hh * B + <span class="built_in">ord</span>(haystack[i])) % M</span><br><span class="line">            nh = (nh * B + <span class="built_in">ord</span>(needle[i])) % M</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(h - n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">1</span>:</span><br><span class="line">                hh = (hh * B - <span class="built_in">ord</span>(haystack[i - <span class="number">1</span>]) * highest_power + <span class="built_in">ord</span>(haystack[i + n - <span class="number">1</span>])) % M</span><br><span class="line">            <span class="keyword">if</span> hh == nh:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    <span class="keyword">if</span> haystack[i + j] != needle[j]:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = haystack.length(), n = needle.length();</span><br><span class="line">        <span class="keyword">long</span> M = INT_MAX, B = <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">if</span> (h &lt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> highest_power = <span class="number">1</span>, hh = <span class="number">0</span>, nh = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            highest_power = (highest_power * B) % M;</span><br><span class="line">            nh = (nh * B + needle[i]) % M;</span><br><span class="line">            hh = (hh * B + haystack[i]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= h - n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                hh = (hh * B + M - haystack[i - <span class="number">1</span>] * highest_power % M + haystack[i + n - <span class="number">1</span>]) % M; <span class="comment">// 这里highest_power是B的n次方，因为先整体左移再减高位，如果先减高位再整体左移就是n-1次方了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hh == nh &amp;&amp; haystack.substr(i, n) == needle) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = haystack.length(), n = needle.length();</span><br><span class="line">        <span class="keyword">long</span> M = INT_MAX, B = <span class="number">256</span>; <span class="comment">// INT_MAX是质数！</span></span><br><span class="line">        <span class="keyword">if</span> (h &lt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> highest_power = <span class="number">1</span>, hh = <span class="number">0</span>, nh = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            highest_power = (highest_power * B) % M;</span><br><span class="line">            nh = (nh * B + needle[i]) % M;</span><br><span class="line">            hh = (hh * B + haystack[i]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= h - n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                hh = (hh * B + M - haystack[i - <span class="number">1</span>] * highest_power % M + haystack[i + n - <span class="number">1</span>]) % M; <span class="comment">// 这里highest_power是B的n次方，因为先整体左移再减高位，如果先减高位再整体左移就是n-1次方了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hh == nh) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (haystack[i + j] != needle[j]) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(nh)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> haystack <span class="keyword">and</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        h, n = <span class="built_in">len</span>(haystack), <span class="built_in">len</span>(needle)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(h - n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> haystack[i:i + n] == needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = needle.length(), h = haystack.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= h - n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack[i + j] != needle[j]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Rolling hash</tag>
      </tags>
  </entry>
  <entry>
    <title>29. Divide Two Integers</title>
    <url>/2020/05/31/29-Divide-Two-Integers/</url>
    <content><![CDATA[<p>binary search O(log(dividend/divisor)) time<br>相当于把商转成二进制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dd, dr = <span class="built_in">abs</span>(dividend), <span class="built_in">abs</span>(divisor)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> dd &gt;= dr:</span><br><span class="line">            t, cnt = dr, <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> dd &gt;= (t &lt;&lt; <span class="number">1</span>):</span><br><span class="line">                t &lt;&lt;= <span class="number">1</span></span><br><span class="line">                cnt &lt;&lt;= <span class="number">1</span></span><br><span class="line">            dd -= t</span><br><span class="line">            res += cnt</span><br><span class="line">        <span class="keyword">if</span> (dividend ^ divisor) &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -res</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(res, (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># return [res, (1 &lt;&lt; 31) - 1][res &gt; (1 &lt;&lt; 31) - 1] # 相当于array[0]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> dd = <span class="built_in">labs</span>(dividend), dr = <span class="built_in">labs</span>(divisor), res = <span class="number">0</span>; <span class="comment">// 这里要用labs因为abs(INT_MIN)还是INT_MIN</span></span><br><span class="line">        <span class="keyword">while</span> (dd &gt;= dr) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = dr, cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (dd &gt;= (t &lt;&lt; <span class="number">1</span>)) &#123; <span class="comment">// 这里是要避免1/1这个case死循环</span></span><br><span class="line">                t &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                cnt &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dd -= t;</span><br><span class="line">            res += cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((dividend ^ divisor) &lt; <span class="number">0</span>) <span class="keyword">return</span> -res;</span><br><span class="line">        <span class="keyword">return</span> min(res, (<span class="keyword">long</span>)INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isNeg = (dividend ^ divisor) &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> dd = <span class="built_in">abs</span>((<span class="keyword">long</span>)dividend), dr = <span class="built_in">abs</span>((<span class="keyword">long</span>)divisor);</span><br><span class="line">        <span class="keyword">if</span> (dr == <span class="number">0</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>, v = <span class="number">0</span>, shift = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> changed = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            dd -= (v &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            res += (shift &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            v = dr;</span><br><span class="line">            shift = <span class="number">1</span>;</span><br><span class="line">            changed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (v &lt;= dd) &#123;</span><br><span class="line">                v &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                shift &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (changed);</span><br><span class="line">        <span class="keyword">if</span> (!isNeg &amp;&amp; res &gt;= INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">return</span> isNeg ? -res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isNeg = (dividend ^ divisor) &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> dd = <span class="built_in">abs</span>((<span class="keyword">long</span>)dividend), dr = <span class="built_in">abs</span>((<span class="keyword">long</span>)divisor);</span><br><span class="line">        <span class="keyword">if</span> (dr == <span class="number">0</span>) <span class="keyword">return</span> INT_MAX; <span class="comment">// x/0</span></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> v = dr;</span><br><span class="line">            <span class="keyword">long</span> shift = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">bool</span> changed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (v &lt;= dd) &#123;</span><br><span class="line">                v &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                shift &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                dd -= (v &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                res += (shift &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (!isNeg &amp;&amp; res &gt;= INT_MAX) <span class="keyword">return</span> INT_MAX; <span class="comment">// INT_MIN/-1</span></span><br><span class="line">        <span class="keyword">return</span> isNeg ? -res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Integer</tag>
      </tags>
  </entry>
  <entry>
    <title>282. Expression Add Operators</title>
    <url>/2020/11/27/282-Expression-Add-Operators/</url>
    <content><![CDATA[<p>exponential O(n * 4^n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">addOperators</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, num, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">long</span> sum, <span class="keyword">long</span> last_num, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> b, <span class="keyword">const</span> <span class="built_in">string</span> &amp;num, <span class="keyword">const</span> <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target &amp;&amp; b == num.length()) &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> curr_s;</span><br><span class="line">        <span class="keyword">long</span> curr_num = <span class="number">0</span>; <span class="comment">// 必须用long防止溢出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; num.length(); ++i) &#123;</span><br><span class="line">            curr_s += num[i];</span><br><span class="line">            curr_num = curr_num * <span class="number">10</span> + num[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">0</span>) &#123; <span class="comment">// +3456-23-74+90是错的，第一个数字前不能有符号</span></span><br><span class="line">                dfs(curr_num, curr_num, curr_s, i + <span class="number">1</span>, num, target);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dfs(sum + curr_num, curr_num, s + <span class="string">&#x27;+&#x27;</span> + curr_s, i + <span class="number">1</span>, num, target);</span><br><span class="line">                dfs(sum - curr_num, -curr_num, s + <span class="string">&#x27;-&#x27;</span> + curr_s, i + <span class="number">1</span>, num, target);</span><br><span class="line">                dfs(sum - last_num + last_num * curr_num, last_num * curr_num, s + <span class="string">&#x27;*&#x27;</span> + curr_s, i + <span class="number">1</span>, num, target);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num[b] == <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 数字不能以0开始，2534+034是错的</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>String</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>3. Longest Substring Without Repeating Characters</title>
    <url>/2020/05/30/3-Longest-Substring-Without-Repeating-Characters/</url>
    <content><![CDATA[<p>O(n) 用hashmap维护下标<br>l表示上一个发生重复的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        res, l = <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> r, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            l = <span class="built_in">max</span>(l, d.get(c, -<span class="number">1</span>))</span><br><span class="line">            res = <span class="built_in">max</span>(res, r - l)</span><br><span class="line">            d[c] = r</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; f(<span class="number">256</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> r = <span class="number">0</span>, l = -<span class="number">1</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            l = <span class="built_in">max</span>(l, f[s[r]]); // 更新l</span><br><span class="line">            f[s[r]] = r; // 更新表</span><br><span class="line">            res = <span class="built_in">max</span>(res, r - l); // 更新res</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">hm</span><span class="params">(<span class="number">256</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            start = max(start, hm[s[i]]); <span class="comment">// 一定要用max更新start，否则见反例abba</span></span><br><span class="line">            hm[s[i]] = i;</span><br><span class="line">            res = max(res, i - start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n) two pointers</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> hashmap[<span class="number">256</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = i; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; !hashmap[s[j]]) &#123;</span><br><span class="line">                hashmap[s[j++]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, j - i);</span><br><span class="line">            hashmap[s[i]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
      </tags>
  </entry>
  <entry>
    <title>30. Substring with Concatenation of All Words</title>
    <url>/2020/05/31/30-Substring-with-Concatenation-of-All-Words/</url>
    <content><![CDATA[<p>sliding window O(n * l) time O(m * l) space<br>这道题主要思路是把每个单词当成单个字母来处理，用sliding window找出所有符合要求的结果，即对于s[0:10)来说，假设words的每个单词长度为3，那么第一次处理s[0:3) s[3:6) s[6:9) s[9:10)，第二次处理s[1:4) s[4:7) s[7:10)，第三次处理s[2:5) s[5:8) s[8:10)<br>跟<a href="https://leetcode.com/problems/minimum-window-substring/">76. Minimum Window Substring</a>思路接近<br>跟<a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">438. Find All Anagrams in a String</a>解法一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: List[<span class="built_in">str</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> words: <span class="keyword">return</span> []</span><br><span class="line">        d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            d[w] += <span class="number">1</span></span><br><span class="line">        n, m, l = <span class="built_in">len</span>(s), <span class="built_in">len</span>(words), <span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line">        total, res = m * l, []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">            td, cnt = d.copy(), m</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n, l): <span class="comment"># 应该是j + l &lt;= n但是python里字符串切片越界也不影响</span></span><br><span class="line">                t = s[j:j + l]</span><br><span class="line">                td[t] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> td[t] &gt;= <span class="number">0</span>:</span><br><span class="line">                    cnt -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j - total &gt;= i:</span><br><span class="line">                    t = s[j - total:j - total + l]</span><br><span class="line">                    td[t] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> td[t] &gt; <span class="number">0</span>:</span><br><span class="line">                        cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">                    res.append(j - total + l)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (words.empty() || s.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), m = words.size(), l = words[<span class="number">0</span>].length(), total = m * l;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : words) &#123;</span><br><span class="line">            ++hm[w];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = hm;</span><br><span class="line">            <span class="keyword">int</span> cnt = m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j + l &lt;= n; j += l) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--t[s.substr(j, l)] &gt;= <span class="number">0</span>) &#123; <span class="comment">// 从0减小成非0不更新cnt</span></span><br><span class="line">                    --cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - total &gt;= i &amp;&amp; ++t[s.substr(j - total, l)] &gt; <span class="number">0</span>) &#123; <span class="comment">// cnt只有在大于等于0以上更新才有用，从非0变成0不贡献频数所以不更新cnt</span></span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.push_back(j - total + l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (words.empty() || s.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), m = words.size(), l = words[<span class="number">0</span>].length(), total = m * l;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : words) &#123;</span><br><span class="line">            ++hm[w];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = hm;</span><br><span class="line">            <span class="keyword">int</span> cnt = m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j + l &lt;= n; j += l) &#123;</span><br><span class="line">                <span class="keyword">auto</span> w = s.substr(j, l);</span><br><span class="line">                <span class="keyword">if</span> (t.count(w) &amp;&amp; t[w]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    --cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= total) &#123;</span><br><span class="line">                    w = s.substr(j - total, l);</span><br><span class="line">                    <span class="keyword">if</span> (t.count(w) &amp;&amp; ++t[w] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        ++cnt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.push_back(j - total + l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一点优化：如果当前统计的单词不存在则sliding window直接跳过该单词开始新的统计</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (words.empty() || s.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), m = words.size(), len = words[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hm; <span class="comment">// 先统计单词频数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : words) &#123;</span><br><span class="line">            ++hm[w];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123; <span class="comment">// trick在扫描方式上，假设单词长度为3，那么第一次扫0369第二次147第三次258</span></span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;&gt; t; <span class="comment">// 每个queue放每个有效单词的出现位置</span></span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, b = j; j + len &lt;= n; j += len) &#123;</span><br><span class="line">                <span class="keyword">auto</span> w = s.substr(j, len);</span><br><span class="line">                <span class="keyword">if</span> (hm.count(w) == <span class="number">0</span>) &#123; <span class="comment">// 如果当前位置单词不存在，之前统计全部清空</span></span><br><span class="line">                    t.clear();</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                    b = j + len;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t[w].size() &lt; hm[w]) &#123; <span class="comment">// 如果当前位置单词存在且个数未超过上限</span></span><br><span class="line">                    t[w].push(j);</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果当前位置单词存在但是个数已达上限，清除当前位置单词在窗口内最早出现位置之前的所有单词</span></span><br><span class="line">                    b = t[w].front() + len;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;p : t) &#123;</span><br><span class="line">                        <span class="keyword">while</span> (!p.second.empty() &amp;&amp; p.second.front() &lt; b) &#123;</span><br><span class="line">                            --cnt;</span><br><span class="line">                            p.second.pop();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    t[w].push(j);</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt == m) &#123; <span class="comment">// 如果找到符合要求的单词组合</span></span><br><span class="line">                    res.push_back(b);</span><br><span class="line">                    --cnt;</span><br><span class="line">                    t[s.substr(b, len)].pop();</span><br><span class="line">                    b += len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>304. Range Sum Query 2D - Immutable</title>
    <url>/2020/12/06/304-Range-Sum-Query-2D-Immutable/</url>
    <content><![CDATA[<p>O(mn) time constructor O(1) time call O(mn) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        mtx.resize(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt;= n; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= m; ++c) &#123;</span><br><span class="line">                mtx[r][c] = matrix[r - <span class="number">1</span>][c - <span class="number">1</span>] + mtx[r - <span class="number">1</span>][c] + mtx[r][c - <span class="number">1</span>] - mtx[r - <span class="number">1</span>][c - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mtx[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - mtx[row1][col2 + <span class="number">1</span>] - mtx[row2 + <span class="number">1</span>][col1] + mtx[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mtx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumMatrix obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>Range sum</tag>
      </tags>
  </entry>
  <entry>
    <title>31. Next Permutation</title>
    <url>/2020/05/31/31-Next-Permutation/</url>
    <content><![CDATA[<p>O(n) time 举例021找到第一个顺序对02，说明2开始已经是全逆序了，不可能再找到新的排列，所以只能找2后面的一个数和0交换，从后往前找到第一个比0大的是1，说明1以后的数都不比0大，不可能跟0交换，把1跟0交换以后，得到了一个新的排列，这时要将从2开始的全逆序翻转，即021 –&gt; 120 –&gt; 102</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n, x = <span class="built_in">len</span>(nums), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i + <span class="number">1</span>]:</span><br><span class="line">                x = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums.reverse()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, x, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[x]:</span><br><span class="line">                nums[x], nums[i] = nums[i], nums[x]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># nums[x + 1:] = reversed(nums[x + 1:])</span></span><br><span class="line">        nums[x + <span class="number">1</span>:] = nums[n - <span class="number">1</span>:x:-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># nums[x + 1:] = nums[x + 1:][::-1]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums.reverse()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, i, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[i]:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        l, r = i + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] &gt;= nums[i]) --i;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            reverse(begin(nums), end(nums));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[j] &lt;= nums[i - <span class="number">1</span>]) --j;</span><br><span class="line">        swap(nums[i - <span class="number">1</span>], nums[j]);</span><br><span class="line">        reverse(begin(nums) + i, end(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] &gt;= nums[i]) --i;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            reverse(begin(nums), end(nums));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = lower_bound(begin(nums) + i, end(nums), nums[i - <span class="number">1</span>], greater()) - begin(nums) - <span class="number">1</span>; <span class="comment">// 二分查找右边降序序列里倒数第一个比nums[i - 1]大的数的位置</span></span><br><span class="line">        swap(nums[i - <span class="number">1</span>], nums[j]);</span><br><span class="line">        reverse(begin(nums) + i, end(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i1 = l, i2 = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt; l; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">                i1 = i - <span class="number">1</span>;</span><br><span class="line">                i2 = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == i2) &#123;</span><br><span class="line">            reverse(begin(nums), end(nums));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i3 = i2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= i2; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i1]) &#123;</span><br><span class="line">                i3 = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i1], nums[i3]);</span><br><span class="line">        reverse(begin(nums) + i2, end(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        nextPerm(nums, <span class="number">0</span>, n - <span class="number">1</span>); <span class="comment">// 这里用的是左右闭区间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">nextPerm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= l) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果元素个数为0或者1，则没有下一个排列</span></span><br><span class="line">        <span class="keyword">int</span> idx1 = l, idx2 = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r - <span class="number">1</span>; i &gt;= l; --i) &#123; <span class="comment">// 从后往前找到第一个相邻两元素后面的比前面大的</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                idx1 = i;</span><br><span class="line">                idx2 = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx1 == idx2) &#123; <span class="comment">// 如果找不到，说明已经逆序，返回一个初始正序</span></span><br><span class="line">            reverse(nums.begin() + l, nums.begin() + r + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx3 = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l; --i) &#123; <span class="comment">// 从后往前找到第一个比之前找到的较小元素大的元素，与之交换</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[idx1]) &#123;</span><br><span class="line">                idx3 = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[idx1], nums[idx3]);</span><br><span class="line">        reverse(nums.begin() + idx2, nums.begin() + r + <span class="number">1</span>); <span class="comment">// 将从之前找到的较大元素到数组尾的所有元素翻转</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Permutation</tag>
      </tags>
  </entry>
  <entry>
    <title>301. Remove Invalid Parentheses</title>
    <url>/2020/11/22/301-Remove-Invalid-Parentheses/</url>
    <content><![CDATA[<p>time worst case O(n^2) “)a)a)a)a)a” 因为需要最后的结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        remove(s, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> sb, <span class="keyword">int</span> rb, <span class="keyword">char</span> lp, <span class="keyword">char</span> rp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">int</span> i = search(s, sb, lp, rp); i == s.length()) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">t</span><span class="params">(rbegin(s), rend(s))</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (lp == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                remove(t, <span class="number">0</span>, <span class="number">0</span>, rp, lp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rb; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == rp &amp;&amp; (j == rb || s[j] != s[j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    remove(s.substr(<span class="number">0</span>, j) + s.substr(j + <span class="number">1</span>), i, j, lp, rp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> b, <span class="keyword">char</span> lp, <span class="keyword">char</span> rp)</span> </span>&#123; <span class="comment">// 找到第一个不匹配的右括号</span></span><br><span class="line">        <span class="keyword">int</span> i = b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            cnt += (s[i] == rp) ? <span class="number">-1</span> : (s[i] == lp);</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        remove(s, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> sb, <span class="keyword">int</span> rb, <span class="keyword">char</span> lp, <span class="keyword">char</span> rp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = sb, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; cnt &gt;= <span class="number">0</span>) &#123; <span class="comment">// 遍历字符串直到找到第一个匹配不上的『右括号』</span></span><br><span class="line">            cnt += (s[i] == rp ? <span class="number">-1</span> : s[i] == lp); <span class="comment">// 注意字符串里可能还有非左右括号的字符</span></span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">0</span>) &#123; <span class="comment">// 如果没有匹配不上的『右括号』则翻转字符串尝试删除匹配不上的『左括号』</span></span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">t</span><span class="params">(rbegin(s), rend(s))</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (lp == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                remove(t, <span class="number">0</span>, <span class="number">0</span>, rp, lp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果两种case都已经尝试过了，则当前字符串已经全部匹配</span></span><br><span class="line">                res.push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当找到第一个匹配不上的『右括号』</span></span><br><span class="line">            --i; <span class="comment">// 先回退到这个匹配不上的『右括号』</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rb; j &lt;= i; ++j) &#123; <span class="comment">// 从上次删除过的位置开始一直到当前这个匹配不上的为止，尝试删除『右括号』并拼成新字符串</span></span><br><span class="line">                <span class="keyword">if</span> (s[j] == rp &amp;&amp; (j == rb || s[j - <span class="number">1</span>] != s[j])) &#123; <span class="comment">// 跳过连续『右括号』去重</span></span><br><span class="line">                    remove(s.substr(<span class="number">0</span>, j) + s.substr(j + <span class="number">1</span>), i, j, lp, rp); <span class="comment">// 下个iteration的删除要从这次删除的位置j开始</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(2^n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123; <span class="comment">// 先统计需要删除几个左括号和右括号（无法匹配）</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                l &gt; <span class="number">0</span> ? --l : ++r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(s, <span class="number">0</span>, l, r);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> b, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span>) &#123; <span class="comment">// 如果多余的左括号和右括号都已经删除</span></span><br><span class="line">            <span class="keyword">if</span> (isValid(s)) <span class="comment">// 判断当前的字符串是否合法（因为是盲删的所以可能得到的字符串不合法）</span></span><br><span class="line">                res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; b &amp;&amp; s[i - <span class="number">1</span>] == s[i]) <span class="keyword">continue</span>; <span class="comment">// 去重，比如连续两个右括号，删一个即可</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> &amp;&amp; l &gt; <span class="number">0</span>) &#123; <span class="comment">// 盲删左括号</span></span><br><span class="line">                helper(s.substr(<span class="number">0</span>, i) + s.substr(i + <span class="number">1</span>), i, l - <span class="number">1</span>, r); <span class="comment">// 从i开始也是一种去重</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; r &gt; <span class="number">0</span>) &#123; <span class="comment">// 盲删右括号</span></span><br><span class="line">                helper(s.substr(<span class="number">0</span>, i) + s.substr(i + <span class="number">1</span>), i, l, r - <span class="number">1</span>); <span class="comment">// 切记不要用s.erase因为是循环删除，所以前面删除以后会影响后边</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--cnt &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Parentheses</tag>
      </tags>
  </entry>
  <entry>
    <title>311. Sparse Matrix Multiplication</title>
    <url>/2020/12/02/311-Sparse-Matrix-Multiplication/</url>
    <content><![CDATA[<p>考点是如何优化空间跟时间<br>mxn * nxp =&gt; mxp<br>A[i][j] * t[j][k] 累加到 res[i][k]<br>思路是遍历A，对每个非零A[i][j]，进行上述累加操作<br>普通矩阵乘法则是以最后结果矩阵为遍历顺序做点积运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; multiply(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; B) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = size(A), n = size(B), p = size(B[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; t(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (B[i][j]) &#123;</span><br><span class="line">                    t[i].emplace_back(j, B[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(p));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : t[j]) &#123;</span><br><span class="line">                    res[i][k] += A[i][j] * v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先把矩阵B变成邻接表C，记录每个元素的列号<br>因为res[i][j]是A的第i行和B的第j列的点积，所以只需要遍历矩阵A<br>将A[i][k]和C[k]（即原来B的第k行的所有非0元素）的每个元素相乘并累加到对应的res[i][j]上即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; multiply(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; B) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.size(), n = B.size(), p = B[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; C(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (B[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    C[i].emplace_back(j, B[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(p));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i][k] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> [j, val] : C[k]) &#123;</span><br><span class="line">                        res[i][j] += A[i][k] * val; <span class="comment">// res[i][j]A的第i行和B的第j列的点积</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>314. Binary Tree Vertical Order Traversal</title>
    <url>/2020/11/28/314-Binary-Tree-Vertical-Order-Traversal/</url>
    <content><![CDATA[<p>bfs O(n) time 给每个node一个伪下标并维护最小最大下标，最后利用最小下标来还原真实下标<br>必须自顶向下自左向右 dfs如果不维护行号会违反 bfs完美符合不用维护行号只需要把每个数放到对应column即可所以选择bfs 即排序优先级是左右上下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; verticalOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, TreeNode *&gt;&gt; v;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, TreeNode *&gt;&gt; q;</span><br><span class="line">        q.emplace(<span class="number">0</span>, root);</span><br><span class="line">        <span class="keyword">int</span> mn = INT_MAX, mx = INT_MIN;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [idx, x] = q.front(); q.pop();</span><br><span class="line">            v.emplace_back(idx, x);</span><br><span class="line">            mn = min(mn, idx);</span><br><span class="line">            mx = max(mx, idx);</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;left) &#123;</span><br><span class="line">                q.emplace(idx - <span class="number">1</span>, x-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;right) &#123;</span><br><span class="line">                q.emplace(idx + <span class="number">1</span>, x-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(mx - mn + <span class="number">1</span>); <span class="comment">// 利用最大最小下标提前分配内存</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [idx, x] : v) &#123;</span><br><span class="line">            res[idx - mn].push_back(x-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; verticalOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;TreeNode *&gt;&gt; m;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, TreeNode *&gt;&gt; q;</span><br><span class="line">        q.emplace(<span class="number">0</span>, root);</span><br><span class="line">        <span class="keyword">int</span> mn = INT_MAX, mx = INT_MIN;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">int</span> idx = p.first;</span><br><span class="line">            <span class="keyword">auto</span> x = p.second;</span><br><span class="line">            m[idx].push_back(x);</span><br><span class="line">            mn = min(mn, idx);</span><br><span class="line">            mx = max(mx, idx);</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;left) &#123;</span><br><span class="line">                q.emplace(idx - <span class="number">1</span>, x-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;right) &#123;</span><br><span class="line">                q.emplace(idx + <span class="number">1</span>, x-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(mx - mn + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mn; i &lt;= mx; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> x : m[i]) &#123;</span><br><span class="line">                res[i - mn].push_back(x-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Vertical order traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>317. Shortest Distance from All Buildings</title>
    <url>/2020/12/01/317-Shortest-Distance-from-All-Buildings/</url>
    <content><![CDATA[<p>O(m*n*b) time O(m*n) space<br>思路很直白 遍历每个房子 对每个房子bfs 累加每个空地到每个房子的距离 要找的是一个可以reach所有房子的空地（前提是房子少空地多，否则就要对每个空地bfs）<br>这道题最重要的corner case是有的房子reach不到所有的空地<br>下面这个方法比较tricky但是省空间且不需要最后的遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty() || grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; s(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    res = bfs(s, grid, cnt--, i, j, m, n); <span class="comment">// cnt其实就是房子的个数</span></span><br><span class="line">                    <span class="keyword">if</span> (res == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 有任何一个房子不能reach到所有空地，直接返回-1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> cnt, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.emplace(i, j);</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span>, res = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = q.size(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [ui, uj] = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">4</span>; ++p) &#123;</span><br><span class="line">                    <span class="keyword">int</span> vi = ui + di[p];</span><br><span class="line">                    <span class="keyword">int</span> vj = uj + dj[p];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= vi &amp;&amp; vi &lt; m &amp;&amp; <span class="number">0</span> &lt;= vj &amp;&amp; vj &lt; n &amp;&amp; cnt == grid[vi][vj]) &#123; <span class="comment">// 只有当前空地的计数器等于之前遍历过的所有房子的个数才有可能对res进行更新，如果之前有某个房子不能reach到，则当前空地的计数器一定和cnt不等；如果当前房子是reach不到的则res也不会更新，因为res会被overwritten，所以如果有一个房子reach不到，那么res会被改成INT_MAX并且之后再遍历的所有房子都不会再更新res</span></span><br><span class="line">                        grid[vi][vj] = cnt - <span class="number">1</span>;</span><br><span class="line">                        s[vi][vj] += d;</span><br><span class="line">                        q.emplace(vi, vj);</span><br><span class="line">                        res = min(res, s[vi][vj]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> di[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dj[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty() || grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; s(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n)), cnt = s; <span class="comment">// s用来累加每个空地到其他房子的距离，cnt用来统计每个空地能有多少个房子reach</span></span><br><span class="line">        <span class="keyword">int</span> color = <span class="number">0</span>; <span class="comment">// color用来给grid里的空地着色，避免重复访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    bfs(s, grid, cnt, --color, i, j, m, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i][j] &gt; <span class="number">0</span> &amp;&amp; cnt[i][j] + color == <span class="number">0</span>) &#123; <span class="comment">// 如果存在一个空地可以reach所有房子，s[i][j] &gt; 0说明是空地，cnt[i][j] + color == 0说明可以reach所有房子</span></span><br><span class="line">                    res = min(res, s[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">-1</span> : res; <span class="comment">// 如果不存在能reach所有房子的空地</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;cnt, <span class="keyword">int</span> color, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.emplace(i, j);</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = q.size(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="keyword">auto</span> u = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">4</span>; ++p) &#123;</span><br><span class="line">                    <span class="keyword">int</span> vi = u.first + di[p];</span><br><span class="line">                    <span class="keyword">int</span> vj = u.second + dj[p];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= vi &amp;&amp; vi &lt; m &amp;&amp; <span class="number">0</span> &lt;= vj &amp;&amp; vj &lt; n &amp;&amp; color &lt; grid[vi][vj] &amp;&amp; grid[vi][vj] &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                        grid[vi][vj] = color;</span><br><span class="line">                        s[vi][vj] += d;</span><br><span class="line">                        q.emplace(vi, vj);</span><br><span class="line">                        ++cnt[vi][vj];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> di[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dj[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>32. Longest Valid Parentheses</title>
    <url>/2020/06/01/32-Longest-Valid-Parentheses/</url>
    <content><![CDATA[<p>stack O(n) time O(n) space<br>所有匹配的括号都出栈了，栈里剩下的都是匹配不上的，所以两个匹配不上的括号之间的就是匹配上的括号串，统计最长的可以匹配上的括号串的长度即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">-1</span>&#125;; <span class="comment">// 开始加入-1方便后面计算，比如&quot;()()())&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123; <span class="comment">// 如果是&quot;(&quot;，直接把下标入栈</span></span><br><span class="line">                v.push_back(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (v.back() != <span class="number">-1</span> &amp;&amp; s[v.back()] == <span class="string">&#x27;(&#x27;</span>) &#123; <span class="comment">// 如果是&quot;)&quot;，并且栈不为『空』或者栈顶是&quot;(&quot;，证明有正确的匹配，将栈顶的&quot;(&quot;的下标出栈</span></span><br><span class="line">                    v.pop_back();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则证明是一个孤立无法匹配的&quot;)&quot;，将下标入栈</span></span><br><span class="line">                    v.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v.push_back(n); <span class="comment">// 最后入栈一个结尾长度下标，方便计算，比如&quot;)()()&quot;</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.size(); ++i) &#123;</span><br><span class="line">            res = max(res, v[i] - v[i - <span class="number">1</span>] - <span class="number">1</span>); <span class="comment">// 只需要检查前后两个不匹配的括号之前的距离便可以找到最长的合法匹配的括号的长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>进一步优化，不需要最后再扫一遍，每次找到一个合法匹配就可以直接更新res</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        stk, res = [-<span class="number">1</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stk.append(i)</span><br><span class="line">            <span class="keyword">elif</span> stk[-<span class="number">1</span>] &gt;= <span class="number">0</span> <span class="keyword">and</span> s[stk[-<span class="number">1</span>]] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stk.pop()</span><br><span class="line">                res = <span class="built_in">max</span>(res, i - stk[-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stk.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk&#123;&#123;<span class="number">-1</span>&#125;&#125;; <span class="comment">// 开始加入-1方便后面计算，比如&quot;()()())&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123; <span class="comment">// 如果是&quot;(&quot;，直接把下标入栈</span></span><br><span class="line">                stk.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stk.top() != <span class="number">-1</span> &amp;&amp; s[stk.top()] == <span class="string">&#x27;(&#x27;</span>) &#123; <span class="comment">// 如果是&quot;)&quot;，并且栈不为『空』或者栈顶是&quot;(&quot;，证明有正确的匹配，将栈顶的&quot;(&quot;的下标出栈</span></span><br><span class="line">                stk.pop(); <span class="comment">// 一定要先出栈再更新res</span></span><br><span class="line">                res = max(res, i - stk.top()); <span class="comment">// 当前是一个合法的匹配，更新res</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则证明是一个孤立无法匹配的&quot;)&quot;，将下标入栈</span></span><br><span class="line">                stk.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>323. Number of Connected Components in an Undirected Graph</title>
    <url>/2020/12/13/323-Number-of-Connected-Components-in-an-Undirected-Graph/</url>
    <content><![CDATA[<p>union-find O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countComponents</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        parent.resize(n);</span><br><span class="line">        iota(begin(parent), end(parent), <span class="number">0</span>);</span><br><span class="line">        res = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;e : edges) &#123;</span><br><span class="line">            merge(e.first, e.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">            x = parent[x] = parent[parent[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> px = find(x);</span><br><span class="line">        <span class="keyword">int</span> py = find(y);</span><br><span class="line">        <span class="keyword">if</span> (px != py) &#123;</span><br><span class="line">            parent[px] = py;</span><br><span class="line">            --res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Graph</tag>
        <tag>Union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>33. Search in Rotated Sorted Array</title>
    <url>/2020/06/01/33-Search-in-Rotated-Sorted-Array/</url>
    <content><![CDATA[<p>binary search O(logn)<br>先判断左半边数多还是右半边数多，再对每一种情况分类讨论</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r):</span><br><span class="line">            m = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">elif</span> nums[m] &gt; nums[r]:</span><br><span class="line">                <span class="keyword">if</span> nums[l] &lt;= target &lt; nums[m]:</span><br><span class="line">                    r = m - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[m] &lt; target &lt;= nums[r]:</span><br><span class="line">                    l = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123; <span class="comment">// 这道题是要找数，所以要=</span></span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[mid]) &#123; <span class="comment">// 找到直接返回</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[r]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123; <span class="comment">// 检查是否在单调区间</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>339. Nested List Weight Sum</title>
    <url>/2020/11/30/339-Nested-List-Weight-Sum/</url>
    <content><![CDATA[<p>bfs O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></span><br><span class="line"><span class="comment"> *     NestedInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></span><br><span class="line"><span class="comment"> *     NestedInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></span><br><span class="line"><span class="comment"> *     void setInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"><span class="comment"> *     void add(const NestedInteger &amp;ni);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!nestedList.empty()) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;NestedInteger&gt; nextLevel;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;ni : nestedList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ni.isInteger()) &#123;</span><br><span class="line">                    res += ni.getInteger() * depth;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextLevel.insert(end(nextLevel), begin(ni.getList()), end(ni.getList()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nestedList.swap(nextLevel);</span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></span><br><span class="line"><span class="comment"> *     NestedInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></span><br><span class="line"><span class="comment"> *     NestedInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></span><br><span class="line"><span class="comment"> *     void setInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"><span class="comment"> *     void add(const NestedInteger &amp;ni);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">list</span>&lt;NestedInteger&gt; <span class="title">q</span><span class="params">(begin(nestedList), end(nestedList))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = q.front(); q.pop_front();</span><br><span class="line">                <span class="keyword">if</span> (x.isInteger()) &#123;</span><br><span class="line">                    res += x.getInteger() * depth;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    q.insert(end(q), begin(x.getList()), end(x.getList()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></span><br><span class="line"><span class="comment"> *     NestedInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></span><br><span class="line"><span class="comment"> *     NestedInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></span><br><span class="line"><span class="comment"> *     void setInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"><span class="comment"> *     void add(const NestedInteger &amp;ni);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;NestedInteger&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;ni : nestedList) &#123;</span><br><span class="line">            q.push(ni);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, depth = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (x.isInteger()) &#123;</span><br><span class="line">                    res += x.getInteger() * depth;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;ni : x.getList()) &#123;</span><br><span class="line">                        q.push(ni);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dfs</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></span><br><span class="line"><span class="comment"> *     NestedInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></span><br><span class="line"><span class="comment"> *     NestedInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></span><br><span class="line"><span class="comment"> *     void setInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"><span class="comment"> *     void add(const NestedInteger &amp;ni);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(nestedList, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;ni : nestedList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ni.isInteger()) &#123;</span><br><span class="line">                res += ni.getInteger() * depth;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += dfs(ni.getList(), depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Implementation</tag>
        <tag>Depth first search</tag>
        <tag>Level order traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>34. Find First and Last Position of Element in Sorted Array</title>
    <url>/2020/06/01/34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/</url>
    <content><![CDATA[<p>O(logn) time</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">b, e, t</span>):</span></span><br><span class="line">            <span class="keyword">while</span> b &lt; e:</span><br><span class="line">                m = b + (e - b) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[m] &lt; t:</span><br><span class="line">                    b = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    e = m</span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        l = find(<span class="number">0</span>, n, target)</span><br><span class="line">        <span class="keyword">if</span> l == n <span class="keyword">or</span> nums[l] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> [l, find(l + <span class="number">1</span>, n, target + <span class="number">1</span>) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = lb(nums, <span class="number">0</span>, n, target);</span><br><span class="line">        <span class="keyword">if</span> (i == n || nums[i] != target) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;i, lb(nums, i, n, target + <span class="number">1</span>) - <span class="number">1</span>&#125;; <span class="comment">// 找大一号的数即可，且可以从下界找起</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> lb = lower_bound(begin(nums), end(nums), target);</span><br><span class="line">        <span class="keyword">if</span> (lb == end(nums) || *lb != target) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> ub = upper_bound(begin(nums), end(nums), target);</span><br><span class="line">        <span class="keyword">return</span> &#123;lb - begin(nums), ub - <span class="number">1</span> - begin(nums)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>297. Serialize and Deserialize Binary Tree</title>
    <url>/2020/11/26/297-Serialize-and-Deserialize-Binary-Tree/</url>
    <content><![CDATA[<p>O(n) BFS<br>“1 2 3 # # 4 5 # # # # “</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> n = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (n) &#123;</span><br><span class="line">                res += to_string(n-&gt;val);</span><br><span class="line">                q.push(n-&gt;left);</span><br><span class="line">                q.push(n-&gt;right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="function">TreeNode <span class="title">dummy_root</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">bool</span>, TreeNode *&gt;&gt; q&#123;&#123;&#123;<span class="literal">true</span>, &amp;dummy_root&#125;&#125;&#125;;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">while</span> (input &gt;&gt; s) &#123;</span><br><span class="line">            TreeNode *n = (s == <span class="string">&quot;#&quot;</span> ? <span class="literal">nullptr</span> : <span class="keyword">new</span> TreeNode(stoi(s)));</span><br><span class="line">            <span class="keyword">if</span> (q.front().first) &#123;</span><br><span class="line">                q.front().second-&gt;right = n;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                q.front().second-&gt;left = n;</span><br><span class="line">                q.front().first = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n) &#123; <span class="comment">// 这里要检查是否是空指针，因为要对queue里的指针设左右子树，不能出现空指针</span></span><br><span class="line">                q.emplace(<span class="literal">false</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>
<p>preorder dfs<br>“1 2 # # 3 4 # # 5 # # “</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root ? to_string(root-&gt;val) + <span class="string">&quot; &quot;</span> + serialize(root-&gt;left) + serialize(root-&gt;right) : <span class="string">&quot;# &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> deserialize(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">deserialize</span><span class="params">(<span class="built_in">istringstream</span> &amp;input)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">if</span> (input &gt;&gt; s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="string">&quot;#&quot;</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">auto</span> res = <span class="keyword">new</span> TreeNode(stoi(s));</span><br><span class="line">            res-&gt;left = deserialize(input);</span><br><span class="line">            res-&gt;right = deserialize(input);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Depth first search</tag>
        <tag>Preorder traversal</tag>
        <tag>Serialization</tag>
      </tags>
  </entry>
  <entry>
    <title>340. Longest Substring with At Most K Distinct Characters</title>
    <url>/2020/11/28/340-Longest-Substring-with-At-Most-K-Distinct-Characters/</url>
    <content><![CDATA[<p>O(n) time O(26) space<br>是<a href="https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/">159. Longest Substring with At Most Two Distinct Characters
</a>的follow-up</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            ++m[s[r]];</span><br><span class="line">            <span class="keyword">while</span> (m.size() &gt; k) &#123; <span class="comment">// 注意k有可能为0</span></span><br><span class="line">                <span class="keyword">if</span> (--m[s[l]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    m.erase(s[l]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, r + <span class="number">1</span> - l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>lee的做法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; n; ++r) &#123;</span><br><span class="line">            ++m[s[r]];</span><br><span class="line">            <span class="keyword">if</span> (m.size() &gt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--m[s[l]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    m.erase(s[l]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>347. Top K Frequent Elements</title>
    <url>/2020/12/05/347-Top-K-Frequent-Elements/</url>
    <content><![CDATA[<p>O(n+k) time O(n) space<br>bucket sort</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            ++f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = size(nums);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [x, v] : f) &#123;</span><br><span class="line">            m[v].push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x : m[i]) &#123;</span><br><span class="line">                res.push_back(x);</span><br><span class="line">                <span class="keyword">if</span> (res.size() == k) <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>quick selection</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            ++m[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v(begin(m), end(m));</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;a, <span class="keyword">const</span> <span class="keyword">auto</span> &amp;b)&#123; <span class="keyword">return</span> a.second &gt; b.second; &#125;;</span><br><span class="line">        nth_element(begin(v), begin(v) + k, end(v), cmp); <span class="comment">// k或k - 1都行</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            res.push_back(v[i].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Quickselect</tag>
        <tag>Bucket sort</tag>
      </tags>
  </entry>
  <entry>
    <title>35. Search Insert Position</title>
    <url>/2020/06/01/35-Search-Insert-Position/</url>
    <content><![CDATA[<p>O(logn) time<br>找lower_bound</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) <span class="comment"># 注意直接用左闭右开！！</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = m</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n; <span class="comment">// 直接用左闭右开</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[m]) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[m]) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>333. Largest BST Subtree</title>
    <url>/2020/12/06/333-Largest-BST-Subtree/</url>
    <content><![CDATA[<p>O(n) time O(h) space<br>postorder traversal</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestBSTSubtree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get&lt;<span class="number">0</span>&gt;(dfs(root));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tuple&lt;int, int, int&gt; dfs(TreeNode *p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span> &#123;<span class="number">0</span>, INT_MAX, INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">auto</span> [ln, lmn, lmx] = dfs(p-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> [rn, rmn, rmx] = dfs(p-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (lmx &gt;= p-&gt;val || rmn &lt;= p-&gt;val) <span class="keyword">return</span> &#123;max(ln, rn), INT_MIN, INT_MAX&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;ln + <span class="number">1</span> + rn, min(lmn, p-&gt;val), max(rmx, p-&gt;val)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestBSTSubtree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ret = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ret[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dfs</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;INT_MAX, INT_MIN, <span class="number">0</span>&#125;; <span class="comment">// &#123;最小值，最大值，以root为根的这棵树的最大BST子树的结点数&#125;</span></span><br><span class="line">        <span class="keyword">auto</span> l = dfs(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> r = dfs(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (l[<span class="number">1</span>] &lt; root-&gt;val &amp;&amp; root-&gt;val &lt; r[<span class="number">0</span>]) <span class="keyword">return</span> &#123;min(l[<span class="number">0</span>], root-&gt;val), max(root-&gt;val, r[<span class="number">1</span>]), l[<span class="number">2</span>] + r[<span class="number">2</span>] + <span class="number">1</span>&#125;; <span class="comment">// 这里最小值和最大值都要把root考虑进去</span></span><br><span class="line">        <span class="keyword">return</span> &#123;INT_MIN, INT_MAX, max(l[<span class="number">2</span>], r[<span class="number">2</span>])&#125;; <span class="comment">// 如果这棵树不是BST，左右子可能有一个是BST，不是的话也会把那棵子树上最大的BST的结点数返回给上一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Postorder traversal</tag>
        <tag>Binary search tree</tag>
      </tags>
  </entry>
  <entry>
    <title>36. Valid Sudoku</title>
    <url>/2020/06/01/36-Valid-Sudoku/</url>
    <content><![CDATA[<p>O(1) time O(1) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]]</span>) -&gt; bool:</span></span><br><span class="line">        v = [[<span class="literal">False</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        h = [[<span class="literal">False</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        b = [[<span class="literal">False</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        <span class="comment"># v = [[False] * 10 for _ in range(9)]</span></span><br><span class="line">        <span class="comment"># h, b = deepcopy(v), deepcopy(v)</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                x = board[r][c]</span><br><span class="line">                <span class="keyword">if</span> x != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    x = <span class="built_in">int</span>(x) <span class="comment"># 巧妙！</span></span><br><span class="line">                    <span class="keyword">if</span> v[c][x] <span class="keyword">or</span> h[r][x] <span class="keyword">or</span> b[r // <span class="number">3</span> * <span class="number">3</span> + c // <span class="number">3</span>][x]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    v[c][x] = h[r][x] = b[r // <span class="number">3</span> * <span class="number">3</span> + c // <span class="number">3</span>][x] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>用bitset替代hashtable遍历找重复即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">bitset</span>&lt;9&gt;&gt; h(<span class="number">9</span>), v(<span class="number">9</span>), s(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r(<span class="number">0</span>); r &lt; <span class="number">9</span>; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c(<span class="number">0</span>); c &lt; <span class="number">9</span>; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[r][c] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> x = board[r][c] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (h[r][x] || v[c][x] || s[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][x]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                h[r][x] = v[c][x] = s[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][x] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>37. Sudoku Solver</title>
    <url>/2020/06/10/37-Sudoku-Solver/</url>
    <content><![CDATA[<p>backtracking<br>预处理board把每个cell能算出来的都填上，再跑backtracking试数<br>先写backtracking，再写预处理优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        row.resize(<span class="number">9</span>);</span><br><span class="line">        col.resize(<span class="number">9</span>);</span><br><span class="line">        sub.resize(<span class="number">9</span>);</span><br><span class="line">        s.resize(<span class="number">81</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">9</span>; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">9</span>; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[r][c] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = board[r][c] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    row[r][i] = col[c][i] = sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> change = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            change = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">9</span>; ++r) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">9</span>; ++c) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (board[r][c] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!row[r][i] &amp;&amp; !col[c][i] &amp;&amp; !sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i]) &#123;</span><br><span class="line">                                s[r * <span class="number">9</span> + c].insert(i);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (s[r * <span class="number">9</span> + c].size() == <span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="keyword">int</span> i = *s[r * <span class="number">9</span> + c].begin();</span><br><span class="line">                            board[r][c] = <span class="string">&#x27;0&#x27;</span> + i;</span><br><span class="line">                            ++change;</span><br><span class="line">                            row[r][i] = col[c][i] = sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (change &gt; <span class="number">0</span>);</span><br><span class="line">        dfs(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;b, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">81</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> r = idx / <span class="number">9</span>, c = idx % <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">if</span> (b[r][c] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> dfs(b, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : s[idx]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row[r][i] || col[c][i] || sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i]) <span class="keyword">continue</span>;</span><br><span class="line">            b[r][c] = <span class="string">&#x27;0&#x27;</span> + i;</span><br><span class="line">            row[r][i] = col[c][i] = sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (dfs(b, idx + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            row[r][i] = col[c][i] = sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b[r][c] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// revert</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">bitset</span>&lt;10&gt;&gt; row, col, sub;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; s; <span class="comment">// 对每个位置来说所有可能的数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>没有预处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        h = [[<span class="literal">False</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        v = [[<span class="literal">False</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        s = [[<span class="literal">False</span>] * <span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                x = board[r][c]</span><br><span class="line">                <span class="keyword">if</span> x != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    x = <span class="built_in">int</span>(x)</span><br><span class="line">                    h[r][x] = v[c][x] = s[r // <span class="number">3</span> * <span class="number">3</span> + c // <span class="number">3</span>][x] = <span class="literal">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">idx</span>):</span></span><br><span class="line">            <span class="keyword">if</span> idx == <span class="number">81</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            r, c = <span class="built_in">divmod</span>(idx, <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">if</span> board[r][c] != <span class="string">&#x27;.&#x27;</span>: <span class="keyword">return</span> dfs(idx + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span> h[r][x] <span class="keyword">or</span> v[c][x] <span class="keyword">or</span> s[r // <span class="number">3</span> * <span class="number">3</span> + c // <span class="number">3</span>][x]: <span class="keyword">continue</span></span><br><span class="line">                board[r][c] = <span class="built_in">str</span>(x)</span><br><span class="line">                h[r][x] = v[c][x] = s[r // <span class="number">3</span> * <span class="number">3</span> + c // <span class="number">3</span>][x] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> dfs(idx + <span class="number">1</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                h[r][x] = v[c][x] = s[r // <span class="number">3</span> * <span class="number">3</span> + c // <span class="number">3</span>][x] = <span class="literal">False</span></span><br><span class="line">                board[r][c] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        row.resize(<span class="number">9</span>);</span><br><span class="line">        col.resize(<span class="number">9</span>);</span><br><span class="line">        sub.resize(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">9</span>; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">9</span>; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[r][c] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = board[r][c] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    row[r][i] = col[c][i] = sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;b, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="number">81</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> r = idx / <span class="number">9</span>, c = idx % <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">if</span> (b[r][c] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> dfs(b, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row[r][i] || col[c][i] || sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i]) <span class="keyword">continue</span>;</span><br><span class="line">            b[r][c] = <span class="string">&#x27;0&#x27;</span> + i;</span><br><span class="line">            row[r][i] = col[c][i] = sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (dfs(b, idx + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            row[r][i] = col[c][i] = sub[r / <span class="number">3</span> * <span class="number">3</span> + c / <span class="number">3</span>][i] = <span class="literal">false</span>;</span><br><span class="line">						b[r][c] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">bitset</span>&lt;10&gt;&gt; row, col, sub;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>378. Kth Smallest Element in a Sorted Matrix</title>
    <url>/2020/11/30/378-Kth-Smallest-Element-in-a-Sorted-Matrix/</url>
    <content><![CDATA[<p>bisection O(nlognlogD) time where D是最大最小值之差<br>用这个二分猜数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> lo = matrix[<span class="number">0</span>][<span class="number">0</span>], hi = matrix[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;v : matrix) &#123; <span class="comment">// 统计所有不大于m的数的个数</span></span><br><span class="line">                cnt += (upper_bound(v.begin(), v.end(), m) - v.begin());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; k) &#123; <span class="comment">// 如果不大于m（包括m）的数不到k个，说明m不是最终结果</span></span><br><span class="line">                lo = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O((n+n<sup>2</sup>-k)logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;lhs, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.first &lt; rhs.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> target = matrix.size() * matrix.size() - k;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, cmp&gt; heap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; matrix.size(); ++row) &#123;</span><br><span class="line">            heap.push(<span class="built_in">make_pair</span>(matrix[row].back(), row));</span><br><span class="line">            matrix[row].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">            <span class="keyword">if</span> (!matrix[p.second].empty()) &#123;</span><br><span class="line">                heap.push(<span class="built_in">make_pair</span>(matrix[p.second].back(), p.second));</span><br><span class="line">                matrix[p.second].pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap.top().first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n<sup>3</sup>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = matrix.size() * matrix.size() - k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> max_num = INT_MIN;</span><br><span class="line">            <span class="keyword">int</span> max_row = matrix.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> row = matrix.size() - <span class="number">1</span>; row &gt;= <span class="number">0</span>; --row) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!matrix[row].empty() &amp;&amp; matrix[row].back() &gt; max_num) &#123;</span><br><span class="line">                    max_num = matrix[row].back();</span><br><span class="line">                    max_row = row;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == size - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> matrix[max_row].back();</span><br><span class="line">            matrix[max_row].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
        <tag>Merging</tag>
      </tags>
  </entry>
  <entry>
    <title>38. Count and Say</title>
    <url>/2020/06/10/38-Count-and-Say/</url>
    <content><![CDATA[<p>sliding window</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        res = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            s, i, j, n = <span class="string">&#x27;&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="built_in">len</span>(res)</span><br><span class="line">            <span class="keyword">while</span> i &lt; n:</span><br><span class="line">                <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> res[j] == res[i]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                s += <span class="built_in">str</span>(j - i) + res[i]</span><br><span class="line">                i = j</span><br><span class="line">            res = s</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cas</span>(<span class="params">s</span>):</span></span><br><span class="line">            res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            i, j, n = <span class="number">0</span>, <span class="number">1</span>, <span class="built_in">len</span>(s)</span><br><span class="line">            <span class="keyword">while</span> i &lt; n:</span><br><span class="line">                <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> s[j] == s[i]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                res += <span class="built_in">str</span>(j - i) + s[i]</span><br><span class="line">                i = j</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        res = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            res = cas(res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res = helper(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>, j = i;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n &amp;&amp; s[j] == c; ++j) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            res += to_string(cnt);</span><br><span class="line">            res += c;</span><br><span class="line">            i = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res = helper(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        s += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span> prev = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != prev) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res += to_string(i - b);</span><br><span class="line">                    res += prev;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = s[i];</span><br><span class="line">                b = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>iterative</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 要从1开始，因为0已经数过了</span></span><br><span class="line">            res += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            <span class="keyword">int</span> len = res.length() - <span class="number">1</span>; <span class="comment">// 不需要看最后一个#字符</span></span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">// cnt要从1开始，因为每次res[i] != res[i + 1]的时候会少做一次cnt++</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res[i] == res[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s += to_string(cnt) + res[i];</span><br><span class="line">                    cnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(res, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            <span class="keyword">char</span> prev = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> len = res.length();</span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res[i] != prev) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i - b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        s += to_string(i - b);</span><br><span class="line">                        s += prev;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = res[i];</span><br><span class="line">                    b = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(res, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>39. Combination Sum</title>
    <url>/2020/06/10/39-Combination-Sum/</url>
    <content><![CDATA[<p>backtracking<br>如果问个数就是背包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res, A = [], []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">b, s</span>):</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">                res.append(A[:]) <span class="comment"># 注意要copy!!!</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(b, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                x = candidates[i]</span><br><span class="line">                <span class="keyword">if</span> x &gt; s:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                A.append(x)</span><br><span class="line">                dfs(i, s - x)</span><br><span class="line">                A.pop()</span><br><span class="line">        dfs(<span class="number">0</span>, target)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">b, s, A</span>):</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">                res.append(A)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(b, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                x = candidates[i]</span><br><span class="line">                <span class="keyword">if</span> x &gt; s:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                dfs(i, s - x, A + [x]) <span class="comment"># 会触发copy</span></span><br><span class="line">        dfs(<span class="number">0</span>, target, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sort(begin(candidates), end(candidates)); <span class="comment">// 用来加速和去重</span></span><br><span class="line">        dfs(candidates, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> b, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; candidates.size() &amp;&amp; candidates[i] &lt;= target; ++i) &#123; <span class="comment">// 注意candidates &lt;= target</span></span><br><span class="line">            v.push_back(candidates[i]); <span class="comment">// 尝试寻找以candidates[i]开头的可行解</span></span><br><span class="line">            dfs(candidates, i, target - candidates[i]);</span><br><span class="line">            v.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
        <tag>Combination</tag>
      </tags>
  </entry>
  <entry>
    <title>394. Decode String</title>
    <url>/2020/12/13/394-Decode-String/</url>
    <content><![CDATA[<p>O(n) stack</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123; <span class="comment">// 遇到数字直接把整个数拼出来</span></span><br><span class="line">                <span class="keyword">int</span> x = <span class="number">0</span>, j = i;</span><br><span class="line">                <span class="keyword">for</span> (; j &lt; s.length() &amp;&amp; <span class="built_in">isdigit</span>(s[j]); ++j) &#123;</span><br><span class="line">                    x = x * <span class="number">10</span> + s[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nums.push(x);</span><br><span class="line">                i = j - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">string</span> t;</span><br><span class="line">                <span class="keyword">while</span> (res.back() != <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                    t += res.back();</span><br><span class="line">                    res.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                res.pop_back(); <span class="comment">// [出栈</span></span><br><span class="line">                reverse(begin(t), end(t));</span><br><span class="line">                <span class="keyword">while</span> (nums.top()-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res += t;</span><br><span class="line">                &#125;</span><br><span class="line">                nums.pop(); <span class="comment">// 数出栈</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 字母和[直接压栈</span></span><br><span class="line">                res += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n) DFS<br>用这个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> &amp;i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = s.length(); i &lt; n &amp;&amp; s[i] != <span class="string">&#x27;]&#x27;</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (; i &lt; n &amp;&amp; <span class="built_in">isdigit</span>(s[i]); ++i) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">auto</span> t = helper(s, ++i); <span class="comment">// 跳过[</span></span><br><span class="line">                <span class="keyword">while</span> (num-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res += t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> &amp;i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; s[i] != <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + s[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; <span class="built_in">isdigit</span>(s[i]));</span><br><span class="line">                <span class="built_in">string</span> t = helper(s, ++i);</span><br><span class="line">                ++i; <span class="comment">// 因为helper完最后i会指向上一个]所以需要跳过，放到while循环完最后加也可以</span></span><br><span class="line">                <span class="keyword">while</span> (num-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ret += t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ret += s[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Stack</tag>
        <tag>Calculator</tag>
      </tags>
  </entry>
  <entry>
    <title>398. Random Pick Index</title>
    <url>/2020/11/29/398-Random-Pick-Index/</url>
    <content><![CDATA[<p>reservoir sampling O(n) time O(n) space<br>大小为1的水塘采样<br>從S中抽取首k項放入「水塘」中<br>對於每一個S[j]項（j ≥ k）：<br>   隨機產生一個範圍從0到j的整數r<br>   若 r &lt; k 則把水塘中的第r項換成S[j]項<br>这道题里的k为1，所以目标随机下标r为0<br>证明：假设最后一个被选中的是i，则i之前是否选中不重要，概率乘积为1，之后都不能被选中，假设target共有n个，则i被选中的概率为1/i * i/(i + 1) * … * (n - 1)/n = 1/n</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums) : nums(move(nums)) &#123;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != target) <span class="keyword">continue</span>; <span class="comment">// 跳过所有的非目标，采样跟他们无关</span></span><br><span class="line">            <span class="keyword">if</span> (rand() % ++count == <span class="number">0</span>) &#123; <span class="comment">// 遇到目标时随机一次，这样采样数据源只包括所有的目标</span></span><br><span class="line">                res = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.pick(target);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) : b(begin(nums)), e(end(nums)) &#123;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = b; it != e; ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*it != target) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (rand() % ++count == <span class="number">0</span>) &#123;</span><br><span class="line">                res = distance(b, it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator b, e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.pick(target);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Reservoir sampling</tag>
      </tags>
  </entry>
  <entry>
    <title>4. Median of Two Sorted Arrays</title>
    <url>/2020/05/30/4-Median-of-Two-Sorted-Arrays/</url>
    <content><![CDATA[<p>二分法O(log(m+n))<br><a href="http://www.cnblogs.com/grandyang/p/4465932.html">题解</a><br>把原题转换成给定两个排好序的数组，找出其中第k小的数（k是1-based）<br>复杂度计算：少1/4，少1/8，少1/16，直到逼近中位数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; float:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums1) + <span class="built_in">len</span>(nums2) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (self.findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, n // <span class="number">2</span>) + self.findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, (n + <span class="number">1</span>) // <span class="number">2</span>)) / <span class="number">2</span> <span class="comment">#必须要用self，跟MATLAB一样</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKth</span>(<span class="params">self, A: List[<span class="built_in">int</span>], b1: <span class="built_in">int</span>, B: List[<span class="built_in">int</span>], b2: <span class="built_in">int</span>, k</span>) -&gt; float:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(A) - b1, <span class="built_in">len</span>(B) - b2</span><br><span class="line">        <span class="keyword">if</span> m &gt; n: <span class="keyword">return</span> self.findKth(B, b2, A, b1, k)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>: <span class="keyword">return</span> B[b2 + k - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>: <span class="keyword">return</span> <span class="built_in">min</span>(A[b1], B[b2])</span><br><span class="line">        i, j = <span class="built_in">min</span>(k // <span class="number">2</span>, m), <span class="built_in">min</span>(k // <span class="number">2</span>, n)</span><br><span class="line">        <span class="keyword">if</span> A[b1 + i - <span class="number">1</span>] &lt; B[b2 + j - <span class="number">1</span>]: <span class="keyword">return</span> self.findKth(A, b1 + i, B, b2, k - i)</span><br><span class="line">        <span class="keyword">return</span> self.findKth(A, b1, B, b2 + j, k - j)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; float:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findKth</span>(<span class="params">A, b1, B, b2, k</span>):</span></span><br><span class="line">            m, n = <span class="built_in">len</span>(A) - b1, <span class="built_in">len</span>(B) - b2</span><br><span class="line">            <span class="keyword">if</span> m &gt; n: <span class="keyword">return</span> findKth(B, b2, A, b1, k)</span><br><span class="line">            <span class="keyword">if</span> m == <span class="number">0</span>: <span class="keyword">return</span> B[b2 + k - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">1</span>: <span class="keyword">return</span> <span class="built_in">min</span>(A[b1], B[b2])</span><br><span class="line">            i, j = <span class="built_in">min</span>(k // <span class="number">2</span>, m), <span class="built_in">min</span>(k // <span class="number">2</span>, n)</span><br><span class="line">            <span class="keyword">if</span> A[b1 + i - <span class="number">1</span>] &lt; B[b2 + j - <span class="number">1</span>]: <span class="keyword">return</span> findKth(A, b1 + i, B, b2, k - i)</span><br><span class="line">            <span class="keyword">return</span> findKth(A, b1, B, b2 + j, k - j)</span><br><span class="line">        n = <span class="built_in">len</span>(nums1) + <span class="built_in">len</span>(nums2) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, n // <span class="number">2</span>) + findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, (n + <span class="number">1</span>) // <span class="number">2</span>)) / <span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">        <span class="keyword">return</span> (kth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, (m + n + <span class="number">1</span>) / <span class="number">2</span>) + kth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, (m + n + <span class="number">2</span>) / <span class="number">2</span>)) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="keyword">int</span> b1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2, <span class="keyword">int</span> b2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="keyword">int</span>(nums1.size()) - b1, n = <span class="keyword">int</span>(nums2.size()) - b2;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> kth(nums2, b2, nums1, b1, k);</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> nums2[b2 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> min(nums1[b1], nums2[b2]);</span><br><span class="line">        <span class="keyword">int</span> i = min(m, k / <span class="number">2</span>), j = min(n, k / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> nums1[b1 + i - <span class="number">1</span>] &lt; nums2[b2 + j - <span class="number">1</span>] ? kth(nums1, b1 + i, nums2, b2, k - i) : kth(nums1, b1, nums2, b2 + j, k - j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">        <span class="keyword">return</span> (findKth(nums1, nums2, (m + n + <span class="number">1</span>) / <span class="number">2</span>) + findKth(nums1, nums2, (m + n + <span class="number">2</span>) / <span class="number">2</span>)) * <span class="number">0.5</span>; <span class="comment">// 这里因为是第k大，所以是1-based，(m + n + 1) / 2和(m + n + 2) / 2当m + n是奇数的时候相等，偶数的时候相邻</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.size(), n = B.size();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> findKth(B, A, k); <span class="comment">// 永远保持A比B少</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> B[k - <span class="number">1</span>]; <span class="comment">// 如果A是空的，直接在B里找</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> min(A[<span class="number">0</span>], B[<span class="number">0</span>]); <span class="comment">// 如果要找第1小的数，直接返回最小的那个</span></span><br><span class="line">        <span class="keyword">int</span> i = min(m, k / <span class="number">2</span>), j = min(n, k / <span class="number">2</span>); <span class="comment">// 每次去掉较小的那k / 2个</span></span><br><span class="line">        <span class="keyword">return</span> A[i - <span class="number">1</span>] &lt; B[j - <span class="number">1</span>] ? findKth(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(A.begin() + i, A.end()), B, k - i) : findKth(A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(B.begin() + j, B.end()), k - j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(log(m+n))二分法<br>把原题转换成找第k小的数，k=(m+n)/2<br>每次比较两个数组中第k/2大的数，假设nums1[k/2] &lt; nums2[k/2]，则nums1的前k/2元素都不可能是第k大的数，因为至少有剩余的k个数以及nums2[k/2]共k+1个数比这k/2个数大，所以接下来只需要在nums1的剩余数和nums2全部数中找第k-k/2大的数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.size() + nums2.size();</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, (n + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, n / <span class="number">2</span>) + findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, n / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="keyword">int</span> s1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2, <span class="keyword">int</span> s2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 &gt;= nums1.size()) <span class="keyword">return</span> nums2[s2 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s2 &gt;= nums2.size()) <span class="keyword">return</span> nums1[s1 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> min(nums1[s1], nums2[s2]);</span><br><span class="line">        <span class="keyword">int</span> i1 = s1 + k / <span class="number">2</span> - <span class="number">1</span>, i2 = s2 + k / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> e1 = i1 &gt;= nums1.size() ? INT_MAX : nums1[i1];</span><br><span class="line">        <span class="keyword">int</span> e2 = i2 &gt;= nums2.size() ? INT_MAX : nums2[i2];</span><br><span class="line">        <span class="keyword">if</span> (e1 &lt; e2) &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, s1 + k / <span class="number">2</span>, nums2, s2, k - k / <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, s1, nums2, s2 + k / <span class="number">2</span>, k - k / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Divide and conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>40. Combination Sum II</title>
    <url>/2020/06/11/40-Combination-Sum-II/</url>
    <content><![CDATA[<p>backtracking<br>对比<a href="https://leetcode.com/problems/combination-sum/">39. Combination Sum</a>这道题candidates可能有dup且每个candidate只能用一次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res, A = [], []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">b, s</span>):</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">                res.append(A[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(b, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                x = candidates[i]</span><br><span class="line">                <span class="keyword">if</span> x &gt; s:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; b <span class="keyword">and</span> x == candidates[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                A.append(x)</span><br><span class="line">                dfs(i + <span class="number">1</span>, s - x)</span><br><span class="line">                A.pop()</span><br><span class="line">        dfs(<span class="number">0</span>, target)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">b, s, A</span>):</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">                res.append(A)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(b, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                x = candidates[i]</span><br><span class="line">                <span class="keyword">if</span> x &gt; s:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; b <span class="keyword">and</span> x == candidates[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dfs(i + <span class="number">1</span>, s - x, A + [x])</span><br><span class="line">        dfs(<span class="number">0</span>, target, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sort(begin(candidates), end(candidates));</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> b, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; candidates.size() &amp;&amp; candidates[i] &lt;= target; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; b &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">            v.push_back(candidates[i]);</span><br><span class="line">            dfs(candidates, i + <span class="number">1</span>, target - candidates[i]); <span class="comment">// 从下一个开始</span></span><br><span class="line">            v.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
        <tag>Combination</tag>
      </tags>
  </entry>
  <entry>
    <title>319. Bulb Switcher</title>
    <url>/2020/12/13/319-Bulb-Switcher/</url>
    <content><![CDATA[<p>这道题考分析，题目要求从1到n每次按其倍数改变灯泡状态，对于灯泡i来说，i的约数要不是偶数个要不是奇数个，奇数个约数的数是完全平方数(square number)，所以题目转变成从1到n找完全平方数的个数，即sqrt(n)<br>O(logn) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mySqrt(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">long</span> m = (lo + hi + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> p = m * m;</span><br><span class="line">            <span class="keyword">if</span> (p &lt;= n) &#123;</span><br><span class="line">                lo = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(sqrt(n)) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>41. First Missing Positive</title>
    <url>/2020/06/11/41-First-Missing-Positive/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>负号法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> x &lt; <span class="number">1</span> <span class="keyword">or</span> x &gt; n:</span><br><span class="line">                nums[i] = n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            x = <span class="built_in">abs</span>(x)</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt; x &lt;= n:</span><br><span class="line">                nums[x - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[x - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; n) &#123;</span><br><span class="line">                x = n + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            x = <span class="built_in">abs</span>(x);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt; x &amp;&amp; x &lt;= n) &#123;</span><br><span class="line">                nums[x - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[x - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类似桶排序，每个数都应该放在对应的位置，即 nums[i] == nums[nums[i] - 1]，所以不停交换数，尽可能把每个数挪到对应的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span> &lt; nums[i] &lt;= n <span class="keyword">and</span> nums[i] != nums[nums[i] - <span class="number">1</span>]:</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>], nums[i] = nums[i], nums[nums[i] - <span class="number">1</span>] <span class="comment"># 注意不能写成nums[i], nums[nums[i] - 1] = nums[nums[i] - 1], nums[i]因为从左到右赋值，nums[i]先被修改，nums[nums[i] - 1]的新值是错的！！必要时可以考虑加一个中间变量t来swap</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> x != i + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123; <span class="comment">// 交换的条件，nums[i]必须在(0, n]之间，而且被交换的数不能等于nums[i]，否则会造成死循环</span></span><br><span class="line">                swap(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 查找第一个不在对应位置的数</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hare and tortoise</tag>
        <tag>负号法</tag>
      </tags>
  </entry>
  <entry>
    <title>415. Add Strings</title>
    <url>/2020/11/22/415-Add-Strings/</url>
    <content><![CDATA[<p>O(m+n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">             i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || c &gt; <span class="number">0</span>;</span><br><span class="line">             --i, --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = i &lt; <span class="number">0</span> ? <span class="number">0</span> : (num1[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">int</span> b = j &lt; <span class="number">0</span> ? <span class="number">0</span> : (num2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">int</span> s = a + b + c;</span><br><span class="line">            res += <span class="string">&#x27;0&#x27;</span> + s % <span class="number">10</span>;</span><br><span class="line">            c = s / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(rbegin(res), rend(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Addition</tag>
      </tags>
  </entry>
  <entry>
    <title>417. Pacific Atlantic Water Flow</title>
    <url>/2020/12/13/417-Pacific-Atlantic-Water-Flow/</url>
    <content><![CDATA[<p>bfs O(mn) time O(mn) space<br>这道题不能用堆+爬坡的方法，因为不是有序的，也不能用堆+灌水的方法，因为左上和右下两边是无关的，灌水法要求从外往里，每一层必须是一致的<br>解法：把沿海的边分别入队列，bfs爬坡标记两个海分别可以到哪些点，最后两个海都能到的点即为所求</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pacificAtlantic(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; v1(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n)), v2 = v1;</span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        bfs(matrix, <span class="number">0</span>, <span class="number">0</span>, m, n, v1, dx, dy); <span class="comment">// 对每个沿海可达的地方标记</span></span><br><span class="line">        bfs(matrix, m - <span class="number">1</span>, n - <span class="number">1</span>, m, n, v2, dx, dy);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i][j] &amp;&amp; v2[i][j]) &#123; <span class="comment">// 如果被标记过两次，说明这个地方两个海都可达</span></span><br><span class="line">                    res.push_back(&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;v, <span class="keyword">int</span> dx[], <span class="keyword">int</span> dy[])</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123; <span class="comment">// 把沿海的两条边入队列</span></span><br><span class="line">            q.emplace(i, c);</span><br><span class="line">            v[i][c] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            q.emplace(r, j);</span><br><span class="line">            v[r][j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = q.front().first, x = q.front().second; q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> yy = y + dy[i], xx = x + dx[i];</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= yy &amp;&amp; yy &lt; m &amp;&amp; <span class="number">0</span> &lt;= xx &amp;&amp; xx &lt; n &amp;&amp; !v[yy][xx] &amp;&amp; matrix[yy][xx] &gt;= matrix[y][x]) &#123; <span class="comment">// 爬坡</span></span><br><span class="line">                    q.emplace(yy, xx);</span><br><span class="line">                    v[yy][xx] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title>42. Trapping Rain Water</title>
    <url>/2020/06/14/42-Trapping-Rain-Water/</url>
    <content><![CDATA[<p>O(n)<br>跟<a href="https://leetcode.com/problems/container-with-most-water/">11. Container With Most Water</a>方法几乎一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        l, r, res = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mn = <span class="built_in">min</span>(height[l], height[r])</span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> height[l] &lt;= mn:</span><br><span class="line">                res += mn - height[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> height[r] &lt;= mn:</span><br><span class="line">                res += mn - height[r]</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mn = min(height[l], height[r]);</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; height[l] &lt;= mn) &#123;</span><br><span class="line">                res += mn - height[l];</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; height[r] &lt;= mn) &#123;</span><br><span class="line">                res += mn - height[r];</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        int left(0), right(height.size() - 1), ret(0);</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">auto</span> <span class="title">min</span><span class="params">(<span class="built_in">std</span>::min(height[left], height[right]))</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (min == height[left])</span><br><span class="line">                <span class="keyword">while</span> (++left &lt; right &amp;&amp; height[left] &lt; min)</span><br><span class="line">                    ret += min - height[left];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; --right &amp;&amp; height[right] &lt; min)</span><br><span class="line">                    ret += min - height[right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>426. Convert Binary Search Tree to Sorted Doubly Linked List</title>
    <url>/2020/11/27/426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List/</url>
    <content><![CDATA[<p>inorder dfs O(n) time O(h) space<br>维护一个prev用root更新prev，因为prev一直被更新，所以到最后prev就是tail，最后连接head和prev（即tail）即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root; <span class="comment">// 注意这里必须提前判空，因为后边不好处理</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">auto</span> head = dummy_head.right;</span><br><span class="line">        head-&gt;left = prev;</span><br><span class="line">        prev-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        prev-&gt;right = root;</span><br><span class="line">        root-&gt;left = prev;</span><br><span class="line">        prev = root;</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node dummy_head, *prev = &amp;dummy_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Linked list</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>43. Multiply Strings</title>
    <url>/2020/06/14/43-Multiply-Strings/</url>
    <content><![CDATA[<p>O(mn) time O(m+n) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(num1), <span class="built_in">len</span>(num2)</span><br><span class="line">        num = [<span class="number">0</span>] * (m + n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            c = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                s = num[i + j + <span class="number">1</span>] + <span class="built_in">int</span>(num1[i]) * <span class="built_in">int</span>(num2[j]) + c</span><br><span class="line">                c, num[i + j + <span class="number">1</span>] = <span class="built_in">divmod</span>(s, <span class="number">10</span>)</span><br><span class="line">            num[i] = c</span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, num)).lstrip(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = num1.length(), n = num2.length();</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(m + n, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>, j; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">int</span> s = (res[i + j + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) + (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>) + c;</span><br><span class="line">                res[i + j + <span class="number">1</span>] = s % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                c = s / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = c + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = res.find_first_not_of(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> p == <span class="built_in">string</span>::npos ? <span class="string">&quot;0&quot;</span> : res.substr(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>438. Find All Anagrams in a String</title>
    <url>/2020/11/26/438-Find-All-Anagrams-in-a-String/</url>
    <content><![CDATA[<p>sliding window O(m+n) time O(1) space<br>跟<a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/">30. Substring with Concatenation of All Words</a>解法基本一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : p) &#123;</span><br><span class="line">            ++f[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = s.length(), n = p.length(), cnt = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--f[s[i] - <span class="string">&#x27;a&#x27;</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= n &amp;&amp; ++f[s[i - n] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                --cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt == n) &#123;</span><br><span class="line">                res.push_back(i - n + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        vector&lt;int&gt; mp(26), mc(26);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : p) &#123;</span><br><span class="line">            ++mp[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> m = p.length(), n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ++mc[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= m - <span class="number">1</span>) &#123; <span class="comment">// 从m - 1开始就进行判断，避免在结尾处理的麻烦</span></span><br><span class="line">                <span class="keyword">if</span> (mc == mp) &#123;</span><br><span class="line">                    res.push_back(i - m + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                --mc[s[i - m + <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>44. Wildcard Matching</title>
    <url>/2020/06/14/44-Wildcard-Matching/</url>
    <content><![CDATA[<p>backtracking best case O(m+n) time O(1) space<br>worst case O(mn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, ist = <span class="number">-1</span>, jst = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span>)) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; n &amp;&amp; (p[j] == <span class="string">&#x27;*&#x27;</span>)) &#123; <span class="comment">// 保存*匹配到的i和j</span></span><br><span class="line">                ist = i;</span><br><span class="line">                jst = j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ist &gt;= <span class="number">0</span>) &#123; <span class="comment">// 如果之前匹配过*</span></span><br><span class="line">                i = ++ist; <span class="comment">// 这里重置到ist的下一个是因为*有可能匹配多个字符，方便重置i</span></span><br><span class="line">                j = jst + <span class="number">1</span>; <span class="comment">// backtracking假设*可以cover之前的ist那个字符，继续尝试匹配之后的字符</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; p[j] == <span class="string">&#x27;*&#x27;</span>) &#123; <span class="comment">// 只有p后边全是*才说明完全匹配上了</span></span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp O(mn) time O(mn) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">        f = [[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            f[<span class="number">0</span>][i] = p[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> <span class="keyword">and</span> f[<span class="number">0</span>][i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">1</span>] <span class="keyword">or</span> f[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] <span class="keyword">and</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] <span class="keyword">or</span> p[j - <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> f[m][n]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), m = p.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 两个空串肯定匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            f[<span class="number">0</span>][j] = f[<span class="number">0</span>][j - <span class="number">1</span>] &amp;&amp; (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>); <span class="comment">// *可以匹配任意多个字符，所以直接继承前一个的结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">1</span>] || f[i - <span class="number">1</span>][j]; <span class="comment">// s[i - 1]不去跟*匹配，看s[0:i-1]和p[0:j-2]是否匹配；s[i - 1]去跟*匹配，看s[0:i-2]和p[0:j-1]是否匹配</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>); <span class="comment">// 两字符相同（或通配符是?）直接查看之前的匹配结果</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>recursive</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        cache.resize(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> f(m, n, s, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">string</span> &amp;p)</span> </span>&#123;<span class="comment">//cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (cache[i][j] != <span class="number">-1</span>) <span class="keyword">return</span> cache[i][j];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> cache[i][j] = p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; f(i, j - <span class="number">1</span>, s, p);</span><br><span class="line">        <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">return</span> cache[i][j] = f(i, j - <span class="number">1</span>, s, p) || f(i - <span class="number">1</span>, j, s, p);</span><br><span class="line">        <span class="keyword">return</span> cache[i][j] = (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) &amp;&amp; f(i - <span class="number">1</span>, j - <span class="number">1</span>, s, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cache;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>String match</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>45. Jump Game II</title>
    <url>/2020/06/14/45-Jump-Game-II/</url>
    <content><![CDATA[<p>greedy O(n) time O(1) space<br>相当于BFS一棵树<br>last就是当前层所能达到的最远位置（可以覆盖的地方）<br>curr_max是当前位置能达到的最远位置<br><a href="http://www.cnblogs.com/lichen782/p/leetcode_Jump_Game_II.html">题解</a>比较清楚<br>0 1 2 3 4 i<br>2 3 1 1 4 nums[i]<br>2 4 3 4 8 i + nums[i]<br>0 2 2 4 4 last<br>2 4 4 4 8 curr_max<br>{0(2)} –&gt; {1(4) 2(3)} –&gt; {3(4) 4(8)}<br>意思是最开始在0，不跳的话只能到0，如果想跳到1以后需要跳一次，这一次最远跳到2，然后如果想再跳到3以后需要再跳一次，这一次至少跳到4（最远跳到8但是不需要了），因为4已经达到最远点，跳出循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        possible = curr = res = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> curr &gt;= n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> curr &lt; i:</span><br><span class="line">                curr = possible</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            possible = <span class="built_in">max</span>(possible, i + nums[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; last &lt; n - <span class="number">1</span>; ++i) &#123; <span class="comment">// last &lt; n - 1是一个优化，因为last达到n - 1就说明cnt已经够了</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; last) &#123; <span class="comment">// bfs应该先更新，表示必须要jump一次才能达到当前的i</span></span><br><span class="line">                last = curr_max;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            curr_max = max(curr_max, i + nums[i]); <span class="comment">// bfs应该后『遍历』如果颠倒顺序last少更新一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp O(n<sup>2</sup>) time O(n) space TLE<br>dp[i]表示达到i所需要的最少步数<br>求dp[i]需要查询dp[j] where 0 &lt;= j &lt; i，然后+1<br>dp[0]肯定为0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">n</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>); i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j(<span class="number">0</span>); j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + nums[j] &gt;= i)</span><br><span class="line">                    dp[i] = min(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>46. Permutations</title>
    <url>/2020/06/14/46-Permutations/</url>
    <content><![CDATA[<p>O(n*n!) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125; <span class="keyword">while</span> (next(nums));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">next</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i - <span class="number">1</span>] &lt; A[i]) &#123;</span><br><span class="line">                x = i - <span class="number">1</span>;</span><br><span class="line">                y = i;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 说明从i开始后边全降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; x; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[x]) &#123;</span><br><span class="line">                swap(A[i], A[x]); <span class="comment">// 找到下一个比A[x]大的开始下一轮遍历</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(A.begin() + y, A.end());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>backtracking O(n*n!) time</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n, res = <span class="built_in">len</span>(nums), []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">A, b</span>):</span></span><br><span class="line">            <span class="keyword">if</span> b == n:</span><br><span class="line">                res.append(A)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(b, n):</span><br><span class="line">                A[i], A[b] = A[b], A[i]</span><br><span class="line">                dfs(A[:], b + <span class="number">1</span>)</span><br><span class="line">        dfs(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        n, res = <span class="built_in">len</span>(nums), []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">b</span>):</span></span><br><span class="line">            <span class="keyword">if</span> b == n:</span><br><span class="line">                res.append(nums[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(b, n):</span><br><span class="line">                nums[i], nums[b] = nums[b], nums[i]</span><br><span class="line">                dfs(b + <span class="number">1</span>)</span><br><span class="line">                nums[i], nums[b] = nums[b], nums[i]</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(begin(nums), end(nums));</span><br><span class="line">        dfs(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">// 这里nums是深拷贝！！</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (b == n) &#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; n; ++i) &#123;</span><br><span class="line">            swap(nums[i], nums[b]); <span class="comment">// 每次把一个数放到最前边（可以保证剩下的序列还是升序），然后对剩下的序列全排列</span></span><br><span class="line">            dfs(nums, b + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n<sup>n</sup>) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        visited.resize(n);</span><br><span class="line">        sort(begin(nums), end(nums));</span><br><span class="line">        dfs(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.size() == n) &#123;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            v.push_back(nums[i]); <span class="comment">// 把当前剩下还没访问过的数分别尝试append到v后边</span></span><br><span class="line">            dfs(nums);</span><br><span class="line">            v.pop_back();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
        <tag>Permutation</tag>
      </tags>
  </entry>
  <entry>
    <title>47. Permutations II</title>
    <url>/2020/06/14/47-Permutations-II/</url>
    <content><![CDATA[<p>O(n*n!) time<br>先写 dfs 版本再写循环版本<br>先排序，对于每个位置，从小到大枚举之后的每个数（相同的数要跳过）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res, n = [], <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">A, b</span>):</span></span><br><span class="line">            <span class="keyword">if</span> b == n:</span><br><span class="line">                res.append(A)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(b, n):</span><br><span class="line">                <span class="keyword">if</span> i &gt; b <span class="keyword">and</span> A[i] == A[b]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                A[b], A[i] = A[i], A[b]</span><br><span class="line">                dfs(A[:], b + <span class="number">1</span>)</span><br><span class="line">        dfs(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(begin(nums), end(nums));</span><br><span class="line">        dfs(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">// 注意nums是深拷贝</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (b == n) &#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; b &amp;&amp; nums[i] == nums[b]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">            swap(nums[i], nums[b]);</span><br><span class="line">            dfs(nums, b + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n*n!) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        &#125; <span class="keyword">while</span> (next(nums));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">next</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i - <span class="number">1</span>] &lt; A[i]) &#123;</span><br><span class="line">                x = i - <span class="number">1</span>;</span><br><span class="line">                y = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; x; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[x]) &#123;</span><br><span class="line">                swap(A[i], A[x]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(A.begin() + y, A.end());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n<sup>n</sup>) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        visited.resize(n);</span><br><span class="line">        sort(begin(nums), end(nums));</span><br><span class="line">        dfs(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.size() == n) &#123;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] || i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 如果前一个数已经访问过（还没被访问）并且跟这个数相同，则再访问这个数是重复的，如果前一个数正在被访问（说明在v里）则可以访问当前这个数，即便跟前一个数相同</span></span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            v.push_back(nums[i]);</span><br><span class="line">            dfs(nums);</span><br><span class="line">            v.pop_back();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
        <tag>Permutation</tag>
      </tags>
  </entry>
  <entry>
    <title>49. Group Anagrams</title>
    <url>/2020/06/14/49-Group-Anagrams/</url>
    <content><![CDATA[<p>O(nk) time<br>这道题考如何hash<br>followup是MapReduce</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span>(<span class="params">self, strs: List[<span class="built_in">str</span>]</span>) -&gt; List[List[str]]:</span></span><br><span class="line">        d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            f = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">                f[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">            d[<span class="built_in">tuple</span>(f)].append(s)</span><br><span class="line">        <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span>(<span class="params">self, strs: List[<span class="built_in">str</span>]</span>) -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">myhash</span>(<span class="params">s</span>):</span> <span class="comment"># &#x27;bcabe&#x27; -&gt; &#x27;1a2b1c1e&#x27;</span></span><br><span class="line">            f = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">                f[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">            res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> i, cnt <span class="keyword">in</span> <span class="built_in">enumerate</span>(f):</span><br><span class="line">                <span class="keyword">if</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">                    res += <span class="built_in">str</span>(cnt) + <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) + i)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            d[myhash(s)].append(s)</span><br><span class="line">        <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span>(<span class="params">self, strs: List[<span class="built_in">str</span>]</span>) -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">myhash</span>(<span class="params">s</span>):</span> <span class="comment"># &#x27;bcabe&#x27; -&gt; &#x27;1 2 1 0 1 0 ... 0&#x27;</span></span><br><span class="line">            f = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">                f[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">            res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, f))</span><br><span class="line">        d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            d[myhash(s)].append(s)</span><br><span class="line">        <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : strs) &#123;</span><br><span class="line">            m[hash(s)].push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : m) &#123;</span><br><span class="line">            res.push_back(p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">hash</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123; <span class="comment">// bucket sort</span></span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            ++f[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : f) &#123;</span><br><span class="line">            res += to_string(x);</span><br><span class="line">            res += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>普通解法 O(nklogk) time</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span>(<span class="params">self, strs: List[<span class="built_in">str</span>]</span>) -&gt; List[List[str]]:</span></span><br><span class="line">        d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            d[<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">sorted</span>(s))].append(s) <span class="comment"># key是一个str: &#x27;bcabe&#x27; -&gt; &#x27;abbce&#x27;</span></span><br><span class="line">            <span class="comment"># d[tuple(sorted(s))].append(s) # key是一个tuple: &#x27;bcabe&#x27; -&gt; (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;e&#x27;)</span></span><br><span class="line">        <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; hm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : strs) &#123;</span><br><span class="line">            hm[key(s)].push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : hm) &#123;</span><br><span class="line">            res.push_back(p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">key</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> primes[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; hash_map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;str : strs)</span><br><span class="line">            hash_map[key(str)].push_back(str);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; ret(hash_map.size());</span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">i</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;<span class="built_in">pair</span> : hash_map) &#123;</span><br><span class="line">            ret[i].swap(<span class="built_in">pair</span>.second);</span><br><span class="line">            sort(ret[i].begin(), ret[i].end());</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">key</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">long</span> <span class="title">ret</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;c : str)</span><br><span class="line">            ret *= primes[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
        <tag>String</tag>
        <tag>Anagram</tag>
      </tags>
  </entry>
  <entry>
    <title>48. Rotate Image</title>
    <url>/2020/06/14/48-Rotate-Image/</url>
    <content><![CDATA[<p>two spins O(n<sup>2</sup>)<br>先上下翻转，再沿对称轴翻转</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        matrix.reverse()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        matrix.reverse()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(matrix)):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        reverse(matrix.begin(), matrix.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">0</span>); i &lt; matrix.size() - <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j(i + <span class="number">1</span>); j &lt; matrix.size(); ++j)</span><br><span class="line">                swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>直接移 O(n<sup>2</sup>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">n</span><span class="params">(matrix.size() &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row(<span class="number">0</span>); row &lt; n; ++row)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col(row); col &lt; matrix.size() - <span class="number">1</span> - row; ++col) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">auto</span> <span class="title">temp</span><span class="params">(matrix[row][col])</span></span>;</span><br><span class="line">                matrix[row][col] = matrix[matrix.size() - <span class="number">1</span> - col][row];</span><br><span class="line">                matrix[matrix.size() - <span class="number">1</span> - col][row] = matrix[matrix.size() - <span class="number">1</span> - row][matrix.size() - <span class="number">1</span> - col];</span><br><span class="line">                matrix[matrix.size() - <span class="number">1</span> - row][matrix.size() - <span class="number">1</span> - col] = matrix[col][matrix.size() - <span class="number">1</span> - row];</span><br><span class="line">                matrix[col][matrix.size() - <span class="number">1</span> - row] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title>5. Longest Palindromic Substring</title>
    <url>/2020/05/30/5-Longest-Palindromic-Substring/</url>
    <content><![CDATA[<p>manacher’s algorithm可以O(n)但是不会<br>O(n<sup>2</sup>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">l, r</span>):</span></span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span> &lt;= l <span class="keyword">and</span> r &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> l + <span class="number">1</span>, r - <span class="number">1</span></span><br><span class="line">        ll, rr = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            l, r = find(i, i)</span><br><span class="line">            <span class="keyword">if</span> r - l &gt; rr - ll: ll, rr = l, r</span><br><span class="line">            l, r = find(i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> r - l &gt; rr - ll: ll, rr = l, r</span><br><span class="line">        <span class="keyword">return</span> s[ll:rr + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        ll, rr = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            l, r = self.find(s, i, i)</span><br><span class="line">            <span class="keyword">if</span> r - l &gt; rr - ll: ll, rr = l, r</span><br><span class="line">            l, r = self.find(s, i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> r - l &gt; rr - ll: ll, rr = l, r</span><br><span class="line">        <span class="keyword">return</span> s[ll:rr + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, s, l, r</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> &lt;= l <span class="keyword">and</span> r &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l + <span class="number">1</span>, r - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>因为回文串是对称的，所以枚举所有可能的对称轴<br>对称轴可能是某个字符，也可能是两个字符中间，填充#符号来避免奇偶问题<br>枚举每个可能的对称轴，从对称轴开始向左右两边比较字符直到找到不一样的或者越界，然后左右指针均回退一个（回退以后一定都是指向#符号），更新全局左右指针<br>最后重建原字符串里的最长回文子字符串<br>O(n^2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        s = <span class="string">&#x27;#&#x27;</span> + <span class="string">&#x27;#&#x27;</span>.join(<span class="built_in">list</span>(s)) + <span class="string">&#x27;#&#x27;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        ll, rr = n, n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            l, r = i - <span class="number">1</span>, i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span> &lt;= l <span class="keyword">and</span> r &lt; n <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> r - l &gt; rr - ll: ll, rr = l + <span class="number">1</span>, r - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[ll + <span class="number">1</span> : rr : <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            str += c;</span><br><span class="line">            str += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = str.length(), ll = <span class="number">0</span>, rr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">0</span> &lt;= l &amp;&amp; r &lt; n &amp;&amp; str[l] == str[r]) &#123;</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">            <span class="keyword">if</span> (r - l &gt; rr - ll) &#123;</span><br><span class="line">                ll = l;</span><br><span class="line">                rr = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ll + <span class="number">1</span>; i &lt;= rr; i += <span class="number">2</span>) &#123;</span><br><span class="line">            res += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = split(s);</span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i, r = i;</span><br><span class="line">            <span class="keyword">while</span> (str[l] == str[r] &amp;&amp; l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n) &#123;</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">            <span class="keyword">if</span> (r - l &gt; right - left) &#123;</span><br><span class="line">                left = l;</span><br><span class="line">                right = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reconstruct(str, left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">split</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : s) &#123;</span><br><span class="line">            str += c;</span><br><span class="line">            str += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reconstruct</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt; r; i += <span class="number">2</span>) &#123;</span><br><span class="line">            str += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>memo+recursive<br>f(l, r)表示s[l:r]中最长的回文串的长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), b = <span class="number">0</span>;</span><br><span class="line">        m.resize(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">int</span> mx = f(s, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = l + mx - <span class="number">1</span>; <span class="number">0</span> &lt;= r &amp;&amp; r &lt; n; ++l, ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[l][r] == mx) <span class="keyword">return</span> s.substr(l, mx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (m[l][r] &gt; <span class="number">0</span>) <span class="keyword">return</span> m[l][r];</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> m[l][r] = <span class="number">1</span>;</span><br><span class="line">        m[l][r] = max(f(s, l, r - <span class="number">1</span>), f(s, l + <span class="number">1</span>, r));</span><br><span class="line">        <span class="keyword">if</span> (s[l] == s[r]) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = f(s, l + <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (l + t + <span class="number">1</span> == r) &#123;</span><br><span class="line">                m[l][r] = max(m[l][r], r + <span class="number">1</span> - l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[l][r];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Palindrome</tag>
        <tag>Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>50. Pow(x, n)</title>
    <url>/2020/06/15/50-Pow-x-n/</url>
    <content><![CDATA[<p>O(logn)<br>循环版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x: <span class="built_in">float</span>, n: <span class="built_in">int</span></span>) -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            x = <span class="number">1</span> / x</span><br><span class="line">            n = -n</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                res *= x</span><br><span class="line">            x *= x</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> t = <span class="built_in">labs</span>(n); <span class="comment">// 注意n溢出！！</span></span><br><span class="line">        x = n &lt; <span class="number">0</span> ? <span class="number">1</span> / x : x;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                res *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                res *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            n /= <span class="number">2</span>; <span class="comment">// 这里一定不要用 n &gt;&gt;= 1因为n可能为INT_MIN</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>1.00000<br>-2147483648<br>这个测试用例很重要！因为-INT_MIN还是INT_MIN！！所以必须要把n &lt; 0的分支分离出来，否则会造成死循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &lt; <span class="number">0</span> ? power(<span class="number">1</span> / x, <span class="built_in">labs</span>(n)) : power(x, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n &amp; <span class="number">1</span> ? x * power(x * x, n / <span class="number">2</span>) : power(x * x, n / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        n &lt; <span class="number">0</span> ? power(<span class="number">1</span> / x, <span class="built_in">labs</span>(n), res) : power(x, n, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n, <span class="keyword">double</span> &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        power(x * x, n / <span class="number">2</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Integer</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>523. Continuous Subarray Sum</title>
    <url>/2020/11/22/523-Continuous-Subarray-Sum/</url>
    <content><![CDATA[<p>同余 O(n) time O(n) space<br>a % k = c<br>(a + sum) % k = c<br>sum % k = 0<br>需要sum的数字个数大于1<br>和<a href="https://leetcode.com/problems/subarray-sums-divisible-by-k/">974. Subarray Sums Divisible by K</a>不同，k有可能为0，所以必须给前缀和维护一个hashmap</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// 利用一个map保存&lt;前缀和余数, 下标&gt;</span></span><br><span class="line">        m[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 因为连续的子数组是从头开始的，则需要提前先保存一个余数0</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="number">0</span>) sum %= k; <span class="comment">// k如果是0，跳过即可</span></span><br><span class="line">            <span class="keyword">if</span> (m.count(sum)) &#123; <span class="comment">// 如果map里没有当前余数，保存即可，否则检查是否相隔至少2个数</span></span><br><span class="line">                 <span class="keyword">if</span> (i - m[sum] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这个if不能跟上一层的merge！！！因为有可能有相邻的</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>前缀和O(n<sup>2</sup>) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">presum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            presum[i] = presum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n - <span class="number">1</span>; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - len; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len;</span><br><span class="line">                <span class="keyword">int</span> sum = presum[j + <span class="number">1</span>] - presum[i];</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sum == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum / k * k == sum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>528. Random Pick with Weight</title>
    <url>/2020/11/28/528-Random-Pick-with-Weight/</url>
    <content><![CDATA[<p>O(logn) time O(n) space<br>[1, 3]是频数，即构造成下标数组[0, 1, 1, 1]然后随机一个index<br>累加频数，构造频数和数组[1, 4]，这里最后一个4是所有频数的和，即数组[0, 1, 1, 1]的长度，随机以后得到一个下标，需要得到下标所对应的原数组的index，因为频数和数组是递增的，所以二分可得到对应的频数和位置，即为原频数数组的下标</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w) &#123;</span><br><span class="line">        v = w;</span><br><span class="line">        partial_sum(begin(v), end(v), begin(v), plus&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> upper_bound(begin(v), end(v), rand() % v.back()) - begin(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w) &#123;</span><br><span class="line">        v = w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.size(); ++i) &#123;</span><br><span class="line">            v[i] += v[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lower_bound(begin(v), end(v), (rand() % v.back() + <span class="number">1</span>)) - begin(v); <span class="comment">// 加1恢复成1-indexed</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : w) &#123;</span><br><span class="line">            v.push_back(sum += x); <span class="comment">// 累加频数</span></span><br><span class="line">        &#125;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance(begin(v), upper_bound(begin(v), end(v), rand() % v.back())); <span class="comment">// 这里要用upper_bound因为rand出来的是0-indexed，而频数本身是1-indexed，用lower_bound会找错，举例[1, 4]rand % 4出来的是下标1，而不是频数1，upper_bound找到的是频数和4，而lower_bound找到的是错误的频数和1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.com/problems/random-pick-with-weight/discuss/182620/Follow-up%3A-what-if-we-can-change-weights-array">follow-up</a>如果weight数组是mutable的<br>用线段树，因为需要前缀和，把二分查找前缀和的上界改成二分查找区间和的上界，只是这个区间和是从0开始的<br>update O(logn)<br>query O(logn)<br>pickIndex O(logn*logn)<br>需要注意update和pickIndex的比例，如果很少update也可以考虑普通前缀和来做这样update虽然是O(n)但是pickIndex是O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w) &#123;</span><br><span class="line">        n = w.size();</span><br><span class="line">        v.resize(n * <span class="number">2</span>);</span><br><span class="line">        copy(begin(w), end(w), begin(v) + n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            v[i] = v[i * <span class="number">2</span>] + v[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        i += n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = val - v[i]; i &gt; <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            v[i] += d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = n, r = i + n; l &lt;= r; l &gt;&gt;= <span class="number">1</span>, r &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                res += v[l++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((r &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                res += v[r--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = rand() % v[<span class="number">1</span>], l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (query(m) &lt;= x) &#123; <span class="comment">// &lt;是找下界&lt;=是找上界c</span></span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
        <tag>Random</tag>
        <tag>Segment tree</tag>
      </tags>
  </entry>
  <entry>
    <title>536. Construct Binary Tree from String</title>
    <url>/2020/12/01/536-Construct-Binary-Tree-from-String/</url>
    <content><![CDATA[<p>O(n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">str2tree</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        s += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        TreeNode dummy;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; stk&#123;&#123;&amp;dummy&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, n = s.length(); i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27;(&#x27;</span> &amp;&amp; s[i] != <span class="string">&#x27;)&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = <span class="keyword">new</span> TreeNode(stoi(s.substr(j, i - j)));</span><br><span class="line">                <span class="keyword">if</span> (stk.top()-&gt;left) &#123;</span><br><span class="line">                    stk.top()-&gt;right = x;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stk.top()-&gt;left = x;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            j = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">str2tree</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        s += <span class="string">&#x27;(&#x27;</span>; <span class="comment">// in case no parenthesis</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="function">TreeNode <span class="title">dummy_root</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        stk.push(&amp;dummy_root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>, i = s.find_first_of(<span class="string">&quot;()&quot;</span>); i != <span class="built_in">string</span>::npos; b = i + <span class="number">1</span>, i = s.find_first_of(<span class="string">&quot;()&quot;</span>, b)) &#123; <span class="comment">// find_first_of search any match of the input chars</span></span><br><span class="line">            TreeNode *x = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="built_in">string</span> num = s.substr(b, i - b);</span><br><span class="line">            <span class="keyword">if</span> (!num.empty()) &#123; <span class="comment">// num might be empty e.g. ))</span></span><br><span class="line">                x = <span class="keyword">new</span> TreeNode(stoi(num));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!stk.top()-&gt;left) &#123;</span><br><span class="line">                stk.top()-&gt;left = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!stk.top()-&gt;right) &#123; <span class="comment">// must use else if to check right child to avoid overwrite e.g. 4(2(3)(1)), 3 and 1 are 2&#x27;s children, )) creates a nullptr to try overwriting 1</span></span><br><span class="line">                stk.top()-&gt;right = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x) &#123;</span><br><span class="line">                stk.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_root.left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">str2tree</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="function">TreeNode <span class="title">dummy_root</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        stk.push(&amp;dummy_root);</span><br><span class="line">        <span class="built_in">string</span> num;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = s.length(), i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) <span class="keyword">continue</span>; <span class="comment">// 可有可无</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; (<span class="built_in">isdigit</span>(s[i]) || s[i] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">                num += s[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode *x = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span> (!num.empty()) &#123;</span><br><span class="line">                x = <span class="keyword">new</span> TreeNode(stoi(num));</span><br><span class="line">                --i;</span><br><span class="line">                num.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!stk.top()-&gt;left) &#123;</span><br><span class="line">                stk.top()-&gt;left = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!stk.top()-&gt;right) &#123;</span><br><span class="line">                stk.top()-&gt;right = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x) &#123;</span><br><span class="line">                stk.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_root.left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>String</tag>
        <tag>Stack</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>543. Diameter of Binary Tree </title>
    <url>/2020/11/29/543-Diameter-of-Binary-Tree/</url>
    <content><![CDATA[<p>postorder O(n) 跟<a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">124. Binary Tree Maximum Path Sum</a>思路基本一致</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span> </span>&#123; <span class="comment">// 返回以root为根的最长链有几个结点</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = dfs(root-&gt;left), r = dfs(root-&gt;right);</span><br><span class="line">        res = max(res, l + r); <span class="comment">// 人家问的是边不是点，不要加1</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>56. Merge Intervals</title>
    <url>/2020/12/02/56-Merge-Intervals/</url>
    <content><![CDATA[<p>扫描线版本很清晰 O(nlogn) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Interval&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// 扫一遍输入intervals把start和end存到map里</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i : intervals) &#123;</span><br><span class="line">            ++m[i.start];</span><br><span class="line">            --m[i.end];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; res;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : m) &#123; <span class="comment">// 扫一遍map并实时统计区间个数</span></span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123; <span class="comment">// 扫当前时刻之前如果区间为0，则当前时刻是区间的开始</span></span><br><span class="line">                b = p.first;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt += p.second;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123; <span class="comment">// 扫当前时刻之后如果区间为0，则当前时刻是区间的结束</span></span><br><span class="line">                res.push_back(&#123;b, p.first&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Interval&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i : intervals) &#123;</span><br><span class="line">            ++m[i.start];</span><br><span class="line">            --m[i.end];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : m) &#123;</span><br><span class="line">            s = min(s, p.first);</span><br><span class="line">            cnt += p.second;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                res.emplace_back(s, p.first);</span><br><span class="line">                s = INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>greedy O(nlogn) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        sort(begin(intervals), end(intervals));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res&#123;intervals[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i[<span class="number">0</span>] &lt;= res.back()[<span class="number">1</span>]) &#123;</span><br><span class="line">                res.back()[<span class="number">1</span>] = max(res.back()[<span class="number">1</span>], i[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        sort(begin(intervals), end(intervals));</span><br><span class="line">        <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res&#123;intervals[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= res.back()[<span class="number">1</span>]) &#123;</span><br><span class="line">                res.back()[<span class="number">1</span>] = max(res.back()[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Interval&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> Interval &amp;lhs, <span class="keyword">const</span> Interval &amp;rhs) &#123; <span class="keyword">return</span> lhs.start &lt; rhs.start; &#125;;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!res.empty() &amp;&amp; i.start &lt;= res.back().end) &#123;</span><br><span class="line">                res.back().end = max(res.back().end, i.end);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Interval&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](<span class="keyword">const</span> Interval &amp;lhs, <span class="keyword">const</span> Interval &amp;rhs)</span><br><span class="line">        &#123; <span class="keyword">return</span> lhs.start &lt; rhs.start; &#125;); <span class="comment">// 切记不要加别的条件</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; res&#123;intervals[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.back().end &gt;= intervals[i].start) &#123;</span><br><span class="line">                res.back().end = max(res.back().end, intervals[i].end); <span class="comment">// 这里一定要用max比如[1,4],[2,3]这个反例</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Interval&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](<span class="keyword">const</span> Interval &amp;lhs, <span class="keyword">const</span> Interval &amp;rhs)</span><br><span class="line">        &#123; <span class="keyword">return</span> lhs.start &lt; rhs.start; &#125;);</span><br><span class="line">        <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">        intervals.push_back(Interval(INT_MAX, INT_MAX));</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = intervals[i].start;</span><br><span class="line">            <span class="keyword">int</span> e = intervals[i].end;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n &amp;&amp; e &gt;= intervals[j].start; ++j) &#123;</span><br><span class="line">                e = max(e, intervals[j].end);</span><br><span class="line">            &#125;</span><br><span class="line">            res.emplace_back(s, e);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sweep line</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>560. Subarray Sum Equals K</title>
    <url>/2020/11/22/560-Subarray-Sum-Equals-K/</url>
    <content><![CDATA[<p>O(n) 在遍历每个数的过程中用hashmap把已经算过的前缀和存起来，之后只需要查看目标前缀和的个数即可<br>初始化要加入{0,1}这对映射，这是为啥呢，因为我们的解题思路是遍历数组中的数字，用sum来记录到当前位置的累加和，我们建立哈希表的目的是为了让我们可以快速的查找sum-k是否存在，即是否有连续子数组的和为sum-k，如果存在的话，那么和为k的子数组一定也存在，这样当sum刚好为k的时候，那么数组从起始到当前位置的这段子数组的和就是k，满足题意，如果哈希表中事先没有m[0]项的话，这个符合题意的结果就无法累加到结果res中，这就是初始化的用途</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            s += x;</span><br><span class="line">            res += m[s - k];</span><br><span class="line">            ++m[s];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n^2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                res += (sum[i] + k == sum[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
        <tag>Prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>6. ZigZag Conversion</title>
    <url>/2020/05/30/6-ZigZag-Conversion/</url>
    <content><![CDATA[<p>O(n) time O(n) space<br>用辅助字符串组来保存每一行的字符串，通过调整step来决定是从上往下放字符还是从下往上放字符，当指针指向第一行则从上往下，当指针指向最后一行则从下往上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">self, s: <span class="built_in">str</span>, numRows: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> numRows &lt;= <span class="number">1</span> <span class="keyword">or</span> numRows &gt;= <span class="built_in">len</span>(s): <span class="keyword">return</span> s</span><br><span class="line">        v = [<span class="string">&#x27;&#x27;</span>] * numRows</span><br><span class="line">        <span class="comment"># v = [&#x27;&#x27; for i in range(numRows)]</span></span><br><span class="line">        i, step = <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == numRows - <span class="number">1</span>:</span><br><span class="line">                step = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                step = <span class="number">1</span></span><br><span class="line">            v[i] += c</span><br><span class="line">            i += step</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(v)</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">v</span><span class="params">(numRows)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, step = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == numRows - <span class="number">1</span>) &#123;</span><br><span class="line">                step = <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                step = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v[i] += c;</span><br><span class="line">            i += step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;str : v) &#123;</span><br><span class="line">            res += str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>616. Add Bold Tag in String</title>
    <url>/2020/12/03/616-Add-Bold-Tag-in-String/</url>
    <content><![CDATA[<p>worst case O(n*sum{dict[i].length}) time<br>纯暴力<br>维护一个bold数组标明每个字符是否需要bold<br>和<a href="https://leetcode.com/problems/bold-words-in-string/">758. Bold Words in String</a>是同一道题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBoldTag</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; dict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(s);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">bold</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : dict) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                p = s.find(w, p + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// npos等于-1</span></span><br><span class="line">                fill_n(begin(bold) + p, size(w), <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bold[i] &amp;&amp; (i == <span class="number">0</span> || !bold[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                res += <span class="string">&quot;&lt;b&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += s[i];</span><br><span class="line">            <span class="keyword">if</span> (bold[i] &amp;&amp; (i == n - <span class="number">1</span> || !bold[i + <span class="number">1</span>])) &#123;</span><br><span class="line">                res += <span class="string">&quot;&lt;/b&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBoldTag</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; dict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">bold</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : dict) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = w.length(), p = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                p = s.find(w, p + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                    bold[p + i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bold[i]) &#123;</span><br><span class="line">                res += <span class="string">&quot;&lt;b&gt;&quot;</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; bold[i]) &#123;</span><br><span class="line">                    res += s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">                res += <span class="string">&quot;&lt;/b&gt;&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; !bold[i]) &#123;</span><br><span class="line">                    res += s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>trie</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBoldTag</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; dict)</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : dict) &#123;</span><br><span class="line">            add(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = s.length(), r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            add(search(s, r), r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = s.length(), i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lst.empty()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [l, r] = lst.front();</span><br><span class="line">                <span class="keyword">if</span> (i == l) &#123;</span><br><span class="line">                    res += <span class="string">&quot;&lt;b&gt;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == r) &#123;</span><br><span class="line">                    res += s[i];</span><br><span class="line">                    res += <span class="string">&quot;&lt;/b&gt;&quot;</span>;</span><br><span class="line">                    lst.pop_front();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, TrieNode *&gt; children;</span><br><span class="line">        <span class="keyword">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TrieNode *root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = s.length(), i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children.count(s[i])) &#123;</span><br><span class="line">                p-&gt;children[s[i]] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;children[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">int</span> l = r + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children.count(s[i])) <span class="keyword">break</span>;</span><br><span class="line">            p = p-&gt;children[s[i]];</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;isEnd) &#123;</span><br><span class="line">                l = min(l, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (!lst.empty() &amp;&amp; l &lt;= lst.back().second + <span class="number">1</span>) &#123;</span><br><span class="line">            l = min(l, lst.back().first);</span><br><span class="line">            lst.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        lst.emplace_back(l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; lst;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>String</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>621. Task Scheduler</title>
    <url>/2020/12/02/621-Task-Scheduler/</url>
    <content><![CDATA[<p>O(t) time t是tasks的个数<a href="https://leetcode.com/articles/task-scheduler/#approach-3-calculating-idle-slots-accepted">题解</a><br>先统计字符频数，然后从大到小排序，初始idle的个数是(最大频数 - 1) * n，因为只统计(最大频数 - 1)范围内的区间，比如输入是AAABBB2，则初始化为A__A__，而不是A__A__A__，然后要做的就是按照频数从大到小往idle的slot里面放字符，这里要放在区间范围内，所以要用min(m[i], mx)，即AB_AB_，否则变成AB_AB_B就不对了，所有频数大于0的字符都放完以后，如果还有idle的slot说明剩下的字符只能放在后面了，即AB_AB_AB，不能再往idle的slot里面放了，否则说明不需要idle的slot分隔也足以让字符按照要求间隔的放，比如输入AAABBBCCC2，输出应为ABCABCABC<br>假设task是AAABBCCDD，n = 2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A12</span><br><span class="line">A12</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<p>变成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ABCD</span><br><span class="line">ABCD</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<p>则所有idel slot都占满，结果就是task.size() = 9<br>假设task是AAABBB，n = 2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A12</span><br><span class="line">A12</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<p>变成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AB2</span><br><span class="line">AB2</span><br><span class="line">AB</span><br></pre></td></tr></table></figure>
<p>还剩2个idle slot，结果就是taks.size() + 2 = 8</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : tasks) &#123;</span><br><span class="line">            ++m[c - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(m, m + <span class="number">26</span>, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">int</span> mx = m[<span class="number">0</span>] - <span class="number">1</span>, idle_slots = mx * n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">26</span> &amp;&amp; m[i] &gt; <span class="number">0</span> &amp;&amp; idle_slots &gt;= <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            idle_slots -= min(m[i], mx); <span class="comment">// idle_slots是有可能放不开的，也就是最后变成负数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tasks.size() + max(idle_slots, <span class="number">0</span>); <span class="comment">// 这里要取max是因为idle_slots有可能因为放不开而『过饱和』，也就是变成负数，最后要把这些『负数』加回来，比如AAABBBCCCDDD2，最后idle_slots因为D放不进去变成-2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Greedy</tag>
        <tag>Bucket sort</tag>
      </tags>
  </entry>
  <entry>
    <title>622. Design Circular Queue</title>
    <url>/2020/12/12/622-Design-Circular-Queue/</url>
    <content><![CDATA[<p>O(1) time O(k) space<br>用左闭右开区间[b, e)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class="line">    MyCircularQueue(<span class="keyword">int</span> k) : k(k) &#123;</span><br><span class="line">        q.resize(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        q[e] = value;</span><br><span class="line">        e = (e + <span class="number">1</span>) % k;</span><br><span class="line">        is_empty = <span class="literal">false</span>;</span><br><span class="line">        is_full = b == e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        b = (b + <span class="number">1</span>) % k;</span><br><span class="line">        is_full = <span class="literal">false</span>;</span><br><span class="line">        is_empty = b == e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isEmpty() ? <span class="number">-1</span> : q[b];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isEmpty() ? <span class="number">-1</span> : q[(e + k - <span class="number">1</span>) % k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> is_empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> is_full;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>, e = <span class="number">0</span>, k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">bool</span> is_full = <span class="literal">false</span>, is_empty = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularQueue* obj = new MyCircularQueue(k);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;enQueue(value);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;deQueue();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;Front();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;Rear();</span></span><br><span class="line"><span class="comment"> * bool param_5 = obj-&gt;isEmpty();</span></span><br><span class="line"><span class="comment"> * bool param_6 = obj-&gt;isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Data structure design</tag>
      </tags>
  </entry>
  <entry>
    <title>636. Exclusive Time of Functions</title>
    <url>/2020/11/27/636-Exclusive-Time-of-Functions/</url>
    <content><![CDATA[<p>stack类似括号匹配O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exclusiveTime</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; logs)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;l : logs) &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = parse(l);</span><br><span class="line">            <span class="keyword">if</span> (e[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = e[<span class="number">2</span>] - s.top()[<span class="number">2</span>] + <span class="number">1</span>; <span class="comment">// 先计算最近一个线程的时间</span></span><br><span class="line">                res[e[<span class="number">0</span>]] += t; <span class="comment">// 修改最近一个线程的时间</span></span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span> (!s.empty()) &#123; <span class="comment">// 如果前面还有别的线程被阻塞</span></span><br><span class="line">                    res[s.top()[<span class="number">0</span>]] -= t; <span class="comment">// 从那个线程上减去最近这个线程的运行时间</span></span><br><span class="line">                    <span class="comment">// s.top()[2] += t; 是错的因为只考虑了局部，这道题必须从全局考虑，所以应该直接处理对应线程的最终结果，两层以上的nested call就是错的</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.push(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">parse</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = s.find(<span class="string">&quot;:&quot;</span>), p2 = s.find(<span class="string">&quot;:&quot;</span>, p1 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;stoi(s.substr(<span class="number">0</span>, p1)), s.substr(p1 + <span class="number">1</span>, p2 - p1 - <span class="number">1</span>) == <span class="string">&quot;end&quot;</span>, stoi(s.substr(p2 + <span class="number">1</span>))&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Log</span> &#123;</span></span><br><span class="line">        Log(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(s)</span></span>;</span><br><span class="line">            <span class="built_in">string</span> token;</span><br><span class="line">            getline(input, token, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">            id = stoi(token);</span><br><span class="line">            getline(input, e, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">            getline(input, token, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">            time = stoi(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="built_in">string</span> e;</span><br><span class="line">        <span class="keyword">int</span> time;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exclusiveTime</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; logs)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> sz = logs.size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;Log&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<span class="built_in">log</span> : logs) &#123;</span><br><span class="line">            <span class="function">Log <span class="title">curr</span><span class="params">(<span class="built_in">log</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (curr.e == <span class="string">&quot;start&quot;</span>) &#123;</span><br><span class="line">                s.push(curr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log prev = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">int</span> interval = curr.time + <span class="number">1</span> - prev.time;</span><br><span class="line">                res[prev.id] += interval;</span><br><span class="line">                <span class="keyword">if</span> (!s.empty()) &#123; <span class="comment">// 这里很重要，父函数的实际运行时间不包括子函数的运行时间</span></span><br><span class="line">                    res[s.top().id] -= interval; <span class="comment">// s.top()是父函数，因为每次统计函数运行时间都是直接累加，所以要把子函数的运行时间『先』减掉</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>65. Valid Number</title>
    <url>/2020/11/28/65-Valid-Number/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> <span class="built_in">exp</span> = <span class="literal">false</span>, dot = <span class="literal">false</span>, num = <span class="literal">false</span>, numAfterE = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.find_first_not_of(<span class="string">&#x27; &#x27;</span>); i &lt;= s.find_last_not_of(<span class="string">&#x27; &#x27;</span>); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                num = numAfterE = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">exp</span> || !num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">exp</span> = <span class="literal">true</span>;</span><br><span class="line">                numAfterE = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dot || <span class="built_in">exp</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                dot = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">&#x27; &#x27;</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">&#x27;e&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num &amp;&amp; numAfterE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">bool</span> num = <span class="literal">false</span>, numAfterE = <span class="literal">false</span>, dot = <span class="literal">false</span>, <span class="built_in">exp</span> = <span class="literal">false</span>, sign = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((num || dot || <span class="built_in">exp</span> || sign) &amp;&amp; i + <span class="number">1</span> &lt; n &amp;&amp; s[i + <span class="number">1</span>] != <span class="string">&#x27; &#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 空格不能出现在中间</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                num = numAfterE = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dot || <span class="built_in">exp</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不能有多个.且指数部分不能有.</span></span><br><span class="line">                dot = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">exp</span> || !num) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不能有多个e且e前必须得有数字出现</span></span><br><span class="line">                <span class="built_in">exp</span> = <span class="literal">true</span>;</span><br><span class="line">                numAfterE = <span class="literal">false</span>; <span class="comment">// 重置！！</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">&#x27;e&#x27;</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">&#x27; &#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 符号只能出现在最开始的空格之后或者e之后</span></span><br><span class="line">                sign = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num &amp;&amp; numAfterE; <span class="comment">// 最后底数和指数都要检查</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>67. Add Binary</title>
    <url>/2020/11/22/67-Add-Binary/</url>
    <content><![CDATA[<p>O(max(m, n)) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>, i = a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>;</span><br><span class="line">            i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || c &gt; <span class="number">0</span>;</span><br><span class="line">            --i, --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &lt; <span class="number">0</span> ? <span class="number">0</span> : (a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">int</span> y = j &lt; <span class="number">0</span> ? <span class="number">0</span> : (b[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">int</span> s = x + y + c;</span><br><span class="line">            res += <span class="string">&#x27;0&#x27;</span> + (s &amp; <span class="number">1</span>);</span><br><span class="line">            c = s &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(rbegin(res), rend(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.empty()) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span> (b.empty()) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span> (!a.empty() || !b.empty() || c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a.empty() ? <span class="number">0</span> : (a.back() - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">int</span> y = b.empty() ? <span class="number">0</span> : (b.back() - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (!a.empty()) &#123;</span><br><span class="line">                a.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!b.empty()) &#123;</span><br><span class="line">                b.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> s = x + y + c;</span><br><span class="line">            res += <span class="string">&#x27;0&#x27;</span> + (s &amp; <span class="number">1</span>);</span><br><span class="line">            c = (s &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(rbegin(res), rend(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Addition</tag>
      </tags>
  </entry>
  <entry>
    <title>670. Maximum Swap</title>
    <url>/2020/12/01/670-Maximum-Swap/</url>
    <content><![CDATA[<p>桶排序 O(n) time O(10) space<br>思路就是从高位到低位扫描，对于每一位数字，找到其右侧比他大的所有数字里最大的那个数字，找到这个数字最后一次出现的位置，交换即可，因此需要统计每个数字最后一次出现的位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> s = to_string(num);</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            last[s[i] - <span class="string">&#x27;0&#x27;</span>] = i; <span class="comment">// 记录所有数字最后出现的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">9</span>; j &gt; s[i] - <span class="string">&#x27;0&#x27;</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; last[j]) &#123; <span class="comment">// 对于每个处于高位的数字，如果能找到一个比它大的在低位的数字，交换并返回</span></span><br><span class="line">                    swap(s[i], s[last[j]]);</span><br><span class="line">                    <span class="keyword">return</span> stoi(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>桶排序 O(n) time O(n) space<br>0到9十个数字十个桶，扫描数字字符串，把每个数字出现的下标保存到对应数字的桶里<br>从9到0依次扫描桶，取出当前桶i最后一次出现的下标b[i].back()，然后扫描所有比当前桶对应的数字小的数字的桶j中的第一次出现的下标b[j].front()并找到最小的下标l，将其与桶i最后一次出现的下标b[i].back()，交换原字符串中的数字即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; b(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">auto</span> s = to_string(num);</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            b[s[i] - <span class="string">&#x27;0&#x27;</span>].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b[i].empty()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> l = b[i].back();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b[j].empty()) <span class="keyword">continue</span>;</span><br><span class="line">                l = min(l, b[j].front());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; b[i].back()) &#123;</span><br><span class="line">                swap(s[l], s[b[i].back()]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stoi(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Bucket sort</tag>
      </tags>
  </entry>
  <entry>
    <title>68. Text Justification</title>
    <url>/2020/12/12/68-Text-Justification/</url>
    <content><![CDATA[<p>O(n) time<br>要确认一下单词长度是否会超过limit</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">fullJustify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = words.size(); i &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + cnt &lt; n &amp;&amp; len + words[i + cnt].length() + cnt &lt;= maxWidth) &#123; <span class="comment">// 统计这一行所有单词的总长度以及个数</span></span><br><span class="line">                len += words[i + cnt].length();</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> line = words[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cnt; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + cnt &gt;= n) &#123; <span class="comment">// 如果是最后一行，每个单词之间一个空格即可</span></span><br><span class="line">                    line += <span class="string">&quot; &quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则按照下面的逻辑放空格，先平均放一样的空格数(maxWidth - len) / (cnt - 1)然后剩余的(maxWidth - len) % (cnt -1)个空格从前往后每个位置加一个，加完为止</span></span><br><span class="line">                    line.append((maxWidth - len) / (cnt - <span class="number">1</span>) + (j &lt;= (maxWidth - len) % (cnt - <span class="number">1</span>)), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                line += words[i + j];</span><br><span class="line">            &#125;</span><br><span class="line">            line.append(maxWidth - line.length(), <span class="string">&#x27; &#x27;</span>); <span class="comment">// 不管是长单词单独一行还是最后一行，补齐空格</span></span><br><span class="line">            res.push_back(line);</span><br><span class="line">            i += cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">fullJustify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.size(), cnt = <span class="number">-1</span>; <span class="comment">// cnt初始化为-1因为开始第一个单词前边不用加空格</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indices; <span class="comment">// 把每一行的单词的下标存起来</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt + <span class="number">1</span> + words[i].length() &lt;= maxWidth) &#123; <span class="comment">// 如果当前的单词能放在这一行上</span></span><br><span class="line">                cnt += <span class="number">1</span> + words[i].length(); <span class="comment">// 加一个空格和当前单词</span></span><br><span class="line">                indices.push_back(i); <span class="comment">// 把当前单词的下标存起来</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; spaces; <span class="comment">// 计算每个单词前边的空格个数</span></span><br><span class="line">                <span class="keyword">int</span> slots = indices.size() - <span class="number">1</span>, total = maxWidth - cnt + slots; <span class="comment">// 初始化有多少个位置要放空格以及这一行总的空格个数</span></span><br><span class="line">                <span class="built_in">string</span> s = words[indices[<span class="number">0</span>]];</span><br><span class="line">                <span class="keyword">if</span> (slots == <span class="number">0</span>) &#123; <span class="comment">// 如果只有一个单词（超长单词）直接放即可</span></span><br><span class="line">                    s.append(total, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不止一个单词</span></span><br><span class="line">                    <span class="keyword">while</span> (total &gt; <span class="number">0</span>) &#123; <span class="comment">// 从后往前算平均数，比如18个空格5个单词，四个位置空格数分别为[5, 5, 4, 4]</span></span><br><span class="line">                        <span class="keyword">int</span> space = total / slots--;</span><br><span class="line">                        spaces.push(space);</span><br><span class="line">                        total -= space;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; indices.size(); ++j) &#123; <span class="comment">// 算好空格数以后开始拼这行</span></span><br><span class="line">                        s.append(spaces.top(), <span class="string">&#x27; &#x27;</span>).append(words[indices[j]]);</span><br><span class="line">                        spaces.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(s);</span><br><span class="line">                cnt = words[i].length(); <span class="comment">// 结束这行以后cnt为当前单词长度，因为words[i]被挤下来了</span></span><br><span class="line">                indices = &#123;i&#125;; <span class="comment">// 结束这行以后indices放入当前单词下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123; <span class="comment">// 如果是最后一个单词，则肯定是最后一行，不计算空格数，直接放即可</span></span><br><span class="line">                <span class="built_in">string</span> s = words[indices[<span class="number">0</span>]];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; indices.size(); ++j) &#123;</span><br><span class="line">                    s += <span class="string">&quot; &quot;</span> + words[indices[j]];</span><br><span class="line">                &#125;</span><br><span class="line">                s += <span class="built_in">string</span>(maxWidth - s.length(), <span class="string">&#x27; &#x27;</span>); <span class="comment">// 最后要补足空格</span></span><br><span class="line">                res.push_back(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>680. Valid Palindrome II</title>
    <url>/2020/11/22/680-Valid-Palindrome-II/</url>
    <content><![CDATA[<p>O(n) 两个指针l和r从外往内扫描，如果遇到两个字符s[l]和s[r]不一样，则分别判断s[l:r-1]和s[l+1:r]是不是回文串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = s.length(), l = <span class="number">0</span>, r = n - <span class="number">1</span>; l &lt; r; ++l, --r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l] != s[r]) &#123;</span><br><span class="line">                <span class="keyword">return</span> isPalin(s, l, r - <span class="number">1</span>) || isPalin(s, l + <span class="number">1</span>, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalin</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l++] != s[r--]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l] != s[r]) &#123;</span><br><span class="line">                ++cnt1;</span><br><span class="line">                <span class="keyword">if</span> (cnt1 &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[l + <span class="number">1</span>] == s[r]) &#123;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[l] == s[r - <span class="number">1</span>]) &#123;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">        l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l] != s[r]) &#123;</span><br><span class="line">                ++cnt2;</span><br><span class="line">                <span class="keyword">if</span> (cnt2 &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[l] == s[r - <span class="number">1</span>]) &#123;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[l + <span class="number">1</span>] == s[r]) &#123;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt1 &lt; <span class="number">2</span> || cnt2 &lt; <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Palindrome</tag>
      </tags>
  </entry>
  <entry>
    <title>688. Knight Probability in Chessboard</title>
    <url>/2020/12/17/688-Knight-Probability-in-Chessboard/</url>
    <content><![CDATA[<p>dp O(N^2K) time O(N^2) space<br>千万不要理解成bfs！！！每走一步需要记录整个棋盘的状态，所以是dp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; f(N, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;(N));</span><br><span class="line">        f[r][c] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dr[] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;, dc[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span> ,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (K-- &gt; <span class="number">0</span>) &#123; <span class="comment">// 每走一步，重绘棋盘</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; t(N, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;(N));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; N; ++r) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N; ++c) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (f[r][c] &lt; <span class="number">1e-8</span>) <span class="keyword">continue</span>; <span class="comment">// 浮点数，不要直接跟0比</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                        <span class="keyword">int</span> rr = r + dr[i], cc= c + dc[i];</span><br><span class="line">                        <span class="keyword">if</span> (rr &lt; <span class="number">0</span> || rr &gt;= N || cc &lt; <span class="number">0</span> || cc &gt;= N) <span class="keyword">continue</span>;</span><br><span class="line">                        t[rr][cc] += f[r][c] * <span class="number">0.125</span>; <span class="comment">// 累加当前位置出现queen的概率</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            t.swap(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; N; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N; ++c) &#123;</span><br><span class="line">                res += f[r][c]; <span class="comment">// 累加当前棋盘所有位置queen出现的概率和</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>689. Maximum Sum of 3 Non-Overlapping Subarrays</title>
    <url>/2020/12/05/689-Maximum-Sum-of-3-Non-Overlapping-Subarrays/</url>
    <content><![CDATA[<p>dp 非典型 O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSumOfThreeSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n - k + <span class="number">1</span>)</span></span>;</span><br><span class="line">        w[<span class="number">0</span>] = accumulate(begin(nums), begin(nums) + k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; w.size(); ++i) &#123;</span><br><span class="line">            w[i] = w[i - <span class="number">1</span>] - nums[i - <span class="number">1</span>] + nums[i + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n - <span class="number">3</span> * k + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, best = i; i &lt; left.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; w[best]) &#123;</span><br><span class="line">                best = i;</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = best;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(n - k + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k, best = i; i &gt;= <span class="number">2</span> * k; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt;= w[best]) &#123;</span><br><span class="line">                best = i;</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = best;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k, best = <span class="number">0</span>; i &lt;= n - <span class="number">2</span> * k; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = left[i - k], r = right[i + k];</span><br><span class="line">            <span class="keyword">if</span> (w[l] + w[i] + w[r] &gt; best) &#123;</span><br><span class="line">                best = w[l] + w[i] + w[r];</span><br><span class="line">                res = &#123;l, i, r&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSumOfThreeSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">presum</span><span class="params">(n + <span class="number">1</span>)</span></span>; <span class="comment">// 计算前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            presum[i] = presum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n - k + <span class="number">1</span>)</span></span>; <span class="comment">// 计算所有的相邻k个元素和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.size(); ++i) &#123;</span><br><span class="line">            w[i] = presum[i + k] - presum[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n - <span class="number">3</span> * k + <span class="number">1</span>)</span></span>; <span class="comment">// 计算左边的所有下标使得对应下标开始的k元素和是到当前下标为止最大的</span></span><br><span class="line">        <span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; w[best]) &#123;</span><br><span class="line">                best = i;</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = best; <span class="comment">// best是全局最优，对每个left[i]记录当前全局最优值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(w.size())</span></span>; <span class="comment">// 因为用的是绝对下标，所以right数组的大小要和w保持一致</span></span><br><span class="line">        best = w.size() - <span class="number">1</span>; <span class="comment">// 右侧全局最优值从倒数第k个开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = w.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 这里一定要从右往左计算，因为我们只关心当前下标右侧的全局最优值</span></span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt;= w[best]) &#123; <span class="comment">// 这里一定要是&gt;=因为我们要取字典序较小的下标，如果两个下标对应的k元素和相等，则取左侧较小的下标</span></span><br><span class="line">                best = i;</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = best;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; w.size() - k; ++i) &#123; <span class="comment">// 遍历中间的下标</span></span><br><span class="line">            <span class="keyword">int</span> l = left[i - k], r = right[i + k]; <span class="comment">// 获取当前下标左侧和右侧的最优下标</span></span><br><span class="line">            <span class="keyword">int</span> sum = w[l] + w[i] + w[r]; <span class="comment">// 查看三个下标对应的k元素和是否是整个数组最大和，是的话就更新</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; mx) &#123;</span><br><span class="line">                mx = sum;</span><br><span class="line">                res = &#123;l, i, r&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用这个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSumOfThreeSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(nums);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n)</span></span>;</span><br><span class="line">        w[<span class="number">0</span>] = accumulate(begin(nums), begin(nums) + k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + k &lt;= n; ++i) &#123;</span><br><span class="line">            w[i] = w[i - <span class="number">1</span>] - nums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span> + k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + k &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; w[best]) &#123;</span><br><span class="line">                best = i;</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = best;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        best = n - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - k; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt;= w[best]) &#123;</span><br><span class="line">                best = i;</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = best;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        best = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i + k + k &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = left[i - k], r = right[i + k];</span><br><span class="line">            <span class="keyword">if</span> (w[l] + w[i] + w[r] &gt; best) &#123;</span><br><span class="line">                best = w[l] + w[i] + w[r];</span><br><span class="line">                res = &#123;l, i, r&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>7. Reverse Integer</title>
    <url>/2020/05/30/7-Reverse-Integer/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        res, MAX = <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">        sign = -<span class="number">1</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        x = <span class="built_in">abs</span>(x)</span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> res &gt; MAX: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> res * sign</span><br></pre></td></tr></table></figure>
<p>这道题不需要保存负号，直接转即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (res &lt; INT_MIN || res &gt; INT_MAX) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 只要invalid就返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == INT_MIN || x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = x &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        x = <span class="built_in">abs</span>(x);</span><br><span class="line">        <span class="built_in">string</span> s = to_string(x);</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.back() == <span class="string">&#x27;0&#x27;</span>) s.pop_back();</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> rit = s.rbegin(); rit != s.rend(); ++rit) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + *rit - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (res &gt; INT_MAX) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Integer</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>708. Insert into a Sorted Circular Linked List</title>
    <url>/2020/11/29/708-Insert-into-a-Sorted-Circular-Linked-List/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>one pass</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            <span class="keyword">auto</span> res = <span class="keyword">new</span> Node(insertVal);</span><br><span class="line">            res-&gt;next = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> prev = head, curr = head-&gt;next;</span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">// 因为上来如果判断prev != head没法写循环，改成dowhile就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (prev-&gt;val &lt;= insertVal &amp;&amp; insertVal &lt;= curr-&gt;val) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (prev-&gt;val &gt; curr-&gt;val &amp;&amp; (prev-&gt;val &lt;= insertVal || insertVal &lt;= curr-&gt;val)) <span class="keyword">break</span>;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = prev-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (prev != head);</span><br><span class="line">        prev-&gt;next = <span class="keyword">new</span> Node(insertVal, curr);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123; <span class="comment">// 一定要注意空表！！！</span></span><br><span class="line">            <span class="keyword">auto</span> res = <span class="keyword">new</span> Node(insertVal);</span><br><span class="line">            res-&gt;next = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> prev = head, curr = prev-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (curr != head) &#123; <span class="comment">// curr == head说明已经找了一圈了都不符合要求，这是最后一个，只能这个了</span></span><br><span class="line">            <span class="keyword">if</span> (prev-&gt;val &lt;= insertVal &amp;&amp; insertVal &lt;= curr-&gt;val) <span class="keyword">break</span>; <span class="comment">// 终止条件1：insertVal恰好在prev和curr之间</span></span><br><span class="line">            <span class="keyword">if</span> (prev-&gt;val &gt; curr-&gt;val &amp;&amp; (prev-&gt;val &lt;= insertVal || insertVal &lt;= curr-&gt;val)) <span class="keyword">break</span>; <span class="comment">// 终止条件2：升序序列，insertVal恰好比最大的数大或者比最小的数小，必须最大的严格大于最小的，否则可能插入错误</span></span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = prev-&gt;next;</span><br><span class="line">        &#125; <span class="comment">// 如果都不符合要求，则说明head之前就是应该插入的地方</span></span><br><span class="line">        prev-&gt;next = <span class="keyword">new</span> Node(insertVal, curr);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>two pass</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            <span class="keyword">auto</span> res = <span class="keyword">new</span> Node(insertVal);</span><br><span class="line">            res-&gt;next = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;next != head &amp;&amp; curr-&gt;val &lt;= curr-&gt;next-&gt;val) &#123;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> prev = curr, smallest = prev-&gt;next;</span><br><span class="line">        curr = smallest;</span><br><span class="line">        <span class="keyword">while</span> (curr-&gt;val &lt; insertVal) &#123;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = prev-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (curr == smallest) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev-&gt;next = <span class="keyword">new</span> Node(insertVal, curr);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>71. Simplify Path</title>
    <url>/2020/12/06/71-Simplify-Path/</url>
    <content><![CDATA[<p>O(n) n是路径层数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">while</span> (getline(input, s, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty() || s == <span class="string">&quot;.&quot;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="string">&quot;..&quot;</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (!v.empty()) &#123;</span><br><span class="line">                     v.pop_back();</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v.push_back(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v.empty()) <span class="keyword">return</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : v) &#123;</span><br><span class="line">            res = res + <span class="string">&quot;/&quot;</span> + s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>718. Maximum Length of Repeated Subarray</title>
    <url>/2020/12/12/718-Maximum-Length-of-Repeated-Subarray/</url>
    <content><![CDATA[<p>bisection+rolling hash O((m + n)log(min(m, n))) time O(m + n) space<br>思路就是二分可能的非法结果，找到第一个（最小的）非法结果，即能找到最大的合法结果，对每个非法结果（长度），分别枚举两个数组的子数组进行比对，这里引入rolling hash来加速，即把第一个数组的指定长度的子数组的rolling hash记录下来，再分别计算第二个数组的子数组的rolling hash值进行比对，如果能找到一致的值再挨个比对两个子数组的每个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        m = A.size(), n = B.size();</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>, hi = min(m, n) + <span class="number">1</span>; <span class="comment">// find first INVALID length，因为可能的合法结果是从0到min(m, n)，所以不合法结果的范围整体偏移1，目的是方便写二分，如果正常二分枚举合法结果，最后要不死循环，要不就得最后单独再判断一次</span></span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isValid(A, B, mid)) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> hi_pow = <span class="number">1</span>, ah = <span class="number">0</span>, bh = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123; <span class="comment">// 这里求的是base的len - 1次方</span></span><br><span class="line">            hi_pow = hi_pow * base % M;</span><br><span class="line">            ah = (ah * base + A[i]) % M;</span><br><span class="line">            bh = (bh * base + B[i]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= len) &#123;</span><br><span class="line">                ah = (ah + ((M - A[i - len]) % M) * hi_pow) % M; <span class="comment">// 这里为了避免产生负数要单独处理</span></span><br><span class="line">            &#125;</span><br><span class="line">            ah = (ah * base + A[i]) % M;</span><br><span class="line">            table[ah].push_back(i - len + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= len) &#123;</span><br><span class="line">                bh = (bh + ((M - B[i - len]) % M) * hi_pow) % M;</span><br><span class="line">            &#125;</span><br><span class="line">            bh = (bh * base + B[i]) % M;</span><br><span class="line">            <span class="keyword">if</span> (table.count(bh)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j : table[bh]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (; k &lt; len; ++k) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (A[j + k] != B[i - len + <span class="number">1</span> + k]) <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (k == len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n, M = INT_MAX, base = <span class="number">100</span>; <span class="comment">// 这道题所有数都小于100，否则不能这么用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp O(mn) time O(mn) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.size(), n = B.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res, f[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>Binary search</tag>
        <tag>Rolling hash</tag>
      </tags>
  </entry>
  <entry>
    <title>727. Minimum Window Subsequence</title>
    <url>/2020/12/13/727-Minimum-Window-Subsequence/</url>
    <content><![CDATA[<p>这道题跟<a href="https://leetcode.com/problems/minimum-window-substring/">76. Minimum Window Substring</a>不一样，那个题是找anagram，不需要保持顺序，这个需要<br>O(mn) time O(mn) space<br>把S的每个字符的位置按顺序记录在对应的T的每个字符的bucket里，因为S里的子序列必须严格follow T的顺序所以T的每个bucket对应的下标必须严格递增，扫描所有的bucket将不合法的下标排除，每次扫完更新全局结果即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; c2q;</span><br><span class="line">        <span class="keyword">int</span> m = S.length(), n = T.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            c2q[T[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;&gt; q(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c2q.count(S[i])) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j : c2q[S[i]]) &#123;</span><br><span class="line">                    q[j].push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">-1</span>, r = m;</span><br><span class="line">        <span class="keyword">while</span> (!q[<span class="number">0</span>].empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!q[i].empty() &amp;&amp; q[i - <span class="number">1</span>].front() &gt;= q[i].front()) &#123;</span><br><span class="line">                    q[i].pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (q[i].empty()) <span class="keyword">return</span> l == <span class="number">-1</span> ? <span class="string">&quot;&quot;</span> : S.substr(l, r + <span class="number">1</span> - l); <span class="comment">// 如果有任何一个bucket空了，说明S里不存在合法的子序列或者之前已找到的子序列已经最优</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q[n - <span class="number">1</span>].front() - q[<span class="number">0</span>].front() &lt; r - l) &#123;</span><br><span class="line">                l = q[<span class="number">0</span>].front();</span><br><span class="line">                r = q[n - <span class="number">1</span>].front();</span><br><span class="line">            &#125;</span><br><span class="line">            q[<span class="number">0</span>].pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S.substr(l, r + <span class="number">1</span> - l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>双指针 O(mn) time O(1) space<br>先正着扫找符合要求的子序列，再倒着扫找到最短的子序列，类似sliding window</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">-1</span>, len = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = size(S), n = size(T), i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m;) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123; <span class="comment">// 正向在S里找到第一个包含T序列的子串</span></span><br><span class="line">                <span class="keyword">if</span> (S[i] == T[j]) ++j;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == n) &#123; <span class="comment">// 如果找到</span></span><br><span class="line">                <span class="keyword">int</span> e = i; <span class="comment">// 先记录当前尾下标</span></span><br><span class="line">                --i; --j; <span class="comment">// 回退两个指针</span></span><br><span class="line">                <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123; <span class="comment">// 倒着在当前子串里找最大的起始下标</span></span><br><span class="line">                    <span class="keyword">if</span> (S[i] == T[j]) --j;</span><br><span class="line">                    --i;</span><br><span class="line">                &#125;</span><br><span class="line">                ++i; ++j; <span class="comment">// 修正指针得到最大起始下标</span></span><br><span class="line">                <span class="keyword">if</span> (e - i &lt; len) &#123; <span class="comment">// 更新结果</span></span><br><span class="line">                    len = e - i;</span><br><span class="line">                    b = i;</span><br><span class="line">                &#125;</span><br><span class="line">                ++i; <span class="comment">// 别忘了找到了一个可能结果还要往前移动指针继续找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">-1</span> ? <span class="string">&quot;&quot;</span> : S.substr(b, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp O(mn) time O(mn) space<br>f[i][j]表示S的前i个字符里包括T的前j个字符的子序列的最大的起始下标<br>需要维护一个全局最小起始下标和全局最小子序列长度<br>如果S[i - 1] == T[j - 1]则f[i][j]直接继承f[i - 1][j - 1]否则f[i][j]继承f[i - 1][j]即S的前i - 2个字符里包括T的前j个字符的子序列的最大的起始下标</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = S.length(), n = T.length(), mn = m, b = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123; <span class="comment">// S的前i个字符和T的前0个字符空串的最大起始下标即为i这样f[i][0] - i为0，即不存在这样的子序列</span></span><br><span class="line">            f[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(i, n); ++j) &#123;</span><br><span class="line">                f[i][j] = S[i - <span class="number">1</span>] == T[j - <span class="number">1</span>] ? f[i - <span class="number">1</span>][j - <span class="number">1</span>] : f[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f[i][n] != <span class="number">-1</span>) &#123; <span class="comment">// 如果S的前i个字符包括整个T则进行更新</span></span><br><span class="line">                <span class="keyword">if</span> (i - f[i][n] &lt; mn) &#123;</span><br><span class="line">                    mn = i - f[i][n];</span><br><span class="line">                    b = f[i][n];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">-1</span> ? <span class="string">&quot;&quot;</span> : S.substr(b, mn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp O(mn) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = S.length(), n = T.length(), mn = m, b = <span class="number">-1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">            t[<span class="number">0</span>] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(i, n); ++j) &#123;</span><br><span class="line">                t[j] = S[i - <span class="number">1</span>] == T[j - <span class="number">1</span>] ? f[j - <span class="number">1</span>] : f[j];</span><br><span class="line">            &#125;</span><br><span class="line">            t.swap(f);</span><br><span class="line">            <span class="keyword">if</span> (f[n] != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - f[n] &lt; mn) &#123;</span><br><span class="line">                    mn = i - f[n];</span><br><span class="line">                    b = f[n];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">-1</span> ? <span class="string">&quot;&quot;</span> : S.substr(b, mn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>758. Bold Words in String</title>
    <url>/2020/12/03/758-Bold-Words-in-String/</url>
    <content><![CDATA[<p>worst case O(n*sum{dict[i].length}) time<br>纯暴力<br>维护一个bold数组标明每个字符是否需要bold<br>和<a href="https://leetcode.com/problems/add-bold-tag-in-string/">616. Add Bold Tag in String</a>是同一道题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">boldWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(S);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">bold</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : words) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                p = S.find(w, p + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">                fill_n(begin(bold) + p, size(w), <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bold[i] &amp;&amp; (i == <span class="number">0</span> || !bold[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                res += <span class="string">&quot;&lt;b&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += S[i];</span><br><span class="line">            <span class="keyword">if</span> (bold[i] &amp;&amp; (i == n - <span class="number">1</span> || !bold[i + <span class="number">1</span>])) &#123;</span><br><span class="line">                res += <span class="string">&quot;&lt;/b&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>String</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>76. Minimum Window Substring</title>
    <url>/2020/12/01/76-Minimum-Window-Substring/</url>
    <content><![CDATA[<p>O(n) 想象成柱状图，每个字母频数是一个柱，先把t中的字母频数加上去，然后r指针遍历s每个字符（扩大窗口），先减小各个字母的频数，然后l指针再二次遍历每个字符（缩小窗口）同时增大各个字母的频数直到恢复为正</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t) &#123;</span><br><span class="line">            ++f[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), m = t.length(), ll = <span class="number">-1</span>, rr = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>, l = <span class="number">0</span>, cnt = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--f[s[r]] &gt;= <span class="number">0</span>) &#123; <span class="comment">// 先扩大窗口右端</span></span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cnt == m) &#123; <span class="comment">// 如果当前窗口里包含T的所有字符</span></span><br><span class="line">                <span class="keyword">if</span> (r - l &lt; rr - ll) &#123; <span class="comment">// 更新结果</span></span><br><span class="line">                    ll = l;</span><br><span class="line">                    rr = r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (++f[s[l++]] &gt; <span class="number">0</span>) &#123; <span class="comment">// 缩小窗口左端看能不能找到更小的符合要求的窗口</span></span><br><span class="line">                    --cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ll == <span class="number">-1</span> ? <span class="string">&quot;&quot;</span> : s.substr(ll, rr + <span class="number">1</span> - ll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> smap[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, tmap[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : t) &#123;</span><br><span class="line">            ++tmap[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), window = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = i; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; !contains(smap, tmap)) &#123;</span><br><span class="line">                ++smap[s[j++]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (contains(smap, tmap) &amp;&amp; j - i &lt; window) &#123;</span><br><span class="line">                window = j - i;</span><br><span class="line">                res = s.substr(i, window);</span><br><span class="line">            &#125;</span><br><span class="line">            --smap[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> smap[], <span class="keyword">int</span> tmap[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (smap[i] &lt; tmap[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>766. Toeplitz Matrix</title>
    <url>/2020/12/05/766-Toeplitz-Matrix/</url>
    <content><![CDATA[<p>O(mn) time O(1) space<br>逐行扫描，每一行前n-1个应该和下一行后n-1个一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isToeplitzMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = size(matrix), n = size(matrix[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; m; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; n; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[r][c] != matrix[r - <span class="number">1</span>][c - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>朴素解法，检查每个对角线</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isToeplitzMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = size(matrix), n = size(matrix[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> - n; i &lt;= m - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">bool</span> set1st = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = max(<span class="number">0</span>, i); r &lt;= min(m - <span class="number">1</span>, i + n - <span class="number">1</span>); ++r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set1st) &#123;</span><br><span class="line">                    x = matrix[r][r - i];</span><br><span class="line">                    set1st = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (x != matrix[r][r - i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>772. Basic Calculator III</title>
    <url>/2020/12/13/772-Basic-Calculator-III/</url>
    <content><![CDATA[<p>O(n) time<br>通用解法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        s += <span class="string">&quot;+&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> calc(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> &amp;i)</span> </span>&#123; <span class="comment">// 用函数调用来模拟栈操作，这里i必须是引用</span></span><br><span class="line">        <span class="keyword">char</span> op = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="keyword">long</span> n = s.size(), num = <span class="number">0</span>, curRes = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                num = calc(s, ++i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">// +-*/)五种操作符都要运行</span></span><br><span class="line">                <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: curRes += num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: curRes -= num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: curRes *= num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: curRes /= num; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;)&#x27;</span>) &#123; <span class="comment">// 只要不是*/都要对前面进行一次累加操作</span></span><br><span class="line">                    res += curRes;</span><br><span class="line">                    curRes = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                op = c;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        s += <span class="string">&quot;+&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> calc(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> &amp;i)</span> </span>&#123; <span class="comment">// 用函数调用来模拟栈操作，这里i必须是引用</span></span><br><span class="line">        <span class="keyword">char</span> op = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="keyword">long</span> n = s.size(), num = <span class="number">0</span>, curRes = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n &amp;&amp; op != <span class="string">&#x27;)&#x27;</span>; ++i) &#123; <span class="comment">// 结束条件是op != &#x27;)&#x27;而不是c != &#x27;)&#x27;因为即便c是&#x27;)&#x27;也需要用op来进行一步操作</span></span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                num = calc(s, ++i);</span><br><span class="line">                --i; <span class="comment">// 因为当op是&#x27;)&#x27;才返回，这时i已经指向了&#x27;)&#x27;的下一个，所以要回退一个</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">// +-*/)五种操作符都要运行</span></span><br><span class="line">                <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: curRes += num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: curRes -= num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: curRes *= num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: curRes /= num; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;)&#x27;</span>) &#123; <span class="comment">// 只要不是*/都要对前面进行一次累加操作</span></span><br><span class="line">                    res += curRes;</span><br><span class="line">                    curRes = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                op = c;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>recursive<br>worst case O(n^2) time<br>1-2*3 ==&gt; 0+1+-2*3+<br>遇到左括号找对应的右括号递归处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> op = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        s += <span class="string">&quot;+&quot;</span>; <span class="comment">// 补一个+方便操作</span></span><br><span class="line">        <span class="keyword">long</span> n = s.size(), num = <span class="number">0</span>, curRes = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i, cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) ++cnt;</span><br><span class="line">                    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) --cnt;</span><br><span class="line">                    <span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 括号匹配</span></span><br><span class="line">                &#125;</span><br><span class="line">                num = calculate(s.substr(j + <span class="number">1</span>, i - j - <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (op) &#123; <span class="comment">// 这个op不是当前的，是之前的，即curRes op num c</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: curRes += num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: curRes -= num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: curRes *= num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: curRes /= num; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    res += curRes;</span><br><span class="line">                    curRes = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                op = c;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>stack O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        s.erase(remove_if(s.begin(), s.end(), [](<span class="keyword">char</span> c) &#123;<span class="keyword">return</span> c == <span class="string">&#x27; &#x27;</span>;&#125;), s.end()); <span class="comment">// 先去掉多余的空格</span></span><br><span class="line">        s = <span class="string">&quot;(&quot;</span> + s + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (s[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; !<span class="built_in">isdigit</span>(s[i - <span class="number">1</span>]) &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                        opnd.push_back(x);</span><br><span class="line">                        x = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!optr.empty() &amp;&amp; optr.back() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        eval();</span><br><span class="line">                    &#125;</span><br><span class="line">                    optr.push_back(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        optr.push_back(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">                        opnd.push_back(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                        optr.back() = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                        optr.back() = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                        opnd.back() *= <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                        opnd.push_back(x);</span><br><span class="line">                        x = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (!optr.empty() &amp;&amp; optr.back() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                            eval();</span><br><span class="line">                        &#125;</span><br><span class="line">                        optr.push_back(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!optr.empty() &amp;&amp; optr.back() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                            eval();</span><br><span class="line">                        &#125;</span><br><span class="line">                        optr.push_back(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                        opnd.push_back(x);</span><br><span class="line">                        x = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!optr.empty() &amp;&amp; (optr.back() == <span class="string">&#x27;*&#x27;</span> || optr.back() == <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">                        eval();</span><br><span class="line">                    &#125;</span><br><span class="line">                    optr.push_back(s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: &#123;</span><br><span class="line">                    optr.push_back(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                        opnd.push_back(x);</span><br><span class="line">                        x = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (optr.back() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        eval();</span><br><span class="line">                    &#125;</span><br><span class="line">                    optr.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    x = x * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> opnd.back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> op = optr.back(); optr.pop_back();</span><br><span class="line">        <span class="keyword">auto</span> b = opnd.back(); opnd.pop_back();</span><br><span class="line">        <span class="keyword">auto</span> a = opnd.back(); opnd.pop_back();</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: opnd.push_back(a + b); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: opnd.push_back(a - b); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: opnd.push_back(a * b); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: opnd.push_back(<span class="built_in">floor</span>((<span class="keyword">double</span>)a / b)); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; optr;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; opnd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Stack</tag>
        <tag>Calculator</tag>
      </tags>
  </entry>
  <entry>
    <title>785. Is Graph Bipartite?</title>
    <url>/2020/12/01/785-Is-Graph-Bipartite/</url>
    <content><![CDATA[<p>着色法 O(V+E) time O(v) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.size();</span><br><span class="line">        colors.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (colors[i] == <span class="number">0</span> &amp;&amp; !dfs(graph, i, <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph, <span class="keyword">int</span> node, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (colors[node] != <span class="number">0</span>) <span class="keyword">return</span> colors[node] == color;</span><br><span class="line">        colors[node] = color;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(graph, neighbor, -color)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; colors;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Backtracking</tag>
        <tag>Bipartite</tag>
      </tags>
  </entry>
  <entry>
    <title>721. Accounts Merge</title>
    <url>/2020/11/23/721-Accounts-Merge/</url>
    <content><![CDATA[<p>union-find O(sum(Ai logAi)) time O(sum(Ai)) space where Ai = accounts[i].length()<br>用一个hashmap维护email和其对应的accounts的下标i<br>当不同account有相同的email时，merge对应的两个下标<br>最后整理原来accounts每个下标对应的所有email以及name即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; accountsMerge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n = accounts.size();</span><br><span class="line">        parent.resize(n);</span><br><span class="line">        iota(begin(parent), end(parent), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; accounts[i].size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m.count(accounts[i][j])) &#123;</span><br><span class="line">                    merge(m[accounts[i][j]], i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    m[accounts[i][j]] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; v(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[s, i] : m) &#123;</span><br><span class="line">            v[find(i)].insert(s); <span class="comment">// 归并email</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i].empty()) <span class="keyword">continue</span>;</span><br><span class="line">            res.push_back(&#123;accounts[i][<span class="number">0</span>]&#125;); <span class="comment">// 归并email和name</span></span><br><span class="line">            res.back().insert(end(res.back()), begin(v[i]), end(v[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">            x = parent[x] = parent[parent[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        parent[find(x)] = find(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; accountsMerge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; email2id;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; email2name;</span><br><span class="line">        UF uf;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;a : accounts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!email2id.count(a[<span class="number">1</span>])) &#123;</span><br><span class="line">                    email2id[a[<span class="number">1</span>]] = id++;</span><br><span class="line">                    email2name[a[<span class="number">1</span>]] = a[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                uf.add(email2id[a[<span class="number">1</span>]]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; a.size(); ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!email2id.count(a[i])) &#123;</span><br><span class="line">                        email2id[a[i]] = id++;</span><br><span class="line">                        email2name[a[i]] = a[<span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    uf.add(email2id[a[i]]);</span><br><span class="line">                    uf.merge(email2id[a[<span class="number">1</span>]], email2id[a[i]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : email2id) &#123;</span><br><span class="line">            m[uf.getParent(email2id[p.first])].insert(p.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : m) &#123;</span><br><span class="line">            res.push_back(&#123;email2name[*p.second.begin()]&#125;);</span><br><span class="line">            res.back().insert(res.back().end(), p.second.begin(), p.second.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UF</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (parent.count(x)) <span class="keyword">return</span>;</span><br><span class="line">            parent[x] = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getParent</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">                x = parent[x] = parent[parent[x]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            parent[getParent(x)] = getParent(y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; parent;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; accountsMerge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt;&gt; m;</span><br><span class="line">        UF uf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;a : accounts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                uf.add(a[<span class="number">1</span>]);</span><br><span class="line">                m[a[<span class="number">1</span>]].first = a[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; a.size(); ++i) &#123;</span><br><span class="line">                    uf.add(a[i]);</span><br><span class="line">                    m[a[i]].first = a[<span class="number">0</span>];</span><br><span class="line">                    uf.merge(a[<span class="number">1</span>], a[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : m) &#123;</span><br><span class="line">            m[uf.getParent(p.first)].second.insert(p.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p.second.second.empty()) &#123;</span><br><span class="line">                res.push_back(&#123;p.second.first&#125;);</span><br><span class="line">                res.back().insert(res.back().end(), p.second.second.begin(), p.second.second.end());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UF</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (parent.count(s)) <span class="keyword">return</span>;</span><br><span class="line">            parent[s] = s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">getParent</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (parent[s] != s) &#123;</span><br><span class="line">                s = parent[s] = parent[parent[s]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent[s];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;x, <span class="keyword">const</span> <span class="built_in">string</span> &amp;y)</span> </span>&#123;</span><br><span class="line">            parent[getParent(x)] = getParent(y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; parent;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>8. String to Integer (atoi)</title>
    <url>/2020/05/30/8-String-to-Integer-atoi/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span>(<span class="params">self, <span class="built_in">str</span>: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        res, MAX, MIN = <span class="number">0</span>, (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>, -(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)</span><br><span class="line">        <span class="built_in">str</span> = <span class="built_in">str</span>.lstrip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">str</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        sign, i = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">str</span>[<span class="number">0</span>] <span class="keyword">in</span> <span class="string">&#x27;+-&#x27;</span>:</span><br><span class="line">            sign, i = <span class="number">44</span> - <span class="built_in">ord</span>(<span class="built_in">str</span>[<span class="number">0</span>]), <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(<span class="built_in">str</span>)):</span><br><span class="line">            <span class="keyword">if</span> res &gt; MAX <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">str</span>[i].isdigit(): <span class="keyword">break</span></span><br><span class="line">            res = res * <span class="number">10</span> + <span class="built_in">int</span>(<span class="built_in">str</span>[i])</span><br><span class="line">        res *= sign</span><br><span class="line">        <span class="keyword">if</span> res &lt; MIN: <span class="keyword">return</span> MIN</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res &lt;= MAX <span class="keyword">else</span> MAX</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (str[b] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[b] == <span class="string">&#x27;+&#x27;</span> || str[b] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sign = <span class="number">44</span> - str[b];</span><br><span class="line">            ++b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; n &amp;&amp; <span class="built_in">isdigit</span>(str[i]) &amp;&amp; res &lt;= INT_MAX; ++i) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res *= sign;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> res &lt;= INT_MAX ? res : INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">// 去掉开始的空格</span></span><br><span class="line">        <span class="keyword">while</span> (str[b] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[b] == <span class="string">&#x27;-&#x27;</span> || str[b] == <span class="string">&#x27;+&#x27;</span>) &#123; <span class="comment">// 判断符号，注意b++</span></span><br><span class="line">            <span class="keyword">if</span> (str[b++] == <span class="string">&#x27;-&#x27;</span>) sign = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; n &amp;&amp; <span class="built_in">isdigit</span>(str[i]) &amp;&amp; res &lt;= INT_MAX; ++i) &#123; <span class="comment">// 三个条件：不能越界、必须是数字、值不能超过INT_MAX（INT_MIN可行）</span></span><br><span class="line">            res = res * <span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res *= sign;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">while</span> (b &lt; n &amp;&amp; str[b] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> ispos = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[b] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            ispos = <span class="literal">false</span>;</span><br><span class="line">            ++b;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[b] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            ++b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; n &amp;&amp; res &lt;= INT_MAX &amp;&amp; <span class="string">&#x27;0&#x27;</span> &lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>; ++i) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ispos ? min((<span class="keyword">long</span>)INT_MAX, res) : max((<span class="keyword">long</span>)INT_MIN, -res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Integer</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>79. Word Search</title>
    <url>/2020/12/13/79-Word-Search/</url>
    <content><![CDATA[<p>DFS O(mn*4^k) mn是board的宽和长，k是word长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board.empty() || board[<span class="number">0</span>].empty() || word.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exist(board, i, j, word, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">const</span> <span class="built_in">string</span> &amp;word, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == word.length()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || board[i][j] != word[b]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exist(board, i + dy[k], j + dx[k], word, b + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = word[b];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n, dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>811. Subdomain Visit Count</title>
    <url>/2020/12/12/811-Subdomain-Visit-Count/</url>
    <content><![CDATA[<p>O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">subdomainVisits</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cpdomains)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : cpdomains) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(s)</span></span>;</span><br><span class="line">            input &gt;&gt; cnt &gt;&gt; d;</span><br><span class="line">            m[d] += cnt;</span><br><span class="line">            <span class="keyword">int</span> n = d.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    m[d.substr(i + <span class="number">1</span>)] += cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : m) &#123;</span><br><span class="line">            res.push_back(to_string(p.second) + <span class="string">&quot; &quot;</span> + p.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>825. Friends Of Appropriate Ages</title>
    <url>/2020/12/02/825-Friends-Of-Appropriate-Ages/</url>
    <content><![CDATA[<p>O(A^2) time O(A) space<br>先统计每个年龄的频数，然后两两比较各个年龄<br>这个题里的第三个条件是没用的，因为第二个条件比第三个条件更严格</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numFriendRequests</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m[<span class="number">121</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : ages) &#123;</span><br><span class="line">            ++m[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">1</span>; a &lt; <span class="number">121</span>; ++a) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[a] == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 没有这个年龄的人，跳过看下一个</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= a; ++b) &#123; <span class="comment">// 这里b &gt; a是不符合条件的，所以上限设成a就行</span></span><br><span class="line">                <span class="keyword">if</span> (m[b] == <span class="number">0</span> || a &gt;= <span class="number">2</span> * b - <span class="number">14</span>) <span class="keyword">continue</span>; <span class="comment">// 如果b不符合条件则跳过看下一个</span></span><br><span class="line">                res += m[a] * m[b]; <span class="comment">// 如果a和b年龄符合条件则所有a年龄的人都可以request年龄b的人</span></span><br><span class="line">                <span class="keyword">if</span> (a == b) &#123; <span class="comment">// 如果a年龄和b年龄一样，则要减去自身，因为自己不能request自己</span></span><br><span class="line">                    res -= m[a];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(nlogn) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numFriendRequests</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ages)</span> </span>&#123;</span><br><span class="line">        sort(begin(ages), end(ages));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : ages) &#123;</span><br><span class="line">            t.push_back(<span class="number">2</span> * a - <span class="number">14</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = t.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it1 = upper_bound(begin(t), end(t), <span class="number">2</span> * ages[i] - <span class="number">14</span>); <span class="comment">// B &lt;= A(2B-14 &lt;= 2A-14)</span></span><br><span class="line">            <span class="keyword">auto</span> it = upper_bound(begin(t), it1, ages[i]); <span class="comment">// A &lt; 2 * B - 14</span></span><br><span class="line">            res += max(<span class="number">0</span>, <span class="keyword">int</span>(distance(it, it1) - <span class="number">1</span>)); <span class="comment">// 因为找B &lt;= A时找的上界多算了一个B，所以要减1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Bucket sort</tag>
      </tags>
  </entry>
  <entry>
    <title>827. Making A Large Island</title>
    <url>/2020/12/03/827-Making-A-Large-Island/</url>
    <content><![CDATA[<p>这道题的关键点是如何快速根据区域内任意一点得到整个区域的面积，并查集是一种方案，查询每个点都能返回该点所在区域的唯一的根，另外一种方案就是用dfs或者bfs对该区域统一标号（着色）并对不同区域用不同的标号（颜色）来区分，查询每个点都能返回该区域的标号（颜色）<br>dfs O(n^2) time O(n^2) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        n = grid.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">areas</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// areas表示不同颜色的岛屿面积，颜色从2开始</span></span><br><span class="line">        <span class="keyword">int</span> color = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    areas.push_back(dfs(grid, i, j, color++)); <span class="comment">// 用dfs对每个岛着色并统计面积记录下来</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (areas.size() == <span class="number">3</span> &amp;&amp; areas[<span class="number">2</span>] == n * n) <span class="keyword">return</span> areas[<span class="number">2</span>]; <span class="comment">// 如果整个grid就是一个岛，直接返回</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123; <span class="comment">// 遍历每一个0，如果与某些岛相邻则累加其面积</span></span><br><span class="line">                    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">                    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                        <span class="keyword">int</span> r = i + dr[k];</span><br><span class="line">                        <span class="keyword">int</span> c = j + dc[k];</span><br><span class="line">                        <span class="keyword">if</span> (isValid(r, c) &amp;&amp; grid[r][c] &gt; <span class="number">1</span> &amp;&amp; s.count(grid[r][c]) == <span class="number">0</span>) &#123;</span><br><span class="line">                            s.insert(grid[r][c]);</span><br><span class="line">                            sum += areas[grid[r][c]];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res = max(res, sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        grid[i][j] = color;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = i + dr[k];</span><br><span class="line">            <span class="keyword">int</span> c = j + dc[k];</span><br><span class="line">            <span class="keyword">if</span> (isValid(r, c) &amp;&amp; grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                res += dfs(grid, r, c, color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= i &amp;&amp; i &lt; n &amp;&amp; <span class="number">0</span> &lt;= j &amp;&amp; j &lt; n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, dr[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>union-find O(n^2) time O(n^2) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; borders;</span><br><span class="line">        parent.resize(n * n);</span><br><span class="line">        iota(begin(parent), end(parent), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = i * n + j;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] &amp;&amp; area.count(k) == <span class="number">0</span>) &#123;</span><br><span class="line">                    area[k] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][j]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (grid[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                            merge(k, k - <span class="number">1</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            borders[k- <span class="number">1</span>].push_back(k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (grid[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                            borders[k].push_back(k - <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][j]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (grid[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                            merge(k, k - n);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            borders[k - n].push_back(k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (grid[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                            borders[k].push_back(k - n);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (area.empty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (borders.empty()) <span class="keyword">return</span> n * n;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; p : borders) &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : p.second) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.count(find(i))) <span class="keyword">continue</span>;</span><br><span class="line">                s.insert(find(i));</span><br><span class="line">                sum += area[find(i)];</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">            x = parent[x] = parent[parent[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> px = find(x);</span><br><span class="line">        <span class="keyword">int</span> py = find(y);</span><br><span class="line">        <span class="keyword">if</span> (px != py) &#123;</span><br><span class="line">            parent[px] = py;</span><br><span class="line">            area[py] = area[py] + area[px];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; area;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Implementation</tag>
        <tag>Depth first search</tag>
        <tag>Island</tag>
        <tag>Union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>85. Maximal Rectangle</title>
    <url>/2020/12/12/85-Maximal-Rectangle/</url>
    <content><![CDATA[<p>increasing stack (<a href="https://leetcode.com/problems/largest-rectangle-in-histogram/">largest rectangle in histogram</a>) O(nm)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">height</span><span class="params">(m + <span class="number">1</span>)</span></span>; <span class="comment">// 这里一定要多一个！！方便后边算最大面积</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; n; ++row) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; m; ++col) &#123;</span><br><span class="line">                height[col] = matrix[row][col] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : height[col] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, helper(height));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s&#123;&#123;<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (s.top() != <span class="number">-1</span> &amp;&amp; height[i] &lt; height[s.top()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> h = height[s.top()];</span><br><span class="line">                s.pop();</span><br><span class="line">                res = max(res, h * (i - s.top() - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>88. Merge Sorted Array</title>
    <url>/2020/11/28/88-Merge-Sorted-Array/</url>
    <content><![CDATA[<p>O(m+n) time O(1) space<br>关键是从后往前扫描！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m + n - <span class="number">1</span>, i1 = m - <span class="number">1</span>, i2 = n - <span class="number">1</span>; i2 &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                nums1[i] = nums1[i1] &gt; nums2[i2] ? nums1[i1--] : nums2[i2--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[i] = nums2[i2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m + n - <span class="number">1</span>, i1 = m - <span class="number">1</span>, i2 = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 &gt;= <span class="number">0</span> &amp;&amp; i2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                nums1[i] = nums1[i1] &gt; nums2[i2] ? nums1[i1--] : nums2[i2--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i2 &gt;= <span class="number">0</span>) &#123; <span class="comment">// i1到头了，只扫nums2即可</span></span><br><span class="line">                nums1[i] = nums2[i2--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// i2到头了，nums1保持不变，不用再扫了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(m+n) time O(m+n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(m + n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m || j &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = i &lt; m ? nums1[i] : INT_MAX;</span><br><span class="line">            <span class="keyword">int</span> b = j &lt; n ? nums2[j] : INT_MAX;</span><br><span class="line">            res[i + j] = min(a, b);</span><br><span class="line">            <span class="keyword">if</span> (res[i + j] == a) ++i;</span><br><span class="line">            <span class="keyword">else</span> ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        nums1 = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Merging</tag>
      </tags>
  </entry>
  <entry>
    <title>896. Monotonic Array</title>
    <url>/2020/12/02/896-Monotonic-Array/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMonotonic</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), store = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = A[i - <span class="number">1</span>] &gt; A[i] ? <span class="number">-1</span> : (A[i - <span class="number">1</span>] &lt; A[i]); <span class="comment">// -1表示递减 0表示相等 1表示递增</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 相等则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (store * c &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            store = c; <span class="comment">// 只保存严格递增或递减</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMonotonic</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), isInc = <span class="number">-1</span>; <span class="comment">// -1表示还没遇到严格递增或递减</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == A[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 相邻两数相同则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (isInc == <span class="number">-1</span>) &#123; <span class="comment">// 第一次遇到严格递增或递减</span></span><br><span class="line">                isInc = A[i] &gt; A[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isInc ^ (A[i - <span class="number">1</span>] &lt; A[i])) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果之前的趋势和现在不一样，注意异或的优先级</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>9. Palindrome Number</title>
    <url>/2020/05/30/9-Palindrome-Number/</url>
    <content><![CDATA[<p>O(1) time O(1) space</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x % <span class="number">10</span> == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; y:</span><br><span class="line">            y = y * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> x == y <span class="keyword">or</span> x == y // <span class="number">10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x != <span class="number">0</span> &amp;&amp; x % <span class="number">10</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 负数和结尾是0的正数都不合法</span></span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; y) &#123;</span><br><span class="line">            y = y * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == y || x == y / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Integer</tag>
        <tag>Palindrome</tag>
      </tags>
  </entry>
  <entry>
    <title>938. Range Sum of BST</title>
    <url>/2020/12/02/938-Range-Sum-of-BST/</url>
    <content><![CDATA[<p>O(n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = L &lt;= root-&gt;val &amp;&amp; root-&gt;val &lt;= R ? root-&gt;val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; L) &#123; <span class="comment">// 必须是大于L</span></span><br><span class="line">            res += rangeSumBST(root-&gt;left, L, R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; R) &#123;</span><br><span class="line">            res += rangeSumBST(root-&gt;right, L, R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Binary search tree</tag>
      </tags>
  </entry>
  <entry>
    <title>953. Verifying an Alien Dictionary</title>
    <url>/2020/11/22/953-Verifying-an-Alien-Dictionary/</url>
    <content><![CDATA[<p>O(m*n) time O(1) space where m is the avg length of a word while n is the number of words</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlienSorted</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dict[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            dict[order[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; words.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lte(words[i - <span class="number">1</span>], words[i], dict)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lte</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b, <span class="keyword">int</span> dict[<span class="number">26</span>])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = a.length(), n = b.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min(m, n); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> dict[a[i] - <span class="string">&#x27;a&#x27;</span>] &lt;= dict[b[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m &lt;= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>973. K Closest Points to Origin</title>
    <url>/2020/11/22/973-K-Closest-Points-to-Origin/</url>
    <content><![CDATA[<p>quickselection<br>O(n) time on average O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; kClosest(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> n = points.size(), l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = partition(points, l, r);</span><br><span class="line">            <span class="keyword">if</span> (k == K - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; K - <span class="number">1</span>) &#123;</span><br><span class="line">                l = k + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = k - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(begin(points), begin(points) + K);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;l, l + (r - l) / <span class="number">2</span>, r&#125;;</span><br><span class="line">        swap(p[l], p[v[rand() % <span class="number">3</span>]]);</span><br><span class="line">        <span class="keyword">int</span> j = l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lt(p[i], p[l])) &#123;</span><br><span class="line">                swap(p[i], p[j++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(p[--j], p[l]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lt</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] * a[<span class="number">0</span>] + a[<span class="number">1</span>] * a[<span class="number">1</span>] &lt; b[<span class="number">0</span>] * b[<span class="number">0</span>] + b[<span class="number">1</span>] * b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; kClosest(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> n = points.size(), l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = partition(points, l, r);</span><br><span class="line">            <span class="keyword">if</span> (k == K - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; K - <span class="number">1</span>) &#123;</span><br><span class="line">                l = k + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = k - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(begin(points), begin(points) + K);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;l, l + (r - l) / <span class="number">2</span>, r&#125;;</span><br><span class="line">        swap(p[l], p[v[rand() % <span class="number">3</span>]]);</span><br><span class="line">        <span class="keyword">auto</span> pivot = p[l];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !lt(p[r], pivot)) --r;</span><br><span class="line">            p[l] = p[r];</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; lt(p[l], pivot)) ++l;</span><br><span class="line">            p[r] = p[l];</span><br><span class="line">        &#125;</span><br><span class="line">        p[l] = pivot;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lt</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] * a[<span class="number">0</span>] + a[<span class="number">1</span>] * a[<span class="number">1</span>] &lt; b[<span class="number">0</span>] * b[<span class="number">0</span>] + b[<span class="number">1</span>] * b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(nlogK) time O(K) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; kClosest(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="keyword">using</span> vi = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">        <span class="keyword">auto</span> less = [](<span class="keyword">const</span> vi &amp;a, <span class="keyword">const</span> vi &amp;b)&#123;<span class="keyword">return</span> a[<span class="number">0</span>] * a[<span class="number">0</span>] + a[<span class="number">1</span>] * a[<span class="number">1</span>] &lt; b[<span class="number">0</span>] * b[<span class="number">0</span>] + b[<span class="number">1</span>] * b[<span class="number">1</span>];&#125;;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;vi, <span class="built_in">vector</span>&lt;vi&gt;, <span class="keyword">decltype</span>(less)&gt; q(less);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : points) &#123;</span><br><span class="line">            q.push(p);</span><br><span class="line">            <span class="keyword">if</span> (q.size() &gt; K) &#123;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;vi&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            res.push_back(q.top());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(nlog(n-K)) time O(n-K) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; kClosest(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="keyword">using</span> vi = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">        <span class="keyword">auto</span> greater = [](<span class="keyword">const</span> vi &amp;p1, <span class="keyword">const</span> vi &amp;p2) &#123;<span class="keyword">return</span> p1[<span class="number">0</span>] * p1[<span class="number">0</span>] + p1[<span class="number">1</span>] * p1[<span class="number">1</span>] &gt; p2[<span class="number">0</span>] * p2[<span class="number">0</span>] + p2[<span class="number">1</span>] * p2[<span class="number">1</span>];&#125;;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;vi, <span class="built_in">vector</span>&lt;vi&gt;, <span class="keyword">decltype</span>(greater)&gt; q(greater);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : points) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.size() &lt; n - K) &#123;</span><br><span class="line">                q.push(p);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (greater(p, q.top())) &#123;</span><br><span class="line">                res.push_back(q.top());</span><br><span class="line">                q.pop();</span><br><span class="line">                q.push(p);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Quickselect</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>986. Interval List Intersections</title>
    <url>/2020/11/29/986-Interval-List-Intersections/</url>
    <content><![CDATA[<p>二路归并 O(m + n) time O(1) space<br>最简单的办法是取两个interval的交集，如果交集存在则存入结果，再「分别」判断『交集』的右边界和两个interval是否重合，重合则看下一个interval<br>这道题用扫描线做会非常复杂</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; intervalIntersection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; B) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.size(), n = B.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = max(A[i][<span class="number">0</span>], B[j][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> e = min(A[i][<span class="number">1</span>], B[j][<span class="number">1</span>]); <span class="comment">// 找intersection</span></span><br><span class="line">            <span class="keyword">if</span> (s &lt;= e) &#123; <span class="comment">// 如果有intersection</span></span><br><span class="line">                res.push_back(&#123;s, e&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e == A[i][<span class="number">1</span>]) &#123; <span class="comment">// 如果A[i]区间比较靠前则看下一个</span></span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e == B[j][<span class="number">1</span>]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Merging</tag>
        <tag>Sweep line</tag>
      </tags>
  </entry>
  <entry>
    <title>987. Vertical Order Traversal of a Binary Tree</title>
    <url>/2020/11/27/987-Vertical-Order-Traversal-of-a-Binary-Tree/</url>
    <content><![CDATA[<p>O(nlog(n/k)) time O(n) space<br>n是node数 k是column数 也是树的width<br>插入是O(n)<br>整理是O(k*(n/k)log(n/k)) = O(nlog(n/k))<br>跟<a href="https://leetcode.com/problems/binary-tree-vertical-order-traversal/">314. Binary Tree Vertical Order Traversal</a>的区别是要相同位置的数要按大小排序，所以排序优先级是左右上下大小，因此必须维护行号，理论上bfs和dfs均可，但dfs代码简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; verticalTraversal(TreeNode* root) &#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(mx - mn + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;[i, v] : m) &#123;</span><br><span class="line">            sort(begin(v), end(v));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[j, val] : v) &#123;</span><br><span class="line">                res[i - mn].push_back(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        m[i].emplace_back(j, root-&gt;val);</span><br><span class="line">        mn = min(mn, i);</span><br><span class="line">        mx = max(mx, i);</span><br><span class="line">        dfs(root-&gt;left, i - <span class="number">1</span>, j + <span class="number">1</span>); <span class="comment">// 因为要保证自顶向下的顺序所以这里一定要+1不能-1</span></span><br><span class="line">        dfs(root-&gt;right, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mn = INT_MAX, mx = INT_MIN;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(nlogn) time O(n) space<br>插入是O(nlogk) k是column数 也是树的width<br>整理是O(k*(n/k)log(n/k))<br>O(nlogk + k*(n/k)log(n/k)) = O(nlogk + nlog(n/k)) = O(nlog(k*(n/k))) = O(nlogn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; verticalTraversal(TreeNode* root) &#123;</span><br><span class="line">        dfs(root, <span class="number">1000</span>, <span class="number">0</span>); <span class="comment">// 宽度从1000开始，层数从0开始</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> prev = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;p : m) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = p.first / <span class="number">1000</span>; <span class="comment">// 宽度即结果数组的row</span></span><br><span class="line">            <span class="keyword">if</span> (prev != curr) &#123;</span><br><span class="line">                res.push_back(&#123;&#125;);</span><br><span class="line">                prev = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            res.back().insert(end(res.back()), begin(p.second), end(p.second));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        m[i * <span class="number">1000</span> + j].insert(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left, i - <span class="number">1</span>, j + <span class="number">1</span>); <span class="comment">// 因为要保证自顶向下的顺序所以这里一定要+1不能-1</span></span><br><span class="line">        dfs(root-&gt;right, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; m; <span class="comment">// 同一坐标的数按数大小来排序所以要用set</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果没有1000这个限制条件，则把一维map转换成二维map</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; verticalTraversal(TreeNode* root) &#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;[k, s] : m) &#123;</span><br><span class="line">            res.push_back(&#123;&#125;); <span class="comment">// 对于同一列要按照从上到下的顺序输出，同一位置再按大小输出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;[_, v] : s) &#123;</span><br><span class="line">                res.back().insert(end(res.back()), begin(v), end(v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        m[i][j].insert(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left, i - <span class="number">1</span>, j + <span class="number">1</span>); <span class="comment">// 因为要保证自顶向下的顺序所以这里一定要+1不能-1</span></span><br><span class="line">        dfs(root-&gt;right, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Depth first search</tag>
        <tag>Vertical order traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>How to bind custom domain to github page</title>
    <url>/2018/07/30/How-to-bind-custom-domain-to-github-page/</url>
    <content><![CDATA[<h3 id="CName-file"><a href="#CName-file" class="headerlink" title="CName file"></a>CName file</h3><p>Github uses a file called CNAME to redirect your site. If you read the official<br>guide it says the file must be saved under the root directory in the master branch. But remember that <strong>for us the source branch is where the raw material is and master branch is generated when you deploy</strong>. So if you put something in the master branch it will be overwritten next time you deploy your site.</p>
<a id="more"></a>

<p>Create a file called CNAME (all caps, no extension) under the <strong>source directory</strong> in the source branch and write your domain name into that file. Replace <em>mydomain.com</em> with your own domain.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="built_in">source</span>/</span><br><span class="line">$ <span class="built_in">echo</span> mydomain.com &gt; CNAME</span><br></pre></td></tr></table></figure>
<h3 id="GoDaddy-setup"><a href="#GoDaddy-setup" class="headerlink" title="GoDaddy setup"></a>GoDaddy setup</h3><ol>
<li><p>ping username.github.io and obtain your ip address</p>
</li>
<li><p>add two DNS entries</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>Type</th>
<th>Host</th>
<th>Points to</th>
<th>TTL</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>@</td>
<td>github IP</td>
<td>1 hour</td>
</tr>
<tr>
<td>CNAME</td>
<td>username.github.io</td>
<td>@</td>
<td>1 hour</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>How to check endianness</title>
    <url>/2020/05/18/How-to-check-endianness/</url>
    <content><![CDATA[<p>big-endian:</p>
<p>低地址 -&gt; 高地址</p>
<a id="more"></a>

<p>0x12345678</p>
<p>高位字节 -&gt; 低位字节</p>
<p>更具有可读性</p>
<p>Java一律是big-endian，与平台无关</p>
<hr>
<p>little-endian:</p>
<p>高地址 -&gt; 低地址</p>
<p>0x12345678</p>
<p>高位字节 -&gt; 低位字节</p>
<p>x86是little-endian</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)&amp;a;</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="number">0x78</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;little&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;big&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>Computer architecture</category>
      </categories>
      <tags>
        <tag>Computer architecture</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>How to define an alias in fish shell</title>
    <url>/2020/05/18/How-to-define-an-alias-in-fish-shell/</url>
    <content><![CDATA[<p>In fish shell, type the following commands:</p>
<a id="more"></a>

<ul>
<li>use alias<br>define alias in .config/fish/config.fish<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> foo <span class="string">&#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>use function<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">function</span> foo</span><br><span class="line">      <span class="built_in">command</span> <span class="built_in">echo</span> <span class="string">&#x27;foo was here&#x27;</span> <span class="variable">$argv</span></span><br><span class="line">  end</span><br><span class="line">$ funcsave foo</span><br></pre></td></tr></table></figure>
You should see a file <strong>foo.fish</strong> under <strong>~/.config/fish/functions/</strong></li>
</ul>
]]></content>
      <categories>
        <category>fish shell</category>
      </categories>
      <tags>
        <tag>fish shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown心得</title>
    <url>/2020/05/16/Markdown%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<ol>
<li>表格如果想正确显示一定要与前面的正文隔两行</li>
</ol>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Induction variable in Python&#39;s for loop</title>
    <url>/2020/05/31/Induction-variable-in-Python-s-for-loop/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    print(i) <span class="comment"># 0 1 2 3</span></span><br><span class="line"></span><br><span class="line">print(i) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        i += <span class="number">2</span></span><br><span class="line">    print(i) <span class="comment"># 2 1 4 3 6 5 5</span></span><br></pre></td></tr></table></figure>
<p>Conclusion:</p>
<ul>
<li>induction variable的scope不仅限于for loop</li>
<li>不管for loop内部对induction variable如何修改，for loop本身还会对其重新赋值</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Multiple inheritance</title>
    <url>/2020/12/07/Multiple-inheritance/</url>
    <content><![CDATA[<p>使用类似Java的接口类可以避免虚继承带来的开销</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.a();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Use constexpr whenever possible</title>
    <url>/2020/05/16/Use-constexpr-whenever-possible/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    constexpr Point(double x = 0, double y = 0) noexcept : x(x), y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">xValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">yValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">midpoint</span><span class="params">(<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(p1.xValue() + p2.xValue()) / <span class="number">2</span>, (p1.yValue() + p2.yValue()) / <span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">reflection</span><span class="params">(<span class="keyword">const</span> Point&amp; p)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    Point res;</span><br><span class="line">    res.setX(-p.xValue());</span><br><span class="line">    res.setY(-p.yValue());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = midpoint(p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> reflectedMid = reflection(mid);</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>The <strong>Point</strong> constructor can be declared <strong>constexpr</strong>, because if the arguments passed to it are known during compilation, the value of the data members of the constructed <strong>Point</strong> can also be known during compilation. <strong>Point</strong>s initialized could thus be <strong>constexpr</strong>. In C++14, even setters can be <strong>constexpr</strong>.</p>
<p>Conclusion:</p>
<ul>
<li><strong>constexpr</strong> objects are <strong>const</strong> and are initialized with values known during compilation.</li>
<li><strong>constexpr</strong> functions can produce compile-time results when called with arguments whose values are known during compilation.</li>
<li><strong>constexpr</strong> objects and functions may be used in a wider range of contexts than non-<strong>constexpr</strong> objects and functions.</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/07/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>practice of using move and forward</title>
    <url>/2020/05/17/practice-of-using-move-and-forward/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(Widget&amp;&amp; rhs)</span><br><span class="line">    : name(<span class="built_in">std</span>::move(rhs.name))</span><br><span class="line">    , p(<span class="built_in">std</span>::move(rhs.p)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SomeDataStructure&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = <span class="built_in">std</span>::forward&lt;T&gt;(newName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(w); <span class="comment">// DO NOT DO THIS!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget w1;</span><br><span class="line">Widget w2 = <span class="built_in">std</span>::move(w1); <span class="comment">// w1 is &quot;empty&quot;</span></span><br><span class="line">Widget &amp;&amp;w3 = <span class="built_in">std</span>::move(w2); <span class="comment">// w3 is an rvalue reference and an lvalue, no type deduction</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Widget &amp;&amp;w)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// modify w</span></span><br><span class="line">&#125;</span><br><span class="line">f(w3); <span class="comment">// compilation error! w3 is an lvalue</span></span><br><span class="line">f(<span class="built_in">std</span>::move(w3)); <span class="comment">// Okay! modifying w inside f changes w3</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>Conclusion:</p>
<ul>
<li>use <strong>std::move</strong> to rvalue references and <strong>std::forward</strong> to universal references the last time each is used</li>
<li>Do the same thing for rvalue references and universal references being returned from functions that return by value</li>
<li>Never apply <strong>std::move</strong> or <strong>std::forward</strong> to local objects if they would otherwise be eligible for the return value optimization (RVO)</li>
<li><strong>std::move</strong> performs an unconditional cast to an rvalue. In and of itself, it doesn’t move anything</li>
<li><strong>std::forward</strong> casts its argument to an rvalue only if that argument is bound to an rvalue</li>
<li>Neither <strong>std::move</strong> nor <strong>std::forward</strong> do anything at runtime</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>reference class member in C++</title>
    <url>/2020/05/16/reference-class-member-in-CPP/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> &amp;m;</span><br><span class="line">    A(<span class="keyword">int</span> &amp;x) : m(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(x)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.m &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.m &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 6</span></span><br><span class="line">    a.m = <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>size_t overflow</title>
    <url>/2020/11/22/size-t-overflow/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// your code goes here</span></span><br><span class="line">	<span class="keyword">size_t</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">auto</span> j = x - <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 18446744073709551615</span></span><br><span class="line">	<span class="keyword">int</span> i = j;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// -1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>type deduction</title>
    <url>/2020/05/16/type-deduction/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;</span><br><span class="line">f(x); <span class="comment">// x is lvalue, so T is int&amp;, param&#x27;s type is also int&amp;</span></span><br><span class="line">f(cx); <span class="comment">// cx is lvalue, so T is const int&amp;, param&#x27;s type is also const int&amp;</span></span><br><span class="line">f(rx); <span class="comment">// rx is lvalue, so T is const int&amp;, param&#x27;s type is also const int&amp;</span></span><br><span class="line">f(<span class="number">27</span>); <span class="comment">// 27 is rvalue, so T is int, param&#x27;s type is therefore int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>Conclusion: when deducing types for universal reference parameters, lvalue arguments get special treatment</p>
<ul>
<li>T&amp;&amp; lvalue =&gt; (const) T&amp; lvalue</li>
<li>T&amp;&amp; rvalue =&gt; T&amp;&amp; rvalue</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>; <span class="comment">// type is void()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>; <span class="comment">// pass by value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>; <span class="comment">// pass by reference</span></span><br><span class="line"></span><br><span class="line">f1(fun); <span class="comment">// param deduced as ptr-to-func; type is void(*)()</span></span><br><span class="line">f2(fun); <span class="comment">// param deduced as ref-to-func; type is void(&amp;)()</span></span><br></pre></td></tr></table></figure>
<p>Conclusion: during template type deduction, arguments that are function names decay to pointers, unless they are used to initialize references</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref1 = x; <span class="comment">// x is int and lvalue, so uref1&#x27;s type is int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref2 = cx; <span class="comment">// cx is const int and lvalue, so uref2&#x27;s type is const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; uref3 = <span class="number">27</span>; <span class="comment">// 27 is int and rvalue, so uref3&#x27;s type is int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>Conclusion: same as template type deduction</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">const</span> Widget&amp; cw = w;</span><br><span class="line"><span class="keyword">auto</span> myWidget1 = cw; <span class="comment">// auto type deduction: myWIdget1&#x27;s type is Widget</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) myWidget2 = cw; <span class="comment">// decltype type deduction: myWIdget2&#x27;s type is const Widget&amp;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) y = x; <span class="comment">// y&#x27;s type is int</span></span><br><span class="line">y = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) z = (x); <span class="comment">// z&#x27;s type is int&amp;</span></span><br><span class="line">z = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p><em>x</em> is the name of a variable, so <em>decltype(x)</em> is <em>int</em>. Being a name, <em>x</em> is an lvalue, and C++ defines the expression <em>(x)</em> to be an lvalue, too. <em>decltype((x))</em> is therefore <em>int&amp;</em>.</p>
<p>Conclusion:</p>
<ul>
<li> <em>decltype</em> almost always yeilds the type of a variable or expression without any modifications.</li>
<li>For lvalue expressions of type <strong>T</strong> other than names, <em>decltype</em> always reports a type of <strong>T&amp;</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">float</span> a = f(); <span class="comment">// implicitly convert double -&gt; float</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(f()); <span class="comment">// explicitly typed initializer idiom</span></span><br></pre></td></tr></table></figure>
<p>Conclusion: use explicitly typed initializer idiom for <strong>auto</strong> to deduce the type you want it to have</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>unique_ptr函数传参</title>
    <url>/2020/07/15/unique-ptr%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A::A&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~A() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A::~A&quot;</span>&lt;&lt;<span class="built_in">endl</span>;x=<span class="number">0</span>;&#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a) : x(a.x) &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;copy ctor&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    A(A&amp;&amp; a)  <span class="keyword">noexcept</span> : x(a.x) &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;move ctor&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;A&gt; &amp;&amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x-&gt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    x-&gt;x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">unique_ptr</span>&lt;A&gt; &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x-&gt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    x-&gt;x = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;A&gt; <span class="title">f3</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;A&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x-&gt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// 可以拷贝或赋值一个将要被销毁的unique_ptr （C++ Primer 5th p418）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = make_unique&lt;A&gt;(); <span class="comment">// A::A</span></span><br><span class="line">    f1(move(a)); <span class="comment">// 1</span></span><br><span class="line">    f2(a); <span class="comment">// 2</span></span><br><span class="line">    a = f3(move(a)); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// A::~A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用RAII思想来管理线程</title>
    <url>/2020/05/16/%E4%BD%BF%E7%94%A8RAII%E6%80%9D%E6%83%B3%E6%9D%A5%E7%AE%A1%E7%90%86%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread_guard</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(thread &amp;t)</span> : <span class="keyword">_t</span><span class="params">(t)</span> </span>&#123;&#125;</span><br><span class="line">    ~thread_guard() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">_t</span>.joinable()) &#123;</span><br><span class="line">            <span class="keyword">_t</span>.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread_guard(<span class="keyword">const</span> thread_guard &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    thread_guard &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> thread_guard &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    thread &amp;<span class="keyword">_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        thread t&#123;[](<span class="keyword">int</span> x) &#123; <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;, i&#125;;</span><br><span class="line">        thread_guard tg&#123;t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程分离以后的资源回收</title>
    <url>/2020/05/15/%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB%E4%BB%A5%E5%90%8E%E7%9A%84%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::~A() &quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;child&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    this_thread::sleep_for(chrono::seconds(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;parent&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    thread t&#123;child&#125;;</span><br><span class="line">    t.detach();</span><br><span class="line"><span class="comment">//    this_thread::sleep_for(chrono::seconds(1));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    parent();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//    this_thread::sleep_for(chrono::seconds(5));</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程detach以后，如果进程结束（比如main函数返回）则该detached线程的资源交给系统回收，与该线程的父线程是否返回无关（除非父线程是main函数）</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>快速启动Emacs</title>
    <url>/2020/06/27/%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8Emacs/</url>
    <content><![CDATA[<ul>
<li><p>Emacs CS模式<br>在~/.emacs里加入</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">require</span> &#x27;server)</span><br><span class="line">(<span class="name">unless</span> (<span class="name">server-running-p</span>) (<span class="name">server-start</span>))</span><br></pre></td></tr></table></figure>
<p>或者(server-start)，emacs启动的时候就会自动启动server。然后你可以利<br>用emacscilent -c命令来打开一个新的窗口，速度会非常快。这有个缺点，如果充当server<br>的emacs被关闭之后，使用客户端命令就会出现无法打开的现象。可以使用emacs –daemon&amp;<br>模式在后台打开一个emacs作为server</p>
</li>
<li><p>开机自动启动emacs<br>Linux下在~/.profile里加入emacs –daemon&amp;即可<br>以后就可以使用emacsclient -c启动客户端了</p>
</li>
<li><p>Emacs和Emacsclient<br>有的时候，快速启动得到的emacsclient不能编辑需要sudo的文件。这是因为它的server没<br>有处在root权限下，所以会出现出错的现象。另外，emacsclient下的字体背景等会和原来<br>的有差异。我的解决办法是，平时开启一个emacs进程作为主要编辑的工具，另外一个<br>emacsclient则是编辑临时文件的时候使用，这样既保证了编辑临时文件的速度问题，同样<br>尽可能的排除错误。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Emacs</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title>1168. Optimize Water Distribution in a Village</title>
    <url>/2020/12/20/1168-Optimize-Water-Distribution-in-a-Village/</url>
    <content><![CDATA[<p>MST O((V+E)log(V+E)) time O(V) space<br>这道题首先应该想到是求MST，然后思考如何抽象每个点来构造MST，观察到pipes里每个点都是1-indexed，说明应该有一个点0，解法就是加一个virtual node 0，把每个点自己的weight放到和0连起来的边上，就构成了一棵完整的0-indexed的图，求这个图的MST即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostToSupplyWater</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; wells, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pipes)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            edges.emplace_back(wells[i], <span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : pipes) &#123;</span><br><span class="line">            edges.emplace_back(p[<span class="number">2</span>], p[<span class="number">0</span>], p[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(begin(edges), end(edges));</span><br><span class="line">        parent.resize(n + <span class="number">1</span>);</span><br><span class="line">        iota(begin(parent), end(parent), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[w, u, v] : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (merge(u, v)) &#123;</span><br><span class="line">                res += w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">            x = parent[x] = parent[parent[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line">        <span class="keyword">if</span> (px == py) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        parent[px] = py;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Graph</tag>
        <tag>Greedy</tag>
        <tag>Minimum Spanning Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>157. Read N Characters Given Read4</title>
    <url>/2020/12/20/157-Read-N-Characters-Given-Read4/</url>
    <content><![CDATA[<p>iterative</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of the read4 API.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read4</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param buf Destination buffer</span></span><br><span class="line"><span class="comment">     * @param n   Number of characters to read</span></span><br><span class="line"><span class="comment">     * @return    The number of actual characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> t[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            cnt = read4(t);</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; cnt) &#123;</span><br><span class="line">                buf[i++] = t[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; n &amp;&amp; cnt == <span class="number">4</span>); <span class="comment">// 注意如果read4读出来的字符少于4个就终止</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>recursive</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of the read4 API.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read4</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param buf Destination buffer</span></span><br><span class="line"><span class="comment">     * @param n   Number of characters to read</span></span><br><span class="line"><span class="comment">     * @return    The number of actual characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> t[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = read4(t), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; cnt) &#123;</span><br><span class="line">            buf[i++] = t[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == n) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> cnt + read(buf + cnt, n - cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>155. Min Stack</title>
    <url>/2020/12/22/155-Min-Stack/</url>
    <content><![CDATA[<p>一个栈，比两个栈节省一点空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mn) &#123; <span class="comment">// 当需要修改当前最小值时，把旧的最小值压栈，然后修改，这里必须包含等于mn的情况，否则pop时无法判断栈顶下面是否压栈的是旧的mn还是另外一个数</span></span><br><span class="line">            s.push(mn); <span class="comment">// 压栈旧的最小值</span></span><br><span class="line">            mn = x; <span class="comment">// 更新最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">        s.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = s.top(); s.pop();</span><br><span class="line">        <span class="keyword">if</span> (t == mn) &#123; <span class="comment">// 当要出栈的数跟当前最小值一样时，下一个栈顶的数一定是一个旧的最小值，用这个旧的最小值来给mn赋值</span></span><br><span class="line">            mn = s.top(); s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> mn = INT_MAX;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>两个栈，一个正常栈维护数，一个最小值栈维护当前的最小值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s.push(x);</span><br><span class="line">        m.push(m.empty() ? x : min(m.top(), x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s.pop();</span><br><span class="line">        m.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>min queue<br>单调deque，最省空间<br>amortized O(1) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!m.empty() &amp;&amp; m.back() &gt; x) &#123;</span><br><span class="line">            m.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        m.push_back(x);</span><br><span class="line">        q.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m.empty() &amp;&amp; q.front() == m.front()) &#123;</span><br><span class="line">            m.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>利用<a href="https://leetcode.com/problems/implement-queue-using-stacks/">232. Implement Queue using Stacks</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        back.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rearrange();</span><br><span class="line">        <span class="keyword">return</span> front.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (!front.empty()) &#123;</span><br><span class="line">            res = min(res, front.getMin());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!back.empty()) &#123;</span><br><span class="line">            res = min(res, back.getMin());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rearrange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!back.empty()) &#123;</span><br><span class="line">                front.push(back.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack back, front;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Deque</tag>
        <tag>Stack</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>204. Count Primes</title>
    <url>/2020/12/22/204-Count-Primes/</url>
    <content><![CDATA[<p>朴素eratosthenes筛数法<br>O(nloglogsqrt(n)) time<br><a href="https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html">证明</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">isPrime</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">        isPrime[<span class="number">0</span>] = isPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isPrime[i]) <span class="keyword">continue</span>; <span class="comment">// 如果不是质数直接跳过</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) &#123; <span class="comment">// 要从i * i开始，因为i * 2到i * (i - 1)都已经筛过了</span></span><br><span class="line">                isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count(isPrime.begin(), isPrime.end(), <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// return count_if(isPrime.begin(), isPrime.end(), [](bool isPrime) &#123; return isPrime; &#125;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>307. Range Sum Query - Mutable</title>
    <url>/2020/12/25/307-Range-Sum-Query-Mutable/</url>
    <content><![CDATA[<p>常规线段树<br>指针版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        Node(<span class="keyword">int</span> b, <span class="keyword">int</span> e, <span class="keyword">int</span> val, Node *l = <span class="literal">nullptr</span>, Node *r = <span class="literal">nullptr</span>)</span><br><span class="line">            : b(b), e(e), val(val), l(l), r(r) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> b, e, val;</span><br><span class="line">        Node *l, *r;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span>;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        root = build(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(l, r, A[l]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">auto</span> tl = build(A, l, m);</span><br><span class="line">            <span class="keyword">auto</span> tr = build(A, m + <span class="number">1</span>, r);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(l, r, tl-&gt;val + tr-&gt;val, tl, tr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        update(root, i, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Node *p, <span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;b == i &amp;&amp; p-&gt;e == i) &#123;</span><br><span class="line">            p-&gt;val = val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> m = p-&gt;b + (p-&gt;e - p-&gt;b) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= m) &#123;</span><br><span class="line">                update(p-&gt;l, i, val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                update(p-&gt;r, i, val);</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;val = p-&gt;l-&gt;val + p-&gt;r-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query(root, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(Node *p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;b == l &amp;&amp; p-&gt;e == r) <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> m = p-&gt;b + (p-&gt;e - p-&gt;b) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> query(p-&gt;l, l, min(m, r)) + query(p-&gt;r, max(l, m + <span class="number">1</span>), r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    Node *root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * obj-&gt;update(i,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数组版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span>;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        tree.resize(<span class="number">4</span> * n); <span class="comment">// 开大小为4n的数组</span></span><br><span class="line">        build(<span class="number">1</span>, nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tree[v] = A[l];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            build(v * <span class="number">2</span>, A, l, m);</span><br><span class="line">            build(v * <span class="number">2</span> + <span class="number">1</span>, A, m + <span class="number">1</span>, r);</span><br><span class="line">            tree[v] = tree[v * <span class="number">2</span>] + tree[v * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, i, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tree[v] = val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (p &lt;= m) &#123;</span><br><span class="line">                update(v * <span class="number">2</span>, l, m, p, val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                update(v * <span class="number">2</span> + <span class="number">1</span>, m + <span class="number">1</span>, r, p, val);</span><br><span class="line">            &#125;</span><br><span class="line">            tree[v] = tree[v * <span class="number">2</span>] + tree[v * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tl == l &amp;&amp; tr == r) <span class="keyword">return</span> tree[v];</span><br><span class="line">        <span class="keyword">int</span> m = tl + (tr - tl) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> query(v * <span class="number">2</span>, tl, m, l, min(m, r)) + query(v * <span class="number">2</span> + <span class="number">1</span>, m + <span class="number">1</span>, tr, max(m + <span class="number">1</span>, l), r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * obj-&gt;update(i,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>zkw segment tree O(n) constructor O(logn) update O(logn) sum O(n) space<br>只支持bottom-up的题，top-down的题一律用常规线段树做<br>用数组来表示线段树<br>原始数组为[1, 2, 3, 4]则数组为[0, 10, 3, 7, 1, 2, 3, 4]，<br>原始数组为[1, 2, 3]则数组为[0, 6, 5, 1, 2, 3]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        tree.resize(<span class="number">2</span> * n); <span class="comment">// 开大小为2n的数组</span></span><br><span class="line">        copy(begin(nums), end(nums), begin(tree) + n); <span class="comment">// 把原始数组的n个数放在最后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123; <span class="comment">// 自底向上累加</span></span><br><span class="line">            tree[i] = tree[<span class="number">2</span> * i] + tree[<span class="number">2</span> * i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        i += n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = val - tree[i]; i &gt; <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span>) &#123; <span class="comment">// 从叶节点开始用新旧数差值d自底向上来更新线段树</span></span><br><span class="line">            tree[i] += d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i += n, j += n; i &lt;= j; i &gt;&gt;= <span class="number">1</span>, j &gt;&gt;= <span class="number">1</span>) &#123; <span class="comment">// 分别找到两个叶节点的位置，自底向上『递归』</span></span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123; <span class="comment">// 如果左边界是奇数，则证明是一个右子树，直接累加并右移一个节点，如果左边界是偶数，则证明是一个左子树，其父节点是左右两子树之和，继续向上递归即可</span></span><br><span class="line">                res += tree[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((j &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123; <span class="comment">// 如果右边界是偶数，则证明是一个左子树，直接累加并左移一个节点，如果右边界是奇数，则证明是一个右子树，其父节点是左右两子树之和，继续向上递归即可</span></span><br><span class="line">                res += tree[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * obj-&gt;update(i,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>树状数组<br>constructor O(nlogn)<br>update O(logn)<br>sumRange O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums) &#123;</span><br><span class="line">        v = nums;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        BIT.resize(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            helper(i, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += BIT[i];</span><br><span class="line">            i -= (i &amp; -i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        helper(i, val - v[i]);</span><br><span class="line">        v[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; BIT.size()) &#123;</span><br><span class="line">            BIT[i] += val;</span><br><span class="line">            i += (i &amp; -i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query(j) - query(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; BIT, v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * obj.update(i,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>二维树状数组求区间和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	Solution(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;mtx) : mtx(mtx) &#123;</span><br><span class="line">		<span class="keyword">int</span> n = mtx.size(), m = mtx[<span class="number">0</span>].size();</span><br><span class="line">		BIT.resize(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">				helper(i, j, mtx[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		++i, ++j;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = j; <span class="comment">// 注意要保存j因为每次内循环要用原值</span></span><br><span class="line">			<span class="keyword">while</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				sum += BIT[i][t];</span><br><span class="line">				t -= (t &amp; -t);</span><br><span class="line">			&#125;</span><br><span class="line">			i -= (i &amp; -i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> uli, <span class="keyword">int</span> ulj, <span class="keyword">int</span> lri, <span class="keyword">int</span> lrj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> query(lri, lrj) - query(lri, ulj - <span class="number">1</span>) - query(uli - <span class="number">1</span>, lrj) + query(uli - <span class="number">1</span>, ulj - <span class="number">1</span>); <span class="comment">// 注意跟一维的不一样，不能只减左上角还有两边的矩阵和也要减</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		++i, ++j;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; BIT.size()) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = j;</span><br><span class="line">			<span class="keyword">while</span> (t &lt; BIT[i].size()) &#123;</span><br><span class="line">				BIT[i][t] += val;</span><br><span class="line">				t += (t &amp; -t);</span><br><span class="line">			&#125;</span><br><span class="line">			i += (i &amp; -i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		helper(i, j, val - mtx[i][j]);</span><br><span class="line">		mtx[i][j] = val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mtx, BIT;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// your code goes here</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mtx = &#123;</span><br><span class="line">		&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;,</span><br><span class="line">		&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>&#125;,</span><br><span class="line">		&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function">Solution <span class="title">s</span><span class="params">(mtx)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s.query(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s.query(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	s.update(<span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s.query(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s.query(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Range sum</tag>
        <tag>Segment tree</tag>
      </tags>
  </entry>
  <entry>
    <title>743. Network Delay Time</title>
    <url>/2020/12/28/743-Network-Delay-Time/</url>
    <content><![CDATA[<p>dijkstra’s algorithm+heap O(NlogN + E) time O(N + E) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(N + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        d[<span class="number">0</span>] = d[K] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; g(N + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;t : times) &#123;</span><br><span class="line">            g[t[<span class="number">0</span>]].emplace_back(t[<span class="number">1</span>], t[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;d](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> d[a] == d[b] ? a &lt; b : d[a] &lt; d[b]; &#125;; <span class="comment">// 注意当d[a] == d[b]的时候set无法区分，所以只会保留一个数</span></span><br><span class="line">        set&lt;int, decltype(cmp)&gt; q(cmp);</span><br><span class="line">        q.insert(K);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = *begin(q); q.erase(begin(q));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : g[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[u] + w &lt; d[v]) &#123;</span><br><span class="line">                    q.erase(v);</span><br><span class="line">                    d[v] = d[u] + w;</span><br><span class="line">                    q.insert(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            res = max(res, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>错误实现，lambda会破坏pq内部结构！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; g(N + <span class="number">1</span>);</span><br><span class="line">        g[<span class="number">0</span>][K] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;e : times) &#123;</span><br><span class="line">            g[e[<span class="number">0</span>]][e[<span class="number">1</span>]] = e[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(N + <span class="number">1</span>, <span class="number">1000000</span>)</span></span>;</span><br><span class="line">        d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;d](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;<span class="keyword">return</span> d[x] &gt; d[y];&#125;;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; q(cmp);</span><br><span class="line">        q.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.top(); q.pop();</span><br><span class="line">            <span class="keyword">while</span> (!g[u].empty()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = g[u].begin();</span><br><span class="line">                <span class="keyword">int</span> v = it-&gt;first, t = it-&gt;second;</span><br><span class="line">                d[v] = min(d[v], d[u] + t);</span><br><span class="line">                q.push(v);</span><br><span class="line">                g[u].erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">1000000</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>正确实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; g(N + <span class="number">1</span>);</span><br><span class="line">        g[K][K] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;e : times) &#123;</span><br><span class="line">            g[e[<span class="number">0</span>]][e[<span class="number">1</span>]] = e[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(N + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        d[<span class="number">0</span>] = d[K] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">using</span> pii = <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;pii, <span class="built_in">vector</span>&lt;pii&gt;, greater&lt;&gt;&gt; q;</span><br><span class="line">        q.emplace(<span class="number">0</span>, K);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [w, u] = q.top(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (w != d[u]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : g[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[u] + w &lt; d[v]) &#123;</span><br><span class="line">                    d[v] = d[u] + w;</span><br><span class="line">                    q.emplace(d[v], v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= INT_MAX) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dijkstra</tag>
        <tag>Graph</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>1026. Maximum Difference Between Node and Ancestor</title>
    <url>/2020/12/29/1026-Maximum-Difference-Between-Node-and-Ancestor/</url>
    <content><![CDATA[<p>O(n) time O(h) space<br>每次更新mx和mn，到nullptr时得到根到叶的一条路径上的最大和最小值，只需要求差即可，对于左右两个子树返回上来的不同路径的最大最小值之差，只需要取较大的那个即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, root-&gt;val, root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> mx, <span class="keyword">int</span> mn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root ? max(dfs(root-&gt;left, max(mx, root-&gt;val), min(mn, root-&gt;val)), dfs(root-&gt;right, max(mx, root-&gt;val), min(mn, root-&gt;val))) : mx - mn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root, root-&gt;val, root-&gt;val); <span class="comment">// 初始最大最小都为root即可</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> mx, <span class="keyword">int</span> mn)</span> </span>&#123; <span class="comment">// 因为是绝对值，所以要维护最大最小两个值</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        res = max(&#123;res, <span class="built_in">abs</span>(mx - root-&gt;val), <span class="built_in">abs</span>(mn - root-&gt;val)&#125;);</span><br><span class="line">        mx = max(mx, root-&gt;val);</span><br><span class="line">        mn = min(mn, root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left, mx, mn);</span><br><span class="line">        dfs(root-&gt;right, mx, mn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Binary tree</tag>
        <tag>Preorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>1047. Remove All Adjacent Duplicates In String</title>
    <url>/2020/12/30/1047-Remove-All-Adjacent-Duplicates-In-String/</url>
    <content><![CDATA[<p>O(n) time O(n) space<br>这道题的意思是一定要『一对』才remove</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!res.empty() &amp;&amp; res.back() == c) &#123;</span><br><span class="line">                res.pop_back();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>1539. Kth Missing Positive Number</title>
    <url>/2020/12/29/1539-Kth-Missing-Positive-Number/</url>
    <content><![CDATA[<p>二分 O(logn) time O(1) space<br>找『上界』<br>跟<a href="https://leetcode.com/problems/missing-element-in-sorted-array/">1060. Missing Element in Sorted Array</a>思路接近</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(arr), l = <span class="number">0</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[m] - m - <span class="number">1</span> &gt;= k) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l + k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        arr.push_back(<span class="number">10000</span>); <span class="comment">// padding好写code</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">int</span> d = arr[i] - (i + <span class="number">1</span>); d &gt;= k) &#123; <span class="comment">// arr[i]出现在了第i + 1个位置，arr[i]前边本应该有arr[i] - 1个数，结果现在只有i个数，差了d个数，假如d &gt;= k，说明差的第k个数必在这d个数里，因为是第一次出现这种情况，说明一定是从第arr[i]开始往前数第d - k + 1个数</span></span><br><span class="line">                <span class="keyword">return</span> arr[i] - (d - k + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不padding</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">int</span> d = arr[i] - (i + <span class="number">1</span>); d &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">return</span> arr[i] - (d - k + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + k; <span class="comment">// 说明就是第n + k个数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>203. Remove Linked List Elements</title>
    <url>/2020/12/29/203-Remove-Linked-List-Elements/</url>
    <content><![CDATA[<p>O(n) 朴素解法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummy_head(0), *prev = &amp;dummy_head;</span><br><span class="line">        prev-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> curr = head; curr; curr = curr-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;val == val) &#123;</span><br><span class="line">                prev-&gt;next = curr-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev = curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n)二级指针法<br>一般一个节点分两部分，数据和next指针，各自有不同的地址（占用不同的内存空间），我们要做的是改变要删除的节点的前驱节点的next指针的值，如果当前节点不是要删除的目标节点，我们取next指针的地址保存起来，即list = &amp;(*list)-&gt;next;，下次循环的时候，我们是站在前驱节点的位置来检查前驱节点的后继节点是不是要被删除的目标节点，如果是的话，直接修改这个『next』指针值，即*list = (*list)-&gt;next;，相当于node-&gt;next = node-&gt;next-&gt;next;，其中node-&gt;next是要被删除的目标节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode **<span class="built_in">list</span> = &amp;head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (*<span class="built_in">list</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*<span class="built_in">list</span>)-&gt;val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                *<span class="built_in">list</span> = (*<span class="built_in">list</span>)-&gt;next; <span class="comment">// 因为之前保存了前驱节点的next指针信息，所以可以直接修改前驱节点的next指针的值为当前节点的后继节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">list</span> = &amp;(*<span class="built_in">list</span>)-&gt;next; <span class="comment">// 保存的其实是当前节点的next指针信息，而不是下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n)递归解法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        head-&gt;next = removeElements(head-&gt;next, val);</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>381. Insert Delete GetRandom O(1) - Duplicates allowed</title>
    <url>/2020/12/29/381-Insert-Delete-GetRandom-O-1-Duplicates-allowed/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    RandomizedCollection() &#123;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> res = m.find(val) == m.end();</span><br><span class="line">        m[val].push_back(v.size());</span><br><span class="line">        v.emplace_back(val, m[val].size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m.count(val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        m[v.back().first][v.back().second] = m[val].back();</span><br><span class="line">        v[m[val].back()] = v.back();</span><br><span class="line">        v.pop_back();</span><br><span class="line">        m[val].pop_back();</span><br><span class="line">        <span class="keyword">if</span> (m[val].empty()) m.erase(val); <span class="comment">// 切记如果m[val]空了要从m中删掉！！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get a random element from the collection. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.empty() ? <span class="number">0</span> : v[rand() % v.size()].first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m; <span class="comment">// 添加删除O(1)所以要用unordered容器，unordered_map可保存更多信息，这里对应每个key存v中所有该key的下标</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v; <span class="comment">// 数组不是只存val，还要存val所在m中的下标集合的下标，即m[v[i].first][v[i].second] = i，v[i].first是val，v[i].second是m[val]对应的数组的下标，通过该下标可以得到val在v中的下标，这么做是因为每次删除以后被修改的数在m中的下标数组不一定是有序的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedCollection object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedCollection obj = new RandomizedCollection();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Data structure design</tag>
      </tags>
  </entry>
  <entry>
    <title>489. Robot Room Cleaner</title>
    <url>/2020/12/29/489-Robot-Room-Cleaner/</url>
    <content><![CDATA[<p>backtracking O(4^(n - m)) time O(n - m) space<br>n是所有cell的个数 m是障碍的个数<br>尝试在每个方向上clean一遍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the robot&#x27;s control interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class Robot &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Returns true if the cell in front is open and robot moves into the cell.</span></span><br><span class="line"><span class="comment"> *     // Returns false if the cell in front is blocked and robot stays in the current cell.</span></span><br><span class="line"><span class="comment"> *     bool move();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Robot will stay in the same cell after calling turnLeft/turnRight.</span></span><br><span class="line"><span class="comment"> *     // Each turn will be 90 degrees.</span></span><br><span class="line"><span class="comment"> *     void turnLeft();</span></span><br><span class="line"><span class="comment"> *     void turnRight();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Clean the current cell.</span></span><br><span class="line"><span class="comment"> *     void clean();</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>, d = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanRoom</span><span class="params">(Robot&amp; robot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> k = to_string(r) + <span class="string">&quot; &quot;</span> + to_string(c);</span><br><span class="line">        <span class="keyword">if</span> (s.count(k)) <span class="keyword">return</span>;</span><br><span class="line">        s.insert(k);</span><br><span class="line">        robot.clean();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123; <span class="comment">// 每一个cell尝试四个方向</span></span><br><span class="line">            <span class="keyword">if</span> (robot.move()) &#123; <span class="comment">// 任何一个方向能前进的话</span></span><br><span class="line">                <span class="keyword">auto</span> [dr, dc] = dirs[d];</span><br><span class="line">                r += dr;</span><br><span class="line">                c += dc;</span><br><span class="line">                cleanRoom(robot); <span class="comment">// 尝试在这个方向上clean（有可能已经clean过，则回退）</span></span><br><span class="line">                robot.turnRight();</span><br><span class="line">                robot.turnRight();</span><br><span class="line">                robot.move();</span><br><span class="line">                robot.turnRight();</span><br><span class="line">                robot.turnRight();</span><br><span class="line">                r -= dr;</span><br><span class="line">                c -= dc;</span><br><span class="line">            &#125;</span><br><span class="line">            robot.turnRight(); <span class="comment">// 尝试下一个方向</span></span><br><span class="line">            d = (d + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Backtracking</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>525. Contiguous Array</title>
    <url>/2020/12/29/525-Contiguous-Array/</url>
    <content><![CDATA[<p>O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), res = <span class="number">0</span>, diff = <span class="number">0</span>;</span><br><span class="line">        m[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            diff += (nums[i] == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (m.count(diff)) &#123;</span><br><span class="line">                res = max(res, i - m[diff]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m[diff] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
        <tag>Prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>658. Find K Closest Elements</title>
    <url>/2020/12/29/658-Find-K-Closest-Elements/</url>
    <content><![CDATA[<p>二分+two pointers O(k+logn) time<br>两个指针分别向左右移，最后把两个指针之间的数返回即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = upper_bound(begin(arr), end(arr), x); <span class="comment">// lower_bound也行</span></span><br><span class="line">        <span class="keyword">int</span> n = arr.size(), r = it == end(arr) ? n - <span class="number">1</span> : it - begin(arr), l = r - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r &gt;= n) &#123;</span><br><span class="line">                --l;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x - arr[l] &lt;= arr[r] - x) &#123; <span class="comment">// arr[l] &lt; x &lt;= arr[r]</span></span><br><span class="line">                    --l;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(begin(arr) + l + <span class="number">1</span>, begin(arr) + r); <span class="comment">// 因为l和r都会多走一步，所以l要回退一步，r正好不用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>787. Cheapest Flights Within K Stops</title>
    <url>/2020/12/29/787-Cheapest-Flights-Within-K-Stops/</url>
    <content><![CDATA[<p>这道题用bellman-ford就可以了<br>每次relax的时候存前后结点，最后倒推一遍即可输出路径<br>O((e+n)logn) time push共e次 pop共n次<br>改进后的dijkstra，记录所有点k个stop以内的最小费用和（普通的dijkstra是记录所有点的全局最小费用和）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1e7</span>)); <span class="comment">// 用邻接矩阵存图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;f : flights) &#123;</span><br><span class="line">            graph[f[<span class="number">0</span>]][f[<span class="number">1</span>]] = f[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ++K; <span class="comment">// 这里K个stop不包括起点和终点，所以要++方便操作，表示K次飞行</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dist(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(K + <span class="number">1</span>, <span class="number">1e7</span>)); <span class="comment">// cache所有点k次飞行以内的最优解</span></span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;lhs, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;rhs) &#123;<span class="keyword">return</span> lhs[<span class="number">2</span>] &gt; rhs[<span class="number">2</span>];&#125;;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; q(cmp); <span class="comment">// 用堆记录每个点每次飞行的可能解，这里需要单独存一份开销dist因为把dist传到cmp里不能在堆上即时反应出来</span></span><br><span class="line">        q.push(&#123;src, <span class="number">0</span>, <span class="number">0</span>&#125;); <span class="comment">// 从src飞到src，0次飞行，开销是0</span></span><br><span class="line">        <span class="comment">// dist[src][0] = 0; // 可写可不写</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> v = q.top(); q.pop();</span><br><span class="line">            <span class="keyword">int</span> u = v[<span class="number">0</span>], k = v[<span class="number">1</span>], d = v[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (u == dst) <span class="keyword">return</span> d; <span class="comment">// 因为堆肯定是最优解（最小费用和）在前，所以第一次碰到dst一定就是最优解</span></span><br><span class="line">            <span class="keyword">if</span> (k == K) <span class="keyword">continue</span>; <span class="comment">// 已经达到上限，不propagate了，否则relax时dist[i][k + 1]会outofbound</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[i][k + <span class="number">1</span>] &gt; d + graph[u][i]) &#123; <span class="comment">// relax</span></span><br><span class="line">                    dist[i][k + <span class="number">1</span>] = d + graph[u][i];</span><br><span class="line">                    q.push(&#123;i, k + <span class="number">1</span>, dist[i][k + <span class="number">1</span>]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> tiii = tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        ++K;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; g(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;f : flights) &#123;</span><br><span class="line">            g[f[<span class="number">0</span>]].emplace_back(f[<span class="number">1</span>], f[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dist(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(K + <span class="number">1</span>, INT_MAX));</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;tiii, <span class="built_in">vector</span>&lt;tiii&gt;, greater&lt;tiii&gt;&gt; q;</span><br><span class="line">        q.emplace(<span class="number">0</span>, src, <span class="number">0</span>);</span><br><span class="line">        dist[src][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [cost, u, k] = q.top(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (u == dst) <span class="keyword">return</span> cost;</span><br><span class="line">            <span class="keyword">if</span> (k == K) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [v, c] : g[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cost + c &lt; dist[v][k + <span class="number">1</span>]) &#123;</span><br><span class="line">                    dist[v][k + <span class="number">1</span>] = cost + c;</span><br><span class="line">                    q.emplace(cost + c, v, k + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>没做剪枝的版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> tiii = tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        ++K;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; g(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;f : flights) &#123;</span><br><span class="line">            g[f[<span class="number">0</span>]].emplace_back(f[<span class="number">1</span>], f[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;tiii, <span class="built_in">vector</span>&lt;tiii&gt;, greater&lt;tiii&gt;&gt; q;</span><br><span class="line">        q.emplace(<span class="number">0</span>, src, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [cost, u, k] = q.top(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (u == dst) <span class="keyword">return</span> cost;</span><br><span class="line">            <span class="keyword">if</span> (k == K) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [v, c] : g[u]) &#123;</span><br><span class="line">                q.emplace(cost + c, v, k + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>bellman-ford变种 O(K*E) time O(VK) space<br>因为最多只能K个stop，所以relax K次就可以了<br>每次松弛操作实际上是对相邻节点的访问，第n次松弛操作保证了所有深度为n的路径最短。由于图的最短路径最长不会经过超过 |V|-1 条边，所以可知贝尔曼-福特算法所得为最短路径。<br>K个stop转换成K+1次飞行，直飞就是1次飞行<br>f[i][j]表示最多i次飞行从src到达j的最小开销<br>这里所有的f[i][src] = 0 where 0 &lt;= i &lt;= K + 1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; d(K + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1e7</span>));</span><br><span class="line">        d[<span class="number">0</span>][src] = <span class="number">0</span>; <span class="comment">// 0次飞行哪也去不了，肯定为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            d[i][src] = <span class="number">0</span>; <span class="comment">// 任何次数的飞行都是回到原点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;f : flights) &#123;</span><br><span class="line">                d[i][f[<span class="number">1</span>]] = min(d[i][f[<span class="number">1</span>]], d[i - <span class="number">1</span>][f[<span class="number">0</span>]] + f[<span class="number">2</span>]); <span class="comment">// 进行relax</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d[K + <span class="number">1</span>][dst] == <span class="number">1e7</span> ? <span class="number">-1</span> : d[K + <span class="number">1</span>][dst];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        ++K;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; d(K + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1e7</span>));</span><br><span class="line">        d[<span class="number">0</span>][src] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">            d[i][src] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;f : flights) &#123;</span><br><span class="line">                d[i][f[<span class="number">1</span>]] = min(d[i][f[<span class="number">1</span>]], d[i - <span class="number">1</span>][f[<span class="number">0</span>]] + f[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d[K][dst] == <span class="number">1e7</span> ? <span class="number">-1</span> : d[K][dst];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>滚动数组空间优化以后的bellman-ford变种 O(K*E) time O(V) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        ++K;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; d(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1e7</span>));</span><br><span class="line">        d[<span class="number">0</span>][src] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">            d[i &amp; <span class="number">1</span>][src] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;f : flights) &#123;</span><br><span class="line">                d[i &amp; <span class="number">1</span>][f[<span class="number">1</span>]] = min(d[i &amp; <span class="number">1</span>][f[<span class="number">1</span>]], d[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][f[<span class="number">0</span>]] + f[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d[K &amp; <span class="number">1</span>][dst] == <span class="number">1e7</span> ? <span class="number">-1</span> : d[K &amp; <span class="number">1</span>][dst];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>加入剪枝</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        ++K;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; d(K + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1e7</span>));</span><br><span class="line">        d[<span class="number">0</span>][src] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">            d[i][src] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">bool</span> changed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;f : flights) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[i - <span class="number">1</span>][f[<span class="number">0</span>]] + f[<span class="number">2</span>] &lt; d[i][f[<span class="number">1</span>]]) &#123;</span><br><span class="line">                    d[i][f[<span class="number">1</span>]] = d[i - <span class="number">1</span>][f[<span class="number">0</span>]] + f[<span class="number">2</span>];</span><br><span class="line">                    changed = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!changed) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d[K][dst] == <span class="number">1e7</span> ? <span class="number">-1</span> : d[K][dst];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>BFS 如果有圈的话不如dijkstra 比如[[0, 1, 1], [1, 0, 1], [1, 2, 1], [2, 1, 1], [2, 3, 1], [3, 2, 1], [0, 3, 2]] 1stop</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        ++K;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; g(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;f : flights) &#123;</span><br><span class="line">            g[f[<span class="number">0</span>]].emplace_back(f[<span class="number">1</span>], f[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q&#123;&#123;&#123;src, <span class="number">0</span>&#125;&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>, res = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty() &amp;&amp; k &lt;= K) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [u, cost] = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (u == dst) &#123;</span><br><span class="line">                    res = min(res, cost);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> [v, c] : g[u]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cost + c &lt; res) &#123;</span><br><span class="line">                        q.emplace(v, cost + c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>1213. Intersection of Three Sorted Arrays</title>
    <url>/2020/12/30/1213-Intersection-of-Three-Sorted-Arrays/</url>
    <content><![CDATA[<p>O(mn) time O(1) space<br>类似merge的思路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">arraysIntersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>, n1 = arr1.size(), n2 = arr2.size(), n3 = arr3.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2 &amp;&amp; k &lt; n3) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] == arr2[j] &amp;&amp; arr2[j] == arr3[k]) &#123;</span><br><span class="line">                res.push_back(arr1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mn = min(&#123;arr1[i], arr2[j], arr3[k]&#125;); <span class="comment">// 因为当前的三个数不同所以找出最小的数并跳过</span></span><br><span class="line">            <span class="keyword">if</span> (mn == arr1[i]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mn == arr2[j]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mn == arr3[k]) &#123;</span><br><span class="line">                ++k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">arraysIntersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>, n1 = arr1.size(), n2 = arr2.size(), n3 = arr3.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2 &amp;&amp; k &lt; n3) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] == arr2[j] &amp;&amp; arr2[j] == arr3[k]) &#123; <span class="comment">// 如果三个数都一样则输出</span></span><br><span class="line">                res.push_back(arr1[i]);</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">                ++k;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr1[i] &lt; arr2[j]) &#123; <span class="comment">// 如果arr1[i]不是最大则看arr1[i + 1]</span></span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr2[j] &lt; arr3[k]) &#123; <span class="comment">// 如果arr2[j]不是最大则看arr2[j + 1]</span></span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果arr3[k]不是最大则看arr3[k + 1]</span></span><br><span class="line">                ++k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(mn) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">arraysIntersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr3)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : arr1) &#123;</span><br><span class="line">            ++m[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : arr2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.count(x)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--m[x] == <span class="number">0</span>) &#123;</span><br><span class="line">                    m.erase(x);</span><br><span class="line">                &#125;</span><br><span class="line">                ++t[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t.swap(m);</span><br><span class="line">        t.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : arr3) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.count(x)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--m[x] == <span class="number">0</span>) &#123;</span><br><span class="line">                    m.erase(x);</span><br><span class="line">                &#125;</span><br><span class="line">                ++t[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t.swap(m);</span><br><span class="line">        t.clear();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">                res.push_back(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(begin(res), end(res));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Merging</tag>
      </tags>
  </entry>
  <entry>
    <title>1216. Valid Palindrome III</title>
    <url>/2020/12/30/1216-Valid-Palindrome-III/</url>
    <content><![CDATA[<p>dp O(n^2) time O(n^2) space<br>区间型dp<br>算一下s[0:n-1]的最长回文子序列长度f[0][n - 1]<br>n - f[0][n - 1]是不在最长回文子序列里的即要从原字符串删除的字符个数<br>最后要判断n - f[0][n - 1]是否不超过k</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidPalindrome</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            f[i][i + <span class="number">1</span>] = <span class="number">1</span> + (s[i] == s[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = i + len; j &lt; n; ++i, ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    f[i][j] = f[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = max(f[i][j - <span class="number">1</span>], f[i + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - f[<span class="number">0</span>][n - <span class="number">1</span>] &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>1233. Remove Sub-Folders from the Filesystem</title>
    <url>/2020/12/30/1233-Remove-Sub-Folders-from-the-Filesystem/</url>
    <content><![CDATA[<p>用hash table提前把所有path存起来 遍历每个path 从后往前删文件名（相当于从subfolder向上找parent folder的path）如果parent folder的path在hash table里 证明这是一个subfolder应该remove 否则将一直找到根目录的path</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeSubfolders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; folder)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;string_view&gt; <span class="title">s</span><span class="params">(begin(folder), end(folder))</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;f : folder) &#123;</span><br><span class="line">            <span class="function">string_view <span class="title">v</span><span class="params">(f)</span></span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                v.remove_suffix(v.length() - v.find_last_of(<span class="string">&#x27;/&#x27;</span>));</span><br><span class="line">            &#125; <span class="keyword">while</span> (!v.empty() &amp;&amp; !s.count(v));</span><br><span class="line">            <span class="keyword">if</span> (v.empty()) &#123;</span><br><span class="line">                res.push_back(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeSubfolders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; folder)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;string_view&gt; <span class="title">s</span><span class="params">(begin(folder), end(folder))</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;f : folder) &#123;</span><br><span class="line">            <span class="function">string_view <span class="title">v</span><span class="params">(f)</span></span>;</span><br><span class="line">            <span class="keyword">while</span> (!v.empty()) &#123;</span><br><span class="line">                <span class="keyword">while</span> (v.back() != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    v.remove_suffix(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                v.remove_suffix(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (s.count(v)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v.empty()) &#123;</span><br><span class="line">                res.push_back(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类似trie</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeSubfolders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; folder)</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Folder;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;path : folder) &#123;</span><br><span class="line">            add(path);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Folder</span> &#123;</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, Folder *&gt; subfolders;</span><br><span class="line">        <span class="built_in">string</span> path;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Folder *root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">while</span> (getline(input, name, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;subfolders.count(name)) &#123;</span><br><span class="line">                p-&gt;subfolders[name] = <span class="keyword">new</span> Folder;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;subfolders[name];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Folder *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;path.empty()) &#123;</span><br><span class="line">            res.push_back(p-&gt;path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[_, subfolder] : p-&gt;subfolders) &#123;</span><br><span class="line">            dfs(subfolder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
      </tags>
  </entry>
  <entry>
    <title>129. Sum Root to Leaf Numbers</title>
    <url>/2020/12/30/129-Sum-Root-to-Leaf-Numbers/</url>
    <content><![CDATA[<p>preorder O(n) time O(h) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root, <span class="keyword">int</span> num = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">sum</span><span class="params">(TreeNode *root, <span class="keyword">long</span> val)</span> </span>&#123; <span class="comment">// 返回这棵树所有Root to Leaf Numbers的和</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        val = val * <span class="number">10</span> + root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> val; <span class="comment">// 叶节点要单独处理</span></span><br><span class="line">        <span class="keyword">return</span> sum(root-&gt;left, val) + sum(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Preorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>246. Strobogrammatic Number</title>
    <url>/2020/12/30/246-Strobogrammatic-Number/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isStrobogrammatic</span><span class="params">(<span class="built_in">string</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">9</span>, <span class="number">-1</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = num.length(), l = <span class="number">0</span>, r = n - <span class="number">1</span>; l &lt;= r; ++l, --r) &#123;</span><br><span class="line">            <span class="keyword">int</span> cl = num[l] - <span class="string">&#x27;0&#x27;</span>, cr = num[r] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (m[cl] == <span class="number">-1</span> || m[cr] == <span class="number">-1</span> || m[cl] != cr) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>266. Palindrome Permutation</title>
    <url>/2020/12/30/266-Palindrome-Permutation/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPermutePalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> odd_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            odd_cnt += ((++f[c] &amp; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>; <span class="comment">// 奇数++偶数--</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> odd_cnt &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Palindrome</tag>
      </tags>
  </entry>
  <entry>
    <title>463. Island Perimeter</title>
    <url>/2020/12/30/463-Island-Perimeter/</url>
    <content><![CDATA[<p>O(mn) time<br>count cells and shared edges<br>res = 4 * cells - 2 * shared edges</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, shared = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]) &#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                    shared += (i &gt; <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j]);</span><br><span class="line">                    shared += (j &gt; <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * cnt - shared * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> perimeter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; grid.size(); ++row) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; grid[row].size(); ++col) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[row][col]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> == row || <span class="number">0</span> == grid[row - <span class="number">1</span>][col]) &#123;</span><br><span class="line">                        ++perimeter;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid.size() == row + <span class="number">1</span> || <span class="number">0</span> == grid[row + <span class="number">1</span>][col]) &#123;</span><br><span class="line">                        ++perimeter;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> == col || <span class="number">0</span> == grid[row][col - <span class="number">1</span>]) &#123;</span><br><span class="line">                        ++perimeter;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[row].size() == col + <span class="number">1</span> || <span class="number">0</span> == grid[row][col + <span class="number">1</span>]) &#123;</span><br><span class="line">                        ++perimeter;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> perimeter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>695. Max Area of Island</title>
    <url>/2020/12/30/695-Max-Area-of-Island/</url>
    <content><![CDATA[<p>iterative bfs O(mn) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty() || grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dc[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dr[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; m; ++c) &#123;</span><br><span class="line">                res = max(res, bfs(grid, r, c, dr, dc, n, m));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> dr[], <span class="keyword">int</span> dc[], <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.emplace(r, c);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= r &amp;&amp; r &lt; n &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; m &amp;&amp; grid[r][c]) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                grid[r][c] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                    q.emplace(r + dr[i], c + dc[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title>752. Open the Lock</title>
    <url>/2020/12/30/752-Open-the-Lock/</url>
    <content><![CDATA[<p>bfs O(A^n) A是密码盘字母数，本题是10，n是密码盘个数，本题是4</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; deadends, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">cache</span><span class="params">(begin(deadends), end(deadends))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (cache.count(<span class="string">&quot;0000&quot;</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q&#123;&#123;<span class="string">&quot;0000&quot;</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> s = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (s == target) <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;c : s) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> t = c;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i : &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;) &#123;</span><br><span class="line">                        c = <span class="string">&#x27;0&#x27;</span> + (t - <span class="string">&#x27;0&#x27;</span> + <span class="number">10</span> + i) % <span class="number">10</span>;</span><br><span class="line">                        <span class="keyword">if</span> (!cache.count(s)) &#123;</span><br><span class="line">                            q.push(s);</span><br><span class="line">                            cache.insert(s);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    c = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title>78. Subsets</title>
    <url>/2020/12/30/78-Subsets/</url>
    <content><![CDATA[<p>O(n!) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res&#123;&#123;&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = res.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 一定要用n，不能动态取值</span></span><br><span class="line">                res.push_back(res[i]);</span><br><span class="line">                res.back().push_back(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>backtracking</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        dfs(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        res.push_back(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; size(A); ++i) &#123;</span><br><span class="line">            v.push_back(A[i]);</span><br><span class="line">            dfs(A, i + <span class="number">1</span>);</span><br><span class="line">            v.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>844. Backspace String Compare</title>
    <url>/2020/12/30/844-Backspace-String-Compare/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>从后往前扫，遇到#就处理，直到两个字符串都扫完</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = S.length(), n = T.length();</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>; --i, --j) &#123; <span class="comment">// 有可能是[&quot;&quot;, &quot;ab##&quot;]</span></span><br><span class="line">            resolve(S, i);</span><br><span class="line">            resolve(T, j);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || S[i] != T[j]) <span class="keyword">break</span>; <span class="comment">// 只要有一点不符合要求就break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i &lt; <span class="number">0</span> &amp;&amp; j &lt; <span class="number">0</span>; <span class="comment">// 两个字符串都扫完，说明没有不匹配的字符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resolve</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> &amp;i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            cnt += s[i] == <span class="string">&#x27;#&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>; <span class="comment">// 类似括号匹配</span></span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = S.length(), n = T.length();</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>; --i, --j) &#123; <span class="comment">// 有可能是[&quot;&quot;, &quot;ab##&quot;]</span></span><br><span class="line">            resolve(S, i);</span><br><span class="line">            resolve(T, j);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || S[i] != T[j]) <span class="keyword">break</span>; <span class="comment">// 只要有一点不符合要求就break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i &lt; <span class="number">0</span> &amp;&amp; j &lt; <span class="number">0</span>; <span class="comment">// 两个字符串都扫完，说明没有不匹配的字符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resolve</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> &amp;i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s[i] == <span class="string">&#x27;#&#x27;</span>) &#123; <span class="comment">// 只要还能继续删就一直处理完</span></span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s[i] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s[i] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!S.empty() || !T.empty()) &#123; <span class="comment">// 一定是或不能是与，反例[&quot;nzp#o#g&quot;, &quot;b#nzp#o#g&quot;]</span></span><br><span class="line">            resolve(S);</span><br><span class="line">            resolve(T); <span class="comment">// resolve完之后要不是空，要不结尾不能是#</span></span><br><span class="line">            <span class="keyword">if</span> (S.empty() || T.empty() || S.back() != T.back()) <span class="keyword">break</span>;</span><br><span class="line">            S.pop_back(); <span class="comment">// 因为已经判过空了，所以可以直接pop</span></span><br><span class="line">            T.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S.empty() &amp;&amp; T.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resolve</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.back() == <span class="string">&#x27;#&#x27;</span>) &#123; <span class="comment">// 一定要处理干净再返回，比如&quot;a#b#&quot; ==&gt; &quot;&quot;而不是&quot;a#&quot;</span></span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; s.back() == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                ++cnt; <span class="comment">// 数一下结尾几个#</span></span><br><span class="line">                s.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; s.back() != <span class="string">&#x27;#&#x27;</span> &amp;&amp; cnt &gt; <span class="number">0</span>) &#123; <span class="comment">// 按照#的个数pop结尾字符，直到#个数为0或者字符串为空为止</span></span><br><span class="line">                s.pop_back();</span><br><span class="line">                --cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Merging</tag>
      </tags>
  </entry>
  <entry>
    <title>858. Mirror Reflection</title>
    <url>/2020/12/30/858-Mirror-Reflection/</url>
    <content><![CDATA[<p>做辅助线（延长线）找镜面反射的规律，每个pq对经过约分之后再分别对2取模，因为012的出现都是交替的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1 2 1 2</span><br><span class="line">_ 0 _ 0 _</span><br><span class="line">2 1 2 1 2</span><br><span class="line">s 0 _ 0 _</span><br></pre></td></tr></table></figure>
<p>举例p = 3, q = 2可以化简成p = 1, q = 0结果是一样的<br>最后规律如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p q res</span><br><span class="line">0 1 2</span><br><span class="line">1 1 1</span><br><span class="line">1 0 0</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mirrorReflection</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> g = gcd(p, q); <span class="comment">// 先约分化简（C++17自带）</span></span><br><span class="line">        p /= g; p %= <span class="number">2</span>;</span><br><span class="line">        q /= g; q %= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> res[p * <span class="number">2</span> + q];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            a %= b;</span><br><span class="line">            swap(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int gcd(int a, int b) &#123;</span></span><br><span class="line">    <span class="comment">//     while (b != 0) &#123;</span></span><br><span class="line">    <span class="comment">//         int t = a % b;</span></span><br><span class="line">    <span class="comment">//         a = b;</span></span><br><span class="line">    <span class="comment">//         b = t;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return a;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>863. All Nodes Distance K in Binary Tree</title>
    <url>/2020/12/30/863-All-Nodes-Distance-K-in-Binary-Tree/</url>
    <content><![CDATA[<p>O(n) time O(n) space<br>树转图+bfs<br>跟<a href="https://leetcode.com/problems/closest-leaf-in-a-binary-tree/">742. Closest Leaf in a Binary Tree</a>类似</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distanceK</span><span class="params">(TreeNode* root, TreeNode* target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; q&#123;&#123;target-&gt;val&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (K-- &gt; <span class="number">0</span> &amp;&amp; !q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = q.front(); q.pop_front();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) &#123;</span><br><span class="line">                    g[v].erase(u);</span><br><span class="line">                    q.push_back(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(begin(q), end(q));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            g[root-&gt;val].insert(root-&gt;left-&gt;val);</span><br><span class="line">            g[root-&gt;left-&gt;val].insert(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            g[root-&gt;val].insert(root-&gt;right-&gt;val);</span><br><span class="line">            g[root-&gt;right-&gt;val].insert(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; g; <span class="comment">// 邻接表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distanceK</span><span class="params">(TreeNode* root, TreeNode* target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s&#123;target-&gt;val&#125;;</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; q&#123;&#123;target-&gt;val&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (K-- &gt; <span class="number">0</span> &amp;&amp; !q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = q.front(); q.pop_front();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> y : g[x]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.count(y)) <span class="keyword">continue</span>;</span><br><span class="line">                    s.insert(y);</span><br><span class="line">                    q.push_back(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(begin(q), end(q));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            g[root-&gt;val].push_back(root-&gt;left-&gt;val);</span><br><span class="line">            g[root-&gt;left-&gt;val].push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            g[root-&gt;val].push_back(root-&gt;right-&gt;val);</span><br><span class="line">            g[root-&gt;right-&gt;val].push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g; <span class="comment">// 邻接表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Depth first search</tag>
        <tag>Graph</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>90. Subsets II</title>
    <url>/2020/12/30/90-Subsets-II/</url>
    <content><![CDATA[<p>O(n!) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(begin(nums), end(nums));</span><br><span class="line">        n = nums.size();</span><br><span class="line">        dfs(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        res.push_back(v); <span class="comment">// 每构造一个新结果就输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; b &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">            v.push_back(nums[i]);</span><br><span class="line">            dfs(nums, i + <span class="number">1</span>);</span><br><span class="line">            v.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>921. Minimum Add to Make Parentheses Valid</title>
    <url>/2020/12/31/921-Minimum-Add-to-Make-Parentheses-Valid/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>l和r分别表示无法匹配的左括号跟右括号的个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123; <span class="comment">// 当前字符是右括号且左括号有余则可以进行匹配，用掉一个左括号，否则增加一个无法匹配的右括号</span></span><br><span class="line">                l &gt; <span class="number">0</span> ? --l : ++r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l + r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> debt = <span class="number">0</span>, balance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : S) &#123;</span><br><span class="line">            balance += c == <span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (balance &lt; <span class="number">0</span>) &#123; <span class="comment">// 如果balance为负，说明欠钱了，先赊账，让balance平衡，最后debt和balance一起算</span></span><br><span class="line">                ++debt;</span><br><span class="line">                ++balance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> debt + balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>stack O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; !s.empty() &amp;&amp; s.top() == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Parentheses</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>920. Number of Music Playlists</title>
    <url>/2020/12/31/920-Number-of-Music-Playlists/</url>
    <content><![CDATA[<p>dp O(NL) time O(NL) space<br>这道题的建模应该先从如何生成一个播放列表入手，因为有K首歌之内不能重复这个限制条件，所以我们一定是要一首歌一首歌往播放列表里添加并且每次都要检查是否跟前K首歌重复，如果重复则选择另外一首歌，所以我们只考虑不重复的合法情况：</p>
<ol>
<li>跟当前已生成的播放列表完全不重复，这样的歌就是所有还未选择过的歌</li>
<li>跟前K首歌不重复但是跟K首歌之前的歌有重复，这样的歌就是已经被选择过的播放列表中的歌但是并不在最近的K首歌里</li>
</ol>
<p>假设dp[l][n]表示对于播放表的前l首歌，去除重复的歌曲后还剩下n首歌的方案数。（即使用n首歌来生成播放表的前l首歌）</p>
<p>那么需要return的答案便为：dp[L][N] (因为每首歌必须至少出现一次，故这L首歌去除重复后一定有N首歌)</p>
<p>对于dp[l][n]的求解，需要分类讨论：</p>
<ol>
<li><p>播放表的第l首歌跟前面的(l - 1)首都不一样，则对于dp[l][n]，我们可以先使用(n - 1)首歌排好播放表的前(l - 1)首歌，然后从剩下的(N - (n - 1))首歌<br>里面再任意取一首歌，放在第l个位置，即：<br>dp[l][n] += dp[l - 1][n - 1] * (N - (n - 1))</p>
</li>
<li><p>播放表的第l首歌跟前面的(l - 1)首存在重复的，则对于dp[l][n]，我们可以先使用n首歌排好前面的(l - 1)首歌，然后因为保证任意两首相同的歌之间至<br>少有k首不同的歌，故对于dp[l - 1][n]里面的方案，最后的k首歌一定不一样，故我们只需要选一首跟最后面的k首歌不一样的歌，放在第l个位置即可，即：<br>dp[l][n] += dp[l - 1][n] * (n - k)</p>
</li>
</ol>
<p>此题得解，时间复杂度:O(NL)<br>注意一开始的初始化：dp[0][0] = 1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numMusicPlaylists</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> L, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; f(L + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;(N + <span class="number">1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= L; ++l) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= N; ++n) &#123;</span><br><span class="line">                f[l][n] = (f[l][n] + f[l - <span class="number">1</span>][n - <span class="number">1</span>] * (N - (n - <span class="number">1</span>))) % M;</span><br><span class="line">                f[l][n] = (f[l][n] + f[l - <span class="number">1</span>][n] * max(<span class="number">0</span>, n - K)) % M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[L][N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>RESTful API 设计规范（转）</title>
    <url>/2020/12/31/RESTful-API-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%EF%BC%88%E8%BD%AC%EF%BC%89/</url>
    <content><![CDATA[<h2 id="RESTful-API-设计规范（转）"><a href="#RESTful-API-设计规范（转）" class="headerlink" title="RESTful API 设计规范（转）"></a>RESTful API 设计规范（转）</h2><p>该仓库整理了目前比较流行的 <code>RESTful api</code> 设计规范，为了方便讨论规范带来的问题及争议，现把该文档托管于 <code>Github</code>，欢迎大家补充！！</p>
<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul>
<li><a href="#restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83">RESTful API 设计规范</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E8%83%BD%E6%84%BF%E5%8A%A8%E8%AF%8D%E7%9A%84%E4%BD%BF%E7%94%A8">关于「能愿动词」的使用</a></li>
<li><a href="#protocol">Protocol</a></li>
<li><a href="#api-root-url">API Root URL</a></li>
<li><a href="#versioning">Versioning</a><ul>
<li><a href="#%E5%9C%A8-url-%E4%B8%AD%E5%B5%8C%E5%85%A5%E7%89%88%E6%9C%AC%E7%BC%96%E5%8F%B7">在 URL 中嵌入版本编号</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B%E6%9D%A5%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF">通过媒体类型来指定版本信息</a></li>
</ul>
</li>
<li><a href="#endpoints">Endpoints</a></li>
<li><a href="#http-%E5%8A%A8%E8%AF%8D">HTTP 动词</a></li>
<li><a href="#filtering">Filtering</a></li>
<li><a href="#authentication">Authentication</a></li>
<li><a href="#response">Response</a><ul>
<li><a href="#200-ok">200 ok</a></li>
<li><a href="#201-created">201 Created</a></li>
<li><a href="#202-accepted">202 Accepted</a></li>
<li><a href="#204-no-content">204 No Content</a></li>
<li><a href="#3xx-%E9%87%8D%E5%AE%9A%E5%90%91">3xx 重定向</a></li>
<li><a href="#400-bad-request">400 Bad Request</a></li>
<li><a href="#401-unauthorized">401 Unauthorized</a></li>
<li><a href="#403-forbidden">403 Forbidden</a></li>
<li><a href="#404-not-found">404 Not Found</a></li>
<li><a href="#405-method-not-allowd">405 Method Not Allowd</a></li>
<li><a href="#406-not-acceptable">406 Not Acceptable</a></li>
<li><a href="#408-request-timeout">408 Request Timeout</a></li>
<li><a href="#409-gonfilct">409 Gonfilct</a></li>
<li><a href="#410-gone">410 Gone</a></li>
<li><a href="#413-request-entity-too-large">413 Request Entity Too Large</a></li>
<li><a href="#414-request-uri-too-long">414 Request-URI Too Long</a></li>
<li><a href="#415-unsupported-media-type">415 Unsupported Media Type</a></li>
<li><a href="#429-too-many-request">429 Too Many Request</a></li>
<li><a href="#500-internal-server-error">500 Internal Server Error</a></li>
<li><a href="#503-service-unavailable">503 Service Unavailable</a></li>
</ul>
</li>
<li><a href="#%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E">版权声明</a></li>
<li><a href="#%E5%BB%BA%E8%AE%AE%E5%8F%82%E8%80%83">建议参考</a></li>
<li><a href="#license">LICENSE</a></li>
</ul>
<a id="more"></a>

<h2 id="关于「能愿动词」的使用"><a href="#关于「能愿动词」的使用" class="headerlink" title="关于「能愿动词」的使用"></a>关于「能愿动词」的使用</h2><p>为了避免歧义，文档大量使用了「能愿动词」，对应的解释如下：</p>
<ul>
<li><code>必须 (MUST)</code>：绝对，严格遵循，请照做，无条件遵守；</li>
<li><code>一定不可 (MUST NOT)</code>：禁令，严令禁止；</li>
<li><code>应该 (SHOULD)</code> ：强烈建议这样做，但是不强求；</li>
<li><code>不该 (SHOULD NOT)</code>：强烈不建议这样做，但是不强求；</li>
<li><code>可以 (MAY)</code> 和 <code>可选 (OPTIONAL)</code> ：选择性高一点，在这个文档内，此词语使用较少；</li>
</ul>
<blockquote>
<p>参见：<a href="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a></p>
</blockquote>
<h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><p>客户端在通过 <code>API</code> 与后端服务通信的过程中，<code>应该</code> 使用 <code>HTTPS</code> 协议。</p>
<h2 id="API-Root-URL"><a href="#API-Root-URL" class="headerlink" title="API Root URL"></a>API Root URL</h2><p><code>API</code> 的根入口点应尽可能保持足够简单，这里有两个常见的 <code>URL</code> 根例子：</p>
<ul>
<li>api.example.com/*</li>
<li>example.com/api/*</li>
</ul>
<blockquote>
<p>如果你的应用很庞大或者你预计它将会变的很庞大，那 <code>应该</code> 将 <code>API</code> 放到子域下（<code>api.example.com</code>）。这种做法可以保持某些规模化上的灵活性。</p>
</blockquote>
<h2 id="Versioning"><a href="#Versioning" class="headerlink" title="Versioning"></a>Versioning</h2><p>所有的 <code>API</code> 必须保持向后兼容，你 <code>必须</code> 在引入新版本 <code>API</code> 的同时确保旧版本 <code>API</code> 仍然可用。所以 <code>应该</code> 为其提供版本支持。</p>
<p>目前比较常见的两种版本号形式：</p>
<h3 id="在-URL-中嵌入版本编号"><a href="#在-URL-中嵌入版本编号" class="headerlink" title="在 URL 中嵌入版本编号"></a>在 URL 中嵌入版本编号</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">api.example.com/v1/*</span><br></pre></td></tr></table></figure>
<p>这种做法是版本号直观、易于调试；另一种做法是，将版本号放在 <code>HTTP Header</code> 头中：</p>
<h3 id="通过媒体类型来指定版本信息"><a href="#通过媒体类型来指定版本信息" class="headerlink" title="通过媒体类型来指定版本信息"></a>通过媒体类型来指定版本信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Accept: application/vnd.example.com.v1+json</span><br></pre></td></tr></table></figure>
<p>其中 <code>vnd</code> 表示 <code>Standards Tree</code> 标准树类型，有三个不同的树: <code>x</code>，<code>prs</code> 和 <code>vnd</code>。你使用的标准树需要取决于你开发的项目</p>
<ul>
<li>未注册的树（<code>x</code>）主要表示本地和私有环境</li>
<li>私有树（<code>prs</code>）主要表示没有商业发布的项目</li>
<li>供应商树（<code>vnd</code>）主要表示公开发布的项目</li>
</ul>
<blockquote>
<p>后面几个参数依次为应用名称（一般为应用域名）、版本号、期望的返回格式。</p>
</blockquote>
<p>至于具体把版本号放在什么地方，这个问题一直存在很大的争议，但由于我们大多数时间都在使用 <code>Laravel</code> 开发，<code>应该</code> 使用 <a href="https://github.com/dingo/api">dingo/api</a> 来快速构建应用，它采用第二种方式来管理 <code>API</code> 版本，并且已集成了标准的 <code>HTTP Response</code>。</p>
<h2 id="Endpoints"><a href="#Endpoints" class="headerlink" title="Endpoints"></a>Endpoints</h2><p>端点就是指向特定资源或资源集合的 <code>URL</code>。在端点的设计中，你 <code>必须</code> 遵守下列约定：</p>
<ul>
<li>URL 的命名 <code>必须</code> 全部小写</li>
<li>URL 中资源（<code>resource</code>）的命名 <code>必须</code> 是名词，并且 <code>必须</code> 是复数形式</li>
<li><code>必须</code> 优先使用 <code>Restful</code> 类型的 URL</li>
<li>URL <code>必须</code> 是易读的</li>
<li>URL <code>一定不可</code> 暴露服务器架构</li>
</ul>
<blockquote>
<p>至于 URL 是否必须使用连字符（<code>-</code>） 或下划线（<code>_</code>），不做硬性规定，但 <code>必须</code> 根据团队情况统一一种风格。</p>
</blockquote>
<p>来看一个反例</p>
<ul>
<li><a href="https://api.example.com/getUserInfo?userid=1">https://api.example.com/getUserInfo?userid=1</a></li>
<li><a href="https://api.example.com/getusers">https://api.example.com/getusers</a></li>
<li><a href="https://api.example.com/sv/u">https://api.example.com/sv/u</a></li>
<li><a href="https://api.example.com/cgi-bin/users/get_user.php?userid=1">https://api.example.com/cgi-bin/users/get_user.php?userid=1</a></li>
</ul>
<p>再来看一个正例</p>
<ul>
<li><a href="https://api.example.com/zoos">https://api.example.com/zoos</a></li>
<li><a href="https://api.example.com/animals">https://api.example.com/animals</a></li>
<li><a href="https://api.example.com/zoos/%7Bzoo%7D/animals">https://api.example.com/zoos/{zoo}/animals</a></li>
<li><a href="https://api.example.com/animal_types">https://api.example.com/animal_types</a></li>
<li><a href="https://api.example.com/employees">https://api.example.com/employees</a></li>
</ul>
<h2 id="HTTP-动词"><a href="#HTTP-动词" class="headerlink" title="HTTP 动词"></a>HTTP 动词</h2><p>对于资源的具体操作类型，由 <code>HTTP</code> 动词表示。常用的 <code>HTTP</code> 动词有下面五个（括号里是对应的 <code>SQL</code> 命令）。</p>
<ul>
<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
</ul>
<p>其中</p>
<p>1 删除资源 <code>必须</code> 用 <code>DELETE</code> 方法<br>2 创建新的资源 <code>必须</code> 使用 <code>POST</code> 方法<br>3 更新资源 <code>应该</code> 使用 <code>PUT</code> 方法<br>4 获取资源信息 <code>必须</code> 使用 <code>GET</code> 方法</p>
<p>针对每一个端点来说，下面列出所有可行的 <code>HTTP</code> 动词和端点的组合</p>
<table>
<thead>
<tr>
<th>请求方法</th>
<th>URL</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>/zoos</td>
<td>列出所有的动物园(ID和名称，不要太详细)</td>
</tr>
<tr>
<td>POST</td>
<td>/zoos</td>
<td>新增一个新的动物园</td>
</tr>
<tr>
<td>GET</td>
<td>/zoos/{zoo}</td>
<td>获取指定动物园详情</td>
</tr>
<tr>
<td>PUT</td>
<td>/zoos/{zoo}</td>
<td>更新指定动物园(整个对象)</td>
</tr>
<tr>
<td>PATCH</td>
<td>/zoos/{zoo}</td>
<td>更新动物园(部分对象)</td>
</tr>
<tr>
<td>DELETE</td>
<td>/zoos/{zoo}</td>
<td>删除指定动物园</td>
</tr>
<tr>
<td>GET</td>
<td>/zoos/{zoo}/animals</td>
<td>检索指定动物园下的动物列表(ID和名称，不要太详细)</td>
</tr>
<tr>
<td>GET</td>
<td>/animals</td>
<td>列出所有动物(ID和名称)。</td>
</tr>
<tr>
<td>POST</td>
<td>/animals</td>
<td>新增新的动物</td>
</tr>
<tr>
<td>GET</td>
<td>/animals/{animal}</td>
<td>获取指定的动物详情</td>
</tr>
<tr>
<td>PUT</td>
<td>/animals/{animal}</td>
<td>更新指定的动物(整个对象)</td>
</tr>
<tr>
<td>PATCH</td>
<td>/animals/{animal}</td>
<td>更新指定的动物(部分对象)</td>
</tr>
<tr>
<td>GET</td>
<td>/animal_types</td>
<td>获取所有动物类型(ID和名称，不要太详细)</td>
</tr>
<tr>
<td>GET</td>
<td>/animal_types/{type}</td>
<td>获取指定的动物类型详情</td>
</tr>
<tr>
<td>GET</td>
<td>/employees</td>
<td>检索整个雇员列表</td>
</tr>
<tr>
<td>GET</td>
<td>/employees/{employee}</td>
<td>检索指定特定的员工</td>
</tr>
<tr>
<td>GET</td>
<td>/zoos/{zoo}/employees</td>
<td>检索在这个动物园工作的雇员的名单(身份证和姓名)</td>
</tr>
<tr>
<td>POST</td>
<td>/employees</td>
<td>新增指定新员工</td>
</tr>
<tr>
<td>POST</td>
<td>/zoos/{zoo}/employees</td>
<td>在特定的动物园雇佣一名员工</td>
</tr>
<tr>
<td>DELETE</td>
<td>/zoos/{zoo}/employees/{employee}</td>
<td>从某个动物园解雇一名员工</td>
</tr>
</tbody></table>
<blockquote>
<p>超出 <code>Restful</code> 端点的，<code>应该</code> 模仿上表的方式来定义端点。</p>
</blockquote>
<h2 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h2><blockquote>
<p>如果记录数量很多，服务器不可能都将它们返回给用户。API <code>应该</code> 提供参数，过滤返回结果。下面是一些常见的参数。</p>
</blockquote>
<ul>
<li>?limit=10：指定返回记录的数量</li>
<li>?offset=10：指定返回记录的开始位置。</li>
<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>
<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>
<li>?animal_type_id=1：指定筛选条件</li>
</ul>
<p>所有 <code>URL</code> 参数 <code>必须</code> 是全小写，<code>必须</code> 使用下划线类型的参数形式。</p>
<blockquote>
<p>分页参数 <code>必须</code> 固定为 <code>page</code>、<code>per_page</code></p>
</blockquote>
<p>经常使用的、复杂的查询 <code>应该</code> 标签化，降低维护成本。如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /trades?status=closed&amp;sort=sortby=name&amp;order=asc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可为其定制快捷方式</span></span><br><span class="line">GET /trades/recently_closed</span><br></pre></td></tr></table></figure>
<h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p><code>应该</code> 使用 <code>OAuth2.0</code> 的方式为 API 调用者提供登录认证。<code>必须</code> 先通过登录接口获取 <code>Access Token</code> 后再通过该 <code>token</code> 调用需要身份认证的 <code>API</code>。</p>
<p>Oauth 的端点设计示例</p>
<ul>
<li>RFC 6749   /token</li>
<li>Twitter    /oauth2/token</li>
<li>Fackbook   /oauth/access_token</li>
<li>Google     /o/oauth2/token</li>
<li>Github     /login/oauth/access_token</li>
<li>Instagram  /oauth/authorize</li>
</ul>
<p>客户端在获得 <code>access token</code> 的同时 <code>必须</code> 在响应中包含一个名为 <code>expires_in</code> 的数据，它表示当前获得的 <code>token</code> 会在多少 <code>秒</code> 后失效。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span>: <span class="string">&quot;token....&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;token_type&quot;</span>: <span class="string">&quot;Bearer&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;expires_in&quot;</span>: <span class="number">3600</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端在请求需要认证的 <code>API</code> 时，<code>必须</code> 在请求头 <code>Authorization</code> 中带上 <code>access_token</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Authorization: Bearer token...</span><br></pre></td></tr></table></figure>
<p>当超过指定的秒数后，<code>access token</code> 就会过期，再次用过期/或无效的 <code>token</code> 访问时，服务端 <code>应该</code> 返回 <code>invalid_token</code> 的错误或 <code>401</code> 错误码。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">401</span> Unauthorized</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;error&quot;: &quot;invalid_token&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Laravel 开发中，<code>应该</code> 使用 <a href="https://github.com/tymondesigns/jwt-auth">JWT</a> 来为管理你的 Token，并且 <code>一定不可</code> 在 <code>api</code> 中间件中开启请求 <code>session</code>。</p>
</blockquote>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p>所有的 <code>API</code> 响应，<code>必须</code> 遵守 <code>HTTP</code> 设计规范，<code>必须</code> 选择合适的 <code>HTTP</code> 状态码。<code>一定不可</code> 所有接口都返回状态码为 <code>200</code> 的 <code>HTTP</code> 响应，如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> ok</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Server</span>: example.com</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 0,</span><br><span class="line">    &quot;msg&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;username&quot;: &quot;username&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> ok</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Server</span>: example.com</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: -1,</span><br><span class="line">    &quot;msg&quot;: &quot;该活动不存在&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下表列举了常见的 <code>HTTP</code> 状态码</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>代表请求已被接受，需要继续处理</td>
</tr>
<tr>
<td>2xx</td>
<td>请求已成功，请求所希望的响应头或数据体将随此响应返回</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端原因引起的错误</td>
</tr>
<tr>
<td>5xx</td>
<td>服务端原因引起的错误</td>
</tr>
</tbody></table>
<blockquote>
<p>只有来自客户端的请求被正确的处理后才能返回 <code>2xx</code> 的响应，所以当 API 返回 <code>2xx</code> 类型的状态码时，前端 <code>必须</code> 认定该请求已处理成功。</p>
</blockquote>
<p>必须强调的是，所有 <code>API</code> <code>一定不可</code> 返回 <code>1xx</code> 类型的状态码。当 <code>API</code> 发生错误时，<code>必须</code> 返回出错时的详细信息。目前常见返回错误信息的方法有两种：</p>
<p>1、将错误详细放入 <code>HTTP</code> 响应首部；</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">X-MYNAME-ERROR-CODE</span>: 4001</span><br><span class="line"><span class="attribute">X-MYNAME-ERROR-MESSAGE</span>: Bad authentication token</span><br><span class="line"><span class="attribute">X-MYNAME-ERROR-INFO</span>: http://docs.example.com/api/v1/authentication</span><br></pre></td></tr></table></figure>
<p>2、直接放入响应实体中；</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">401</span> Unauthorized</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 10:02:59 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;error_code&quot;:40100,&quot;message&quot;:&quot;Unauthorized&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到易读性和客户端的易处理性，我们 <code>必须</code> 把错误信息直接放到响应实体中，并且错误格式 <code>应该</code> 满足如下格式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;您查找的资源不存在&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;error_code&quot;</span>: <span class="number">404001</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中错误码（<code>error_code</code>）<code>必须</code> 和 <code>HTTP</code> 状态码对应，也方便错误码归类，如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">429</span> Too Many Requests</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 10:15:52 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;error_code&quot;:429001,&quot;message&quot;:&quot;你操作太频繁了&quot;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">403</span> Forbidden</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 10:19:27 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;error_code&quot;:403002,&quot;message&quot;:&quot;用户已禁用&quot;&#125;</span><br></pre></td></tr></table></figure>
<p><code>应该</code> 在返回的错误信息中，同时包含面向开发者和面向用户的提示信息，前者可方便开发人员调试，后者可直接展示给终端用户查看如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;直接展示给终端用户的错误信息&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;error_code&quot;</span>: <span class="string">&quot;业务错误码&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;供开发者查看的错误信息&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;debug&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;错误堆栈，必须开启 debug 才存在&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面详细列举了各种情况 API 的返回说明。</p>
<h3 id="200-ok"><a href="#200-ok" class="headerlink" title="200 ok"></a>200 ok</h3><p><code>200</code> 状态码是最常见的 <code>HTTP</code> 状态码，在所有 <strong>成功</strong> 的 <code>GET</code> 请求中，<code>必须</code> 返回此状态码。<code>HTTP</code> 响应实体部分 <code>必须</code> 直接就是数据，不要做多余的包装。</p>
<p>错误示例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> ok</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Server</span>: example.com</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;user&quot;: &#123;</span><br><span class="line">        &quot;id&quot;:1,</span><br><span class="line">        &quot;nickname&quot;:&quot;fwest&quot;,</span><br><span class="line">        &quot;username&quot;: &quot;example&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确示例：</p>
<p>1、获取单个资源详情</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;godruoyi&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">88</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、获取资源集合</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;godruoyi&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;age&quot;</span>: <span class="number">88</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;age&quot;</span>: <span class="number">88</span>,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>3、额外的媒体信息</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;avatar&quot;</span>: <span class="string">&quot;https://lorempixel.com/640/480/?32556&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;nickname&quot;</span>: <span class="string">&quot;fwest&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;last_logined_time&quot;</span>: <span class="string">&quot;2018-05-29 04:56:43&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;has_registed&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">&quot;avatar&quot;</span>: <span class="string">&quot;https://lorempixel.com/640/480/?86144&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;nickname&quot;</span>: <span class="string">&quot;zschowalter&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;last_logined_time&quot;</span>: <span class="string">&quot;2018-06-16 15:18:34&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;has_registed&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;meta&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;pagination&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;total&quot;</span>: <span class="number">101</span>,</span><br><span class="line">            <span class="attr">&quot;count&quot;</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">&quot;per_page&quot;</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">&quot;current_page&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;total_pages&quot;</span>: <span class="number">51</span>,</span><br><span class="line">            <span class="attr">&quot;links&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;next&quot;</span>: <span class="string">&quot;http://api.example.com?page=2&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中，分页和其他额外的媒体信息，必须放到 <code>meta</code> 字段中。</p>
</blockquote>
<h3 id="201-Created"><a href="#201-Created" class="headerlink" title="201 Created"></a>201 Created</h3><p>当服务器创建数据成功时，<code>应该</code> 返回此状态码。常见的应用场景是使用 <code>POST</code> 提交用户信息，如：</p>
<ul>
<li>添加了新用户</li>
<li>上传了图片</li>
<li>创建了新活动</li>
</ul>
<p>等，都可以返回 <code>201</code> 状态码。需要注意的是，你可以选择在用户创建成功后返回新用户的数据</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">201</span> Created</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 09:13:40 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: 1,</span><br><span class="line">    &quot;avatar&quot;: &quot;https:\/\/lorempixel.com\/640\/480\/?32556&quot;,</span><br><span class="line">    &quot;nickname&quot;: &quot;fwest&quot;,</span><br><span class="line">    &quot;last_logined_time&quot;: &quot;2018-05-29 04:56:43&quot;,</span><br><span class="line">    &quot;created_at&quot;: &quot;2018-06-16 17:55:55&quot;,</span><br><span class="line">    &quot;updated_at&quot;: &quot;2018-06-16 17:55:55&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以返回一个响应实体为空的 <code>HTTP Response</code> 如：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">201</span> Created</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=UTF-8</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 09:12:20 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里我们 <code>应该</code> 采用第二种方式，因为大多数情况下，客户端只需要知道该请求操作成功与否，并不需要返回新资源的信息。</p>
</blockquote>
<h3 id="202-Accepted"><a href="#202-Accepted" class="headerlink" title="202 Accepted"></a>202 Accepted</h3><p>该状态码表示服务器已经接受到了来自客户端的请求，但还未开始处理。常用短信发送、邮件通知、模板消息推送等这类很耗时需要队列支持的场景中；</p>
<blockquote>
<p>返回该状态码时，响应实体 <code>必须</code> 为空。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 202 Accepted</span><br><span class="line">Server: nginx/1.11.9</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Sun, 24 Jun 2018 09:25:15 GMT</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<h3 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h3><p>该状态码表示响应实体不包含任何数据，其中：</p>
<ul>
<li>在使用 <code>DELETE</code> 方法删除资源 <strong>成功</strong> 时，<code>必须</code> 返回该状态码</li>
<li>使用 <code>PUT</code>、<code>PATCH</code> 方法更新数据 <strong>成功</strong> 时，也 <code>应该</code> 返回此状态码</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">204</span> No Content</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 09:29:12 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br></pre></td></tr></table></figure>
<h3 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h3><p>所有 <code>API</code> <code>不该</code> 返回 <code>3xx</code> 类型的状态码。因为 <code>3xx</code> 类型的响应格式一般为下列格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Server: nginx/1.11.9</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Cache-Control: no-cache, private</span><br><span class="line">Date: Sun, 24 Jun 2018 09:41:50 GMT</span><br><span class="line">Location: https://example.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0;url=https://example.com&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Redirecting to https://example.com<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        Redirecting to <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://example.com&quot;</span>&gt;</span>https://example.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>所有 <code>API</code> <code>一定不可</code> 返回纯 <code>HTML</code> 结构的响应；若一定要使用重定向功能，<code>可以</code> 返回一个响应实体为空的 <code>3xx</code> 响应，并在响应头中加上 <code>Location</code> 字段:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">302</span> Found</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=UTF-8</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 09:52:50 GMT</span><br><span class="line"><span class="attribute">Location</span>: https://godruoyi.com</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br></pre></td></tr></table></figure>
<h3 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h3><p>由于明显的客户端错误（例如，请求语法格式错误、无效的请求、无效的签名等），服务器 <code>应该</code> 放弃该请求。</p>
<blockquote>
<p>当服务器无法从其他 4xx 类型的状态码中找出合适的来表示错误类型时，都 <code>必须</code> 返回该状态码。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">400</span> Bad Request</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 13:22:36 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;error_code&quot;:40000,&quot;message&quot;:&quot;无效的签名&quot;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h3><p>该状态码表示当前请求需要身份认证，以下情况都 <code>必须</code> 返回该状态码。</p>
<ul>
<li>未认证用户访问需要认证的 API</li>
<li>access_token 无效/过期</li>
</ul>
<blockquote>
<p>客户端在收到 <code>401</code> 响应后，都 <code>应该</code> 提示用户进行下一步的登录操作。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">401</span> Unauthorized</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">WWW-Authenticate</span>: JWTAuth</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 13:17:02 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;message&quot;:&quot;Token Signature could not be verified.&quot;,&quot;error_code&quot;: &quot;40100&quot;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h3><p>该状态码可以简单的理解为没有权限访问该请求，服务器收到请求但拒绝提供服务。</p>
<p>如当普通用户请求操作管理员用户时，<code>必须</code> 返回该状态码。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">403</span> Forbidden</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 13:05:34 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;error_code&quot;:40301,&quot;message&quot;:&quot;权限不足&quot;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h3><p>该状态码表示用户请求的资源不存在，如</p>
<ul>
<li>获取不存在的用户信息 （get /users/9999999）</li>
<li>访问不存在的端点</li>
</ul>
<p>都 <code>必须</code> 返回该状态码，若该资源已永久不存在，则 <code>应该</code> 返回 <code>410</code> 响应。</p>
<h3 id="405-Method-Not-Allowed"><a href="#405-Method-Not-Allowed" class="headerlink" title="405 Method Not Allowed"></a>405 Method Not Allowed</h3><p>当客户端使用的 <code>HTTP</code> 请求方法不被服务器允许时，<code>必须</code> 返回该状态码。</p>
<blockquote>
<p>如客户端调用了 <code>POST</code> 方法来访问只支持 GET 方法的 API</p>
</blockquote>
<p>该响应 <code>必须</code> 返回一个 <code>Allow</code> 头信息用以表示出当前资源能够接受的请求方法的列表。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">405</span> Method Not Allowed</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Allow</span>: GET, HEAD</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 12:30:57 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;message&quot;:&quot;405 Method Not Allowed&quot;,&quot;error_code&quot;: 40500&#125;</span><br></pre></td></tr></table></figure>
<h3 id="406-Not-Acceptable"><a href="#406-Not-Acceptable" class="headerlink" title="406 Not Acceptable"></a>406 Not Acceptable</h3><p><code>API</code> 在不支持客户端指定的数据格式时，应该返回此状态码。如支持 <code>JSON</code> 和 <code>XML</code> 输出的 <code>API</code> 被指定返回 <code>YAML</code> 格式的数据时。</p>
<blockquote>
<p>Http 协议一般通过请求首部的 Accept 来指定数据格式</p>
</blockquote>
<h3 id="408-Request-Timeout"><a href="#408-Request-Timeout" class="headerlink" title="408 Request Timeout"></a>408 Request Timeout</h3><p>客户端请求超时时 <code>必须</code> 返回该状态码，需要注意的时，该状态码表示 <strong>客户端请求超时</strong>，在涉及第三方 <code>API</code> 调用超时时，<code>一定不可</code> 返回该状态码。</p>
<h3 id="409-Confilct"><a href="#409-Confilct" class="headerlink" title="409 Confilct"></a>409 Confilct</h3><p>该状态码表示因为请求存在冲突无法处理。如通过手机号码提供注册功能的 <code>API</code>，当用户提交的手机号已存在时，<code>必须</code> 返回此状态码。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">409</span> Conflict</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 12:19:04 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;error_code&quot;:40900,&quot;message&quot;:&quot;手机号已存在&quot;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="410-Gone"><a href="#410-Gone" class="headerlink" title="410 Gone"></a>410 Gone</h3><p>和 <code>404</code> 类似，该状态码也表示请求的资源不存在，只是 <code>410</code> 状态码进一步表示所请求的资源已不存在，并且未来也不会存在。在收到 <code>410</code> 状态码后，客户端 <code>应该</code> 停止再次请求该资源。</p>
<h3 id="413-Request-Entity-Too-Large"><a href="#413-Request-Entity-Too-Large" class="headerlink" title="413 Request Entity Too Large"></a>413 Request Entity Too Large</h3><p>该状态码表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。</p>
<blockquote>
<p>此种情况下，服务器可以关闭连接以免客户端继续发送此请求。</p>
</blockquote>
<p>如果这个状况是临时的，服务器 <code>应该</code> 返回一个 <code>Retry-After</code> 的响应头，以告知客户端可以在多少时间以后重新尝试。</p>
<h3 id="414-Request-URI-Too-Long"><a href="#414-Request-URI-Too-Long" class="headerlink" title="414 Request-URI Too Long"></a>414 Request-URI Too Long</h3><p>该状态码表示请求的 <code>URI</code> 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。</p>
<h3 id="415-Unsupported-Media-Type"><a href="#415-Unsupported-Media-Type" class="headerlink" title="415 Unsupported Media Type"></a>415 Unsupported Media Type</h3><p>通常表示服务器不支持客户端请求首部 <code>Content-Type</code> 指定的数据格式。如在只接受 <code>JSON</code> 格式的 <code>API</code> 中放入 <code>XML</code> 类型的数据并向服务器发送，都 <code>应该</code> 返回该状态码。</p>
<p>该状态码也可用于如：只允许上传图片格式的文件，但是客户端提交媒体文件非法或不是图片类型，这时 <code>应该</code> 返回该状态码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">415</span> Unsupported Media Type</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 12:09:40 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;error_code&quot;:41500,&quot;message&quot;:&quot;不允许上传的图片格式&quot;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="429-Too-Many-Requests"><a href="#429-Too-Many-Requests" class="headerlink" title="429 Too Many Requests"></a>429 Too Many Requests</h3><p>该状态码表示用户请求次数超过允许范围。如 <code>API</code> 设定为 <code>60次/分钟</code>，当用户在一分钟内请求次数超过 60 次后，都 <code>应该</code> 返回该状态码。并且也 <code>应该</code> 在响应首部中加上下列头部：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">X-RateLimit-Limit: 10 请求速率（由应用设定，其单位一般为小时/分钟等，这里是 10次/5分钟）</span><br><span class="line">X-RateLimit-Remaining: 0 当前剩余的请求数量</span><br><span class="line">X-RateLimit-Reset: 1529839462 重置时间</span><br><span class="line">Retry-After: 120 下一次访问应该等待的时间（秒）</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">429</span> Too Many Requests</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">X-RateLimit-Limit</span>: 10</span><br><span class="line"><span class="attribute">X-RateLimit-Remaining</span>: 0</span><br><span class="line"><span class="attribute">X-RateLimit-Reset</span>: 1529839462</span><br><span class="line"><span class="attribute">Retry-After</span>: 290</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 11:19:32 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;message&quot;:&quot;You have exceeded your rate limit.&quot;,&quot;error_code&quot;:42900&#125;</span><br></pre></td></tr></table></figure>
<p><code>必须</code> 为所有的 API 设置 Rate Limit 支持。</p>
<h3 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h3><p>该状态码 <code>必须</code> 在服务器出错时抛出，对于所有的 <code>500</code> 错误，都 <code>应该</code> 提供完整的错误信息支持，也方便跟踪调试。</p>
<h3 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h3><p>该状态码表示服务器暂时处理不可用状态，当服务器需要维护或第三方 <code>API</code> 请求超时/不可达时，都 <code>应该</code> 返回该状态码，其中若是主动关闭 API 服务，<code>应该 </code>在返回的响应首部加上 <code>Retry-After</code> 头部，表示多少秒后可以再次访问。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">503</span> Service Unavailable</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 10:56:20 GMT</span><br><span class="line"><span class="attribute">Retry-After</span>: 60</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;error_code&quot;:50300,&quot;message&quot;:&quot;服务维护中&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>其他 <code>HTTP</code> 状态码请参考 <a href="https://zh.wikipedia.org/zh-hans/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">HTTP 状态码- 维基百科</a>。</p>
<h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名（<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>）</p>
</blockquote>
<h2 id="建议参考"><a href="#建议参考" class="headerlink" title="建议参考"></a>建议参考</h2><p><a href="https://github.com/aisuhua/restful-api-design-references">restful-api-design-references</a></p>
<p><a href="http://www.cnblogs.com/moonz-wu/p/4211626.html">Principles of good RESTful API Design（译）</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html">理解 RESTful 架构</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">RESTful API 设计指南</a></p>
<p><a href="https://zh.wikipedia.org/zh-hans/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">HTTP 状态码- 维基百科</a></p>
<h2 id="LICENSE"><a href="#LICENSE" class="headerlink" title="LICENSE"></a>LICENSE</h2><p>MIT License</p>
<p>Copyright (c) 2018 godruoyi</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy<br>of this software and associated documentation files (the “Software”), to deal<br>in the Software without restriction, including without limitation the rights<br>to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<br>copies of the Software, and to permit persons to whom the Software is<br>furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all<br>copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br>IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br>FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br>AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br>LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br>OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE<br>SOFTWARE.</p>
]]></content>
      <categories>
        <category>Web design</category>
        <category>RESTful API</category>
      </categories>
      <tags>
        <tag>RESTful API</tag>
      </tags>
  </entry>
  <entry>
    <title>1644. Lowest Common Ancestor of a Binary Tree II</title>
    <url>/2021/01/06/1644-Lowest-Common-Ancestor-of-a-Binary-Tree-II/</url>
    <content><![CDATA[<p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree</a>的followup<br>postorder O(n) time O(h) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = lca(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">2</span> ? res : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">lca</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">auto</span> l = lca(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">auto</span> r = lca(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &amp;&amp; r) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> l ? l : r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = lca(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">2</span> ? res : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">lca</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++cnt == <span class="number">2</span>) <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> l = lca(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">auto</span> r = lca(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (l &amp;&amp; r) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">2</span>) <span class="keyword">return</span> (root == p || root == q) ? root : (l ? l : r);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Postorder traversal</tag>
        <tag>Binary tree</tag>
        <tag>Divide and conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>1032. Stream of Characters</title>
    <url>/2021/01/09/1032-Stream-of-Characters/</url>
    <content><![CDATA[<p>trie<br>因为是最后k个字母，所以是suffix tree</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamChecker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StreamChecker(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) : root(<span class="keyword">new</span> TrieNode) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : words) &#123;</span><br><span class="line">            add(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> letter)</span> </span>&#123;</span><br><span class="line">        data += letter;</span><br><span class="line">        <span class="keyword">return</span> search(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        TrieNode *children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="keyword">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> rit = rbegin(s); rit != rend(s); ++rit) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = *rit - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children[k]) &#123;</span><br><span class="line">                p-&gt;children[k] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;children[k];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> rit = rbegin(s); rit != rend(s); ++rit) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = *rit - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;isEnd) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children[k]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;children[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> data;</span><br><span class="line">    TrieNode *root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StreamChecker object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StreamChecker* obj = new StreamChecker(words);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;query(letter);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>109. Convert Sorted List to Binary Search Tree</title>
    <url>/2021/01/09/109-Convert-Sorted-List-to-Binary-Search-Tree/</url>
    <content><![CDATA[<p>O(n) time O(logn) space<br>采用中序遍历思想，先确定链表长度，然后二分递归进行中序遍历<br>是<a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">108. Convert Sorted Array to Binary Search Tree</a>的升级版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;head = head;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">dfs</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == e) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> m = b + (e - b) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> l = dfs(b, m);</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="keyword">new</span> TreeNode(head-&gt;val);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        res-&gt;left = l;</span><br><span class="line">        res-&gt;right = dfs(m + <span class="number">1</span>, e);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        node = head;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x = head; x; x = x-&gt;next) &#123;</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inorder(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">inorder</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> left = inorder(l, m - <span class="number">1</span>); <span class="comment">// 采用双闭区间</span></span><br><span class="line">        <span class="keyword">auto</span> res = <span class="keyword">new</span> TreeNode(node-&gt;val); <span class="comment">// 这一步一定要后于左半边递归，因为node此时并非真正的root，等左半边遍历过以后，node才是root</span></span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        res-&gt;left = left;</span><br><span class="line">        res-&gt;right = inorder(m + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(nlogn) time O(logn) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (!head-&gt;next) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head-&gt;val);</span><br><span class="line">        ListNode dummy_head(0), *slow = &amp;dummy_head, *fast = head;</span><br><span class="line">        dummy_head.next = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> root = slow-&gt;next;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="keyword">new</span> TreeNode(root-&gt;val);</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        res-&gt;left = sortedListToBST(head);</span><br><span class="line">        res-&gt;right = sortedListToBST(root-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
        <tag>Depth first search</tag>
        <tag>Linked list</tag>
        <tag>Binary search tree</tag>
        <tag>Inorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>114. Flatten Binary Tree to Linked List</title>
    <url>/2021/01/08/114-Flatten-Binary-Tree-to-Linked-List/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        helper(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">helper</span><span class="params">(TreeNode *root)</span> </span>&#123; <span class="comment">// 返回flatten之后的最后一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">auto</span> l = helper(root-&gt;left); <span class="comment">// 要保证l和r至少有一个不为空</span></span><br><span class="line">        <span class="keyword">auto</span> r = helper(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (l) &#123; <span class="comment">// 如果l不为空，root-&gt;right要接到l右边</span></span><br><span class="line">            l-&gt;right = root-&gt;right;</span><br><span class="line">            root-&gt;right = root-&gt;left;</span><br><span class="line">            root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r ? r : l ? l : root; <span class="comment">// 如果r也不为空，返回r，如果l不为空，返回l，否则返回root</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        flatten_helper(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">flatten_helper</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root || !root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">left_last</span><span class="params">(flatten_helper(root-&gt;left))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (left_last) &#123;</span><br><span class="line">            left_last-&gt;right = root-&gt;right;</span><br><span class="line">            root-&gt;right = root-&gt;left;</span><br><span class="line">            root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left_last ? flatten_helper(left_last) : flatten_helper(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Postorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>1209. Remove All Adjacent Duplicates in String II</title>
    <url>/2021/01/08/1209-Remove-All-Adjacent-Duplicates-in-String-II/</url>
    <content><![CDATA[<p>stack O(n) time O(n) space<br>维护一个&lt;字符+频数&gt;的stack 累计连续频数 每次连续频数达到k就出栈 最后把所有字符按频数拼接即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.empty() || stk.back().first != c) &#123;</span><br><span class="line">                stk.emplace_back(c, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (++stk.back().second == k) &#123;</span><br><span class="line">                stk.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [c, n] : stk) &#123;</span><br><span class="line">            res.append(n, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.empty() || stk.back().first != c) &#123;</span><br><span class="line">                stk.emplace_back(c, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++stk.back().second == k) &#123;</span><br><span class="line">                stk.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [c, n] : stk) &#123;</span><br><span class="line">            res.append(n, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>1382. Balance a Binary Search Tree</title>
    <url>/2021/01/09/1382-Balance-a-Binary-Search-Tree/</url>
    <content><![CDATA[<p>O(n) time O(n) space<br>先dfs扫一遍得到所有的node然后二分构造bst</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">balanceBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> reconstruct(<span class="number">0</span>, nodes.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        nodes.push_back(root);</span><br><span class="line">        <span class="keyword">auto</span> r = root-&gt;right;</span><br><span class="line">        root-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">        dfs(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">reconstruct</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == e) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (b + e) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> res = nodes[m];</span><br><span class="line">        res-&gt;left = reconstruct(b, m);</span><br><span class="line">        res-&gt;right = reconstruct(m + <span class="number">1</span>, e);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode *&gt; nodes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>DSW O(n) time O(1) space<br><a href="https://leetcode.com/problems/balance-a-binary-search-tree/discuss/541785/C%2B%2BJava-with-picture-DSW-O(n)orO(1)">解法</a><br>先通过多次右旋变成right-skew的单链，再按照树高（以及子树高）多次左旋</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">makeVine</span><span class="params">(TreeNode *grand, <span class="keyword">int</span> cnt = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> n = grand-&gt;right;</span><br><span class="line">      <span class="keyword">while</span> (n != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="keyword">auto</span> old_n = n;</span><br><span class="line">          n = n-&gt;left;</span><br><span class="line">          old_n-&gt;left = n-&gt;right;</span><br><span class="line">          n-&gt;right = old_n;</span><br><span class="line">          grand-&gt;right = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            grand = n;</span><br><span class="line">            n = n-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">compress</span><span class="params">(TreeNode *grand, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> n = grand-&gt;right;</span><br><span class="line">      <span class="keyword">while</span> (m-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> old_n = n;</span><br><span class="line">        n = n-&gt;right;</span><br><span class="line">        grand-&gt;right = n;</span><br><span class="line">        old_n-&gt;right = n-&gt;left;</span><br><span class="line">        n-&gt;left = old_n;</span><br><span class="line">        grand = n;</span><br><span class="line">        n = n-&gt;right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">balanceBST</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">      TreeNode grand;</span><br><span class="line">      grand.right = root;</span><br><span class="line">      <span class="keyword">auto</span> cnt = makeVine(&amp;grand);</span><br><span class="line">      <span class="keyword">int</span> m = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="keyword">int</span>(log2(cnt + <span class="number">1</span>))) - <span class="number">1</span>;</span><br><span class="line">      compress(&amp;grand, cnt - m);</span><br><span class="line">      <span class="keyword">for</span> (m = m / <span class="number">2</span>; m &gt; <span class="number">0</span>; m /= <span class="number">2</span>)</span><br><span class="line">        compress(&amp;grand, m);</span><br><span class="line">      <span class="keyword">return</span> grand.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
        <tag>Depth first search</tag>
        <tag>Binary search tree</tag>
        <tag>Preorder traversal</tag>
        <tag>Inorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>1424. Diagonal Traverse II</title>
    <url>/2021/01/09/1424-Diagonal-Traverse-II/</url>
    <content><![CDATA[<p>O(C) time O(log(max(m, n))) space<br>当一个binary tree来level order traverse</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q&#123;&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = q.front(); q.pop();</span><br><span class="line">            res.push_back(nums[r][c]);</span><br><span class="line">            <span class="keyword">if</span> (r + <span class="number">1</span> &lt; nums.size() &amp;&amp; c == <span class="number">0</span>) &#123; <span class="comment">// 因为每一行都非空，所以只有第一个需要添加左子，剩下的统一添加右子即可去重</span></span><br><span class="line">                q.emplace(r + <span class="number">1</span>, c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; nums[r].size()) &#123;</span><br><span class="line">                q.emplace(r, c + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Binary tree</tag>
        <tag>Level order traversal</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows</title>
    <url>/2021/01/09/1439-Find-the-Kth-Smallest-Sum-of-a-Matrix-With-Sorted-Rows/</url>
    <content><![CDATA[<p>O(mklog(min(n, k))) time O(min(n, k)) space<br><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/">373. Find K Pairs with Smallest Sums</a>的followup<br>不要想复杂了！！！直接做m - 1遍就行了<br>利用这种原理还可以做并行的两两merge</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">kSmallestPairs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.empty() || nums2.empty() || k == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">using</span> pii = <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;nums1, &amp;nums2](<span class="keyword">const</span> pii &amp;a, <span class="keyword">const</span> pii &amp;b) &#123; <span class="keyword">return</span> nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second]; &#125;;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;pii, <span class="built_in">vector</span>&lt;pii&gt;, <span class="keyword">decltype</span>(cmp)&gt; q(cmp);</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, sz = min(k, n); j &lt; sz; ++j) &#123;</span><br><span class="line">            q.emplace(<span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; !q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [i, j] = q.top(); q.pop();</span><br><span class="line">            res.push_back(nums1[i] + nums2[j]);</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; m) &#123;</span><br><span class="line">                q.emplace(i + <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.size(), n = min((<span class="keyword">int</span>)mat[<span class="number">0</span>].size(), k);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(begin(mat[<span class="number">0</span>]), begin(mat[<span class="number">0</span>]) + n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; m; ++r) &#123;</span><br><span class="line">            v = kSmallestPairs(v, mat[r], k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>并行merge版<br>跟<a href="https://leetcode.com/problems/merge-k-sorted-lists/">23. Merge k Sorted Lists</a>思路一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">kSmallestPairs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (nums1.empty()) <span class="keyword">return</span> nums2;</span><br><span class="line">        <span class="keyword">if</span> (nums2.empty()) <span class="keyword">return</span> nums1;</span><br><span class="line">        <span class="keyword">using</span> pii = <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;nums1, &amp;nums2](<span class="keyword">const</span> pii &amp;a, <span class="keyword">const</span> pii &amp;b) &#123; <span class="keyword">return</span> nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second]; &#125;;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;pii, <span class="built_in">vector</span>&lt;pii&gt;, <span class="keyword">decltype</span>(cmp)&gt; q(cmp);</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, sz = min(k, n); j &lt; sz; ++j) &#123;</span><br><span class="line">            q.emplace(<span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; !q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [i, j] = q.top(); q.pop();</span><br><span class="line">            res.push_back(nums1[i] + nums2[j]);</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; m) &#123;</span><br><span class="line">                q.emplace(i + <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = size(mat);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> step = <span class="number">1</span>; step &lt; m; step &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + step &lt; m; i += (step &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">                mat[i] = kSmallestPairs(mat[i], mat[i + step], k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mat[<span class="number">0</span>].back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Merging</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>329. Longest Increasing Path in a Matrix</title>
    <url>/2021/01/09/329-Longest-Increasing-Path-in-a-Matrix/</url>
    <content><![CDATA[<p>dfs + memo O(mn) time O(mn) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        m = size(matrix), n = size(matrix[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        f.resize(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c) &#123;</span><br><span class="line">                res = max(res, dfs(matrix, r, c, <span class="number">-1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;A, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> prev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || A[r][c] &lt;= prev) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (f[r][c] &gt; <span class="number">0</span>) <span class="keyword">return</span> f[r][c];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            res = max(res, dfs(A, r + dr[i], c + dc[i], A[r][c]) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[r][c] = res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n, dr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>Depth first search</tag>
        <tag>Topological sort</tag>
      </tags>
  </entry>
  <entry>
    <title>487. Max Consecutive Ones II</title>
    <url>/2021/01/08/487-Max-Consecutive-Ones-II/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>followup for infinite stream</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, c0 = <span class="number">0</span>, c1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">                ++c0;</span><br><span class="line">                ++c1;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c1 = c0 + <span class="number">1</span>;</span><br><span class="line">                c0 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, c1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>找最长的子数组最多只包含一个0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, cnt = <span class="number">0</span>, n = size(nums); r &lt; n; ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[r] == <span class="number">0</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[l] == <span class="number">0</span>) &#123;</span><br><span class="line">                    --cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>341. Flatten Nested List Iterator</title>
    <url>/2021/01/08/341-Flatten-Nested-List-Iterator/</url>
    <content><![CDATA[<p>amortized O(1)<br>stack类似BST iterator</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">        s.assign(rbegin(nestedList), rend(nestedList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = s.back().getInteger();</span><br><span class="line">        s.pop_back(); <span class="comment">// 别忘了pop</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; !s.back().isInteger()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> lst = s.back().getList();</span><br><span class="line">            s.pop_back();</span><br><span class="line">            s.insert(end(s), rbegin(lst), rend(lst));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !s.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;NestedInteger&gt; s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NestedIterator i(nestedList);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> rit = nestedList.rbegin(); rit != nestedList.rend(); ++rit) &#123;</span><br><span class="line">            s.push(*rit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = s.top().getInteger();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; !s.top().isInteger()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> lst = s.top().getList();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> rit = lst.rbegin(); rit != lst.rend(); ++rit) &#123;</span><br><span class="line">                s.push(*rit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !s.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;NestedInteger&gt; s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NestedIterator i(nestedList);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>iterator版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">        s.emplace(begin(nestedList), end(nestedList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = s.top().first-&gt;getInteger();</span><br><span class="line">        s.top().first++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;[b, e] = s.top();</span><br><span class="line">            <span class="keyword">if</span> (b == e) &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!b-&gt;isInteger()) &#123;</span><br><span class="line">                s.emplace(begin(b-&gt;getList()), end(b-&gt;getList()));</span><br><span class="line">                ++b;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !s.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> vnii = <span class="built_in">vector</span>&lt;NestedInteger&gt;::iterator;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">pair</span>&lt;vnii, vnii&gt;&gt; s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NestedIterator i(nestedList);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>515. Find Largest Value in Each Tree Row</title>
    <url>/2021/01/08/515-Find-Largest-Value-in-Each-Tree-Row/</url>
    <content><![CDATA[<p>O(n) BFS</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = q.front(); q.pop();</span><br><span class="line">                v = max(v, x-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (x-&gt;left) &#123;</span><br><span class="line">                    q.push(x-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (x-&gt;right) &#123;</span><br><span class="line">                    q.push(x-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>647. Palindromic Substrings</title>
    <url>/2021/01/09/647-Palindromic-Substrings/</url>
    <content><![CDATA[<p>O(n) manacher’s algorithm不会<br>brute force O(n<sup>2</sup>) time O(1) space<br>跟<a href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a>一样，直接数数即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cnt += helper(s, i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cnt += helper(s, i - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n &amp;&amp; s[l] == s[r]; ++cnt, --l, ++r);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>划分型dp O(n<sup>2</sup>) time O(n<sup>2</sup>) space<br>isPalin[i][j] = s[i] == s[j] &amp;&amp; isPalin[i + 1][j - 1]<br>f[i][j] = f[i][j - 1] + f[i + 1][j] - f[i + 1][j - 1] + isPalin[i][j]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; isPalin(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i][i] = <span class="number">1</span>;</span><br><span class="line">            isPalin[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            isPalin[i][i + <span class="number">1</span>] = (s[i] == s[i + <span class="number">1</span>]);</span><br><span class="line">            f[i][i + <span class="number">1</span>] = <span class="number">2</span> + isPalin[i][i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - len; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len;</span><br><span class="line">                isPalin[i][j] = (s[i] == s[j] &amp;&amp; isPalin[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                f[i][j] = f[i][j - <span class="number">1</span>] + f[i + <span class="number">1</span>][j] - f[i + <span class="number">1</span>][j - <span class="number">1</span>] + isPalin[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实没有必要维护一个计数的矩阵，直接用一个cnt就可以了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; isPalin(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            isPalin[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            isPalin[i][i + <span class="number">1</span>] = (s[i] == s[i + <span class="number">1</span>]);</span><br><span class="line">            cnt += isPalin[i][i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - len; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len;</span><br><span class="line">                isPalin[i][j] = (s[i] == s[j] &amp;&amp; isPalin[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                cnt += isPalin[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>1361. Validate Binary Tree Nodes</title>
    <url>/2021/01/10/1361-Validate-Binary-Tree-Nodes/</url>
    <content><![CDATA[<p>union-find O(n) time O(n) space<br>合法的树只有一个连通组件，因为点数和边数之差为1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateBinaryTreeNodes</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; leftChild, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rightChild)</span> </span>&#123;</span><br><span class="line">        parent.resize(n);</span><br><span class="line">        iota(begin(parent), end(parent), <span class="number">0</span>);</span><br><span class="line">        cnt = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!merge(i, leftChild[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!merge(i, rightChild[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">            x = parent[x] = parent[parent[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 注意-1的情况！！！</span></span><br><span class="line">        <span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line">        <span class="keyword">if</span> (px == py) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        parent[px] = py;</span><br><span class="line">        --cnt;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary tree</tag>
        <tag>Union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>348. Design Tic-Tac-Toe</title>
    <url>/2021/01/10/348-Design-Tic-Tac-Toe/</url>
    <content><![CDATA[<p>O(1) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicTacToe</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    TicTacToe(<span class="keyword">int</span> n) : n(n) &#123;</span><br><span class="line">        v.resize(n);</span><br><span class="line">        h.resize(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Player &#123;player&#125; makes a move at (&#123;row&#125;, &#123;col&#125;).</span></span><br><span class="line"><span class="comment">        @param row The row of the board.</span></span><br><span class="line"><span class="comment">        @param col The column of the board.</span></span><br><span class="line"><span class="comment">        @param player The player, can be either 1 or 2.</span></span><br><span class="line"><span class="comment">        @return The current winning condition, can be either:</span></span><br><span class="line"><span class="comment">                0: No one wins.</span></span><br><span class="line"><span class="comment">                1: Player 1 wins.</span></span><br><span class="line"><span class="comment">                2: Player 2 wins. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> player)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = (player &lt;&lt; <span class="number">1</span>) - <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(h[row] += s) == n) <span class="keyword">return</span> player;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(v[col] += s) == n) <span class="keyword">return</span> player;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(d += (row == col) * s) == n) <span class="keyword">return</span> player;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(ad += (row + col == n - <span class="number">1</span>) * s) == n) <span class="keyword">return</span> player;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v, h;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>, ad = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TicTacToe object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TicTacToe* obj = new TicTacToe(n);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;move(row,col,player);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>162. Find Peak Element</title>
    <url>/2021/01/10/162-Find-Peak-Element/</url>
    <content><![CDATA[<p>binary search O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">long</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &gt; nums[m + <span class="number">1</span>]) &#123; <span class="comment">// 因为一定存在peak所以只要单边检查即可，之所以选择m + 1而不是m - 1是因为m一定会取到较小的那个数，也就是说m + 1一定存在，而m - 1不一定</span></span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((m == <span class="number">0</span> || nums[m - <span class="number">1</span>] &lt; nums[m]) &amp;&amp; (m == n - <span class="number">1</span> || nums[m] &gt; nums[m + <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> m; <span class="comment">// 循环内return一律终止条件设成l &lt;= r</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span> || nums[m - <span class="number">1</span>] &lt; nums[m]) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>; <span class="comment">// m不可能是结果</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>; <span class="comment">// m不可能是结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt; nums[m + <span class="number">1</span>]) &#123; <span class="comment">// m never reaches n - 1</span></span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m; <span class="comment">// nums[m] &gt; nums[m + 1] so m could be an answer and should be inclusive when shrinking range</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>380. Insert Delete GetRandom O(1)</title>
    <url>/2021/01/10/380-Insert-Delete-GetRandom-O-1/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    RandomizedSet() &#123;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>)); <span class="comment">// 用时间做种子</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.count(val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        m[val] = v.size(); <span class="comment">// 用数组下标来把hashmap和数组联系起来</span></span><br><span class="line">        v.push_back(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m.count(val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        m[v.back()] = m[val]; <span class="comment">// 删除的主要操作是把数组中待删除的数和数组最后一个数『交换』，所以要把最后一个数的下标改成待删除的数的下标</span></span><br><span class="line">        v[m[val]] = v.back(); <span class="comment">// 把数组结尾的数挪到待删除的数的位置</span></span><br><span class="line">        v.pop_back();</span><br><span class="line">        m.erase(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.empty() ? <span class="number">0</span> : v[rand() % v.size()]; <span class="comment">// 注意数组为空的case</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// 因为添加删除都要O(1)所以肯定是unordered容器，又因为unordered_set无法保存更多的信息，所以肯定要想到用unordered_map</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v; <span class="comment">// 因为需要random access所以肯定要用一个数组存所有的数，即v[m[val]] = val</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Data structure design</tag>
      </tags>
  </entry>
  <entry>
    <title>419. Battleships in a Board</title>
    <url>/2021/01/10/419-Battleships-in-a-Board/</url>
    <content><![CDATA[<p>O(mn) time O(1) space<br>对于每个X只要确定左边和上边不是X就行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBattleships</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board.empty() || board[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = board.size(), m = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((board[i][j] == <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">                    &amp;&amp; (i == <span class="number">0</span> || board[i - <span class="number">1</span>][j] != <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">                    &amp;&amp; (j == <span class="number">0</span> || board[i][j - <span class="number">1</span>] != <span class="string">&#x27;X&#x27;</span>)) &#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>548. Split Array with Equal Sum</title>
    <url>/2021/01/10/548-Split-Array-with-Equal-Sum/</url>
    <content><![CDATA[<p>O(n<sup>2</sup>) time O(n) space<br>常规遍历ijk需要O(n<sup>3</sup>)，为了降低复杂度，先枚举j，然后分别枚举i和k，在枚举i的时候，如果遇到s[0:i-1] == s[i+1:j-1]则cache起来，这样在枚举k的时候，直接可以判断cache里是否存在s[j+1:k-1] == s[k+1:n-1]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">7</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">presum</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            presum.push_back(presum.back() + x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j &lt;= n - <span class="number">4</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= j - <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (presum[i] == presum[j] - presum[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    t.insert(presum[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">2</span>; k &lt;= n - <span class="number">2</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (presum[k] - presum[j + <span class="number">1</span>] == presum[n] - presum[k + <span class="number">1</span>] &amp;&amp; t.count(presum[k] - presum[j + <span class="number">1</span>])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n<sup>2</sup>) time O(n<sup>2</sup>) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">7</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> s = accumulate(begin(nums), end(nums), <span class="number">0</span>), s0 = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; m(n);</span><br><span class="line">        <span class="keyword">int</span> t = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j &lt;= n - <span class="number">4</span>; ++j) &#123;</span><br><span class="line">            t += nums[j];</span><br><span class="line">            <span class="keyword">int</span> s2 = nums[j + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">2</span>; k &lt;= n - <span class="number">2</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> s3 = s - (t + s2 + nums[k]);</span><br><span class="line">                <span class="keyword">if</span> (s2 == s3) &#123;</span><br><span class="line">                    m[j].insert(s2);</span><br><span class="line">                &#125;</span><br><span class="line">                s2 += nums[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> s1 = nums[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt;= n - <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s0 == s1 &amp;&amp; m[j].count(s1)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                s1 += nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            s0 += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>529. Minesweeper</title>
    <url>/2021/01/10/529-Minesweeper/</url>
    <content><![CDATA[<p>dfs</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; updateBoard(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; click) &#123;</span><br><span class="line">        m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">switch</span> (board[click[<span class="number">0</span>]][click[<span class="number">1</span>]]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = <span class="string">&#x27;X&#x27;</span>; <span class="keyword">return</span> board;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>: update(board, click[<span class="number">0</span>], click[<span class="number">1</span>]); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;b, <span class="keyword">int</span> y, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> yy = y + dy[i], xx = x + dx[i];</span><br><span class="line">            res += (<span class="number">0</span> &lt;= yy &amp;&amp; yy &lt; m &amp;&amp; <span class="number">0</span> &lt;= xx &amp;&amp; xx &lt; n &amp;&amp; b[yy][xx] == <span class="string">&#x27;M&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;b, <span class="keyword">int</span> y, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">0</span> || y &gt;= m || x &lt; <span class="number">0</span> || x &gt;= n || b[y][x] != <span class="string">&#x27;E&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = count(b, y, x);</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            b[y][x] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                update(b, y + dy[i], x + dx[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b[y][x] = <span class="string">&#x27;0&#x27;</span> + cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n, dy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, dx[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; updateBoard(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; click) &#123;</span><br><span class="line">        m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">switch</span> (board[click[<span class="number">0</span>]][click[<span class="number">1</span>]]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: &#123;</span><br><span class="line">                board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> board;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>: &#123;</span><br><span class="line">                update(board, click[<span class="number">0</span>], click[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;b, <span class="keyword">int</span> y, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> yy = y + dy[i], xx = x + dx[i];</span><br><span class="line">            <span class="keyword">if</span> (yy &lt; <span class="number">0</span> || yy &gt;= m || xx &lt; <span class="number">0</span> || xx &gt;= n || b[yy][xx] != <span class="string">&#x27;M&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;b, <span class="keyword">int</span> y, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">0</span> || y &gt;= m || x &lt; <span class="number">0</span> || x &gt;= n || b[y][x] != <span class="string">&#x27;E&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = count(b, y, x);</span><br><span class="line">        <span class="keyword">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            b[y][x] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                update(b, y + dy[i], x + dx[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b[y][x] = <span class="string">&#x27;0&#x27;</span> + ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title>678. Valid Parenthesis String</title>
    <url>/2021/01/10/678-Valid-Parenthesis-String/</url>
    <content><![CDATA[<p>two-pass greedy O(n) time O(1) space<br>反证即可，如果有反例则一定可以trap，否则就是balanced<br>There are 3 valid cases:</p>
<ol>
<li>There are more open parenthesis but we have enough ‘*‘ so we can balance the parenthesis with ‘)’</li>
<li>There are more close parenthesis but we have enough ‘*‘ so we can balance the parenthesis with ‘(‘</li>
<li>There are as many ‘(‘ than ‘)’ so all parenthesis are balanced, we can ignore the extra ‘*‘</li>
</ol>
<p>Algorithm: You can parse the String twice, once from left to right by replacing all ‘*‘ by ‘(‘ and once from right to left by replacing all ‘*‘ by ‘)’. For each of the 2 loops, if there’s an iteration where you end up with a negative count (SUM[‘(‘] - SUM[‘)’] &lt; 0) then you know the parenthesis were not balanced. You can return false. After these 2 checks (2 loops), you know the string is balanced because you’ve satisfied all the 3 valid cases mentioned above.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkValidString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            l += (c == <span class="string">&#x27;)&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>); <span class="comment">// 如果所有*都当(</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 只是用来加速，可有可无</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            r += (s[i] == <span class="string">&#x27;(&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>); <span class="comment">// 如果所有*都当)</span></span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 因为既没有左括号过多又没有右括号过多，所以是balanced</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n) 用lo和hi来表示可能的左括号个数减右括号个数之差（只考虑非负数）的区间，<br>比如(*)，(是[1, 1]，(*是[0, 2]，(*)是[0, 1]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkValidString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123; <span class="comment">// 遇见左括号，则区间整体加1</span></span><br><span class="line">                ++lo;</span><br><span class="line">                ++hi;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123; <span class="comment">// 遇见右括号，则区间整体减1</span></span><br><span class="line">                --lo;</span><br><span class="line">                --hi;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 遇见*，既可能是左括号，也可能是右括号，则区间扩大lo减1，hi加1</span></span><br><span class="line">                --lo;</span><br><span class="line">                ++hi;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hi &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 当hi为负时，说明右括号过多，肯定不合法</span></span><br><span class="line">            lo = max(lo, <span class="number">0</span>); <span class="comment">// lo如果小于0，说明)比(多，是不合法的，如果hi并没有小于0，说明lo小于0是由之前的*造成的，*不一定是)也可能是空字符或者(，所以这里lo时刻要保持为非负数，要排除之前的过多*和)对后边可能产生的影响，比如反例((*)(*))((*如果不维持lo始终非负，则最后会产生false negative，因为前面的*和)让low小于0，后边过多的(虽然让low变成非负，但是结果并不合法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo == <span class="number">0</span>; <span class="comment">// 最后判断一下0是否在区间里</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkValidString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            lo += c == <span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            hi += c == <span class="string">&#x27;)&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (hi &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            lo = max(lo, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Parentheses</tag>
      </tags>
  </entry>
  <entry>
    <title>724. Find Pivot Index</title>
    <url>/2021/01/10/724-Find-Pivot-Index/</url>
    <content><![CDATA[<p>前缀和 O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> presum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (presum == sum - presum - nums[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            presum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>前缀和 O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">presum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            presum[i] = presum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (presum[i] == presum[n] - presum[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>974. Subarray Sums Divisible by K</title>
    <url>/2021/01/10/974-Subarray-Sums-Divisible-by-K/</url>
    <content><![CDATA[<p>O(n) time O(n) space<br>统计模K同余的presum，跟<a href="https://leetcode.com/problems/continuous-subarray-sum/">523. Continuous Subarray Sum</a>类似，区别是K是正数且array可能有负数，所以不需要非得给前缀和维护一个hashmap，直接开一个长度为K的数组来统计即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraysDivByK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(K)</span></span>;</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 必须初始化模0的个数为1，表示什么都没有的情况有1个！！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            p += A[i];</span><br><span class="line">            ++cnt[((p % K) + K) % K];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : cnt) &#123;</span><br><span class="line">            res += x * (x - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 即(x - 1) * ((x - 1) + 1) / 2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n<sup>2</sup>) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraysDivByK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">presum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            presum[i + <span class="number">1</span>] = presum[i] + A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = (presum[j] - presum[i]) % K;</span><br><span class="line">                res += t == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>1102. Path With Maximum Minimum Value</title>
    <url>/2021/01/10/1102-Path-With-Maximum-Minimum-Value/</url>
    <content><![CDATA[<p>最小边费用最大的最短路径O(RClogRC) time O(RC) space<br>跟<a href="https://leetcode.com/problems/swim-in-rising-water/">778. Swim in Rising Water</a>思路完全一样<br>类dijkstra<br>用最大堆 只找大数 然后沿着大数走 同时用大数来更新结果 直到达到目的地</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumMinimumPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> R = A.size(), C = A[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(R, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(C));</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;A](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;a, <span class="keyword">const</span> <span class="keyword">auto</span> &amp;b) &#123; <span class="keyword">return</span> A[a.first][a.second] &lt; A[b.first][b.second]; &#125;;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; pq(cmp);</span><br><span class="line">        pq.emplace(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX, dr[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dc[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = pq.top(); pq.pop();</span><br><span class="line">            res = min(res, A[r][c]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r == R - <span class="number">1</span> &amp;&amp; c == C - <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> rr = r + dr[i], cc = c + dc[i];</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= rr &amp;&amp; rr &lt; R &amp;&amp; <span class="number">0</span> &lt;= cc &amp;&amp; cc &lt; C &amp;&amp; !visited[rr][cc]) &#123;</span><br><span class="line">                    pq.emplace(rr, cc);</span><br><span class="line">                    visited[rr][cc] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumMinimumPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> R = A.size(), C = A[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(R, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(C));</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;A](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;a, <span class="keyword">const</span> <span class="keyword">auto</span> &amp;b) &#123; <span class="keyword">return</span> A[a.first][a.second] &lt; A[b.first][b.second]; &#125;;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; pq(cmp);</span><br><span class="line">        pq.emplace(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX, dr[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dc[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = pq.top(); pq.pop();</span><br><span class="line">            res = min(res, A[r][c]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 优化：找出从(r, c)开始的一个范围，该范围内的所有点的费用都不超过A[r][c]</span></span><br><span class="line">            <span class="comment">// 因为用的是queue，不用入堆，局部上使用了复杂度更低的数据结构，但整体的检查规模并没有本质变化</span></span><br><span class="line">            <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">            q.emplace(r, c);</span><br><span class="line">            <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [r, c] = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (r == R - <span class="number">1</span> &amp;&amp; c == C - <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                    <span class="keyword">int</span> rr = r + dr[i], cc = c + dc[i];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= rr &amp;&amp; rr &lt; R &amp;&amp; <span class="number">0</span> &lt;= cc &amp;&amp; cc &lt; C &amp;&amp; !visited[rr][cc]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (A[rr][cc] &lt; res) &#123;</span><br><span class="line">                            pq.emplace(rr, cc);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不小于结果的数不会对结果产生影响，继续扩大局部搜索区域</span></span><br><span class="line">                            q.emplace(rr, cc);</span><br><span class="line">                        &#125;</span><br><span class="line">                        visited[rr][cc] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>union-find</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumMinimumPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> R = size(A), C = size(A[<span class="number">0</span>]);</span><br><span class="line">        parent.resize(R * C);</span><br><span class="line">        iota(begin(parent), end(parent), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; ++c) &#123;</span><br><span class="line">                v.emplace_back(r, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;A](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;a, <span class="keyword">const</span> <span class="keyword">auto</span> &amp;b) &#123; <span class="keyword">return</span> A[a.first][a.second] &gt; A[b.first][b.second]; &#125;;</span><br><span class="line">        sort(begin(v), end(v), cmp);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(R * C)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> dr[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dc[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[r, c] : v) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = r * C + c;</span><br><span class="line">            visited[k] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> rr = r + dr[i], cc = c + dc[i], kk = rr * C + cc;</span><br><span class="line">                <span class="keyword">if</span> (rr &lt; <span class="number">0</span> || rr &gt;= R || cc &lt; <span class="number">0</span> || cc &gt;= C || !visited[kk]) <span class="keyword">continue</span>;</span><br><span class="line">                merge(k, kk); <span class="comment">// 只有visit过的才去union，否则代码不好写</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (find(<span class="number">0</span>) == find(R * C - <span class="number">1</span>)) <span class="keyword">return</span> A[r][c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">            x = parent[x] = parent[parent[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line">        parent[py] = px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
        <tag>Breadth first search</tag>
        <tag>Depth first search</tag>
        <tag>Dijkstra</tag>
        <tag>Graph</tag>
        <tag>Union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>778. Swim in Rising Water</title>
    <url>/2021/01/10/778-Swim-in-Rising-Water/</url>
    <content><![CDATA[<p>这道题的前提是不能有相同海拔且海拔高度必须从0到n<sup>2</sup>-1<br>类dijkstra O(n<sup>2</sup>logn) time O(n<sup>2</sup>) space<br>这道题的难点是能看出来这其实是一个求最大边费用最小的最短路径（dijkstra）的题（和传统的求最小费用和的最短路径不一样），从一个点到邻居点的费用就是邻居点的海拔高度，这道题需要用dijkstra找到一条路径，使得路径上所有点的最高海拔高度尽可能小（这样就能用最少的时间从起点到终点），因为要维护尽可能小的海拔高度，所以要用堆，每次用堆顶的点的海拔高度来更新全局海拔高度，并将该点的邻接点入堆，至于选择四个方向的哪个邻居，完全基于贪心（dijkstra的本质），反正四个方向的邻居我们都会缓存起来，<strong>这样每次更新后实际上都会得到一个更大范围的包含最短路径的区域</strong>，在这道题里，这个区域的大小等于这个区域的海拔落差（最高海拔），并且该最短路径一定要经过这个最高海拔的点，因为（反证法）如果能找到另一条路径且最高海拔的点j比结果的最高海拔i要低，那么点j一定在点i之前入堆，且点i不可能入堆<br>跟<a href="https://leetcode.com/problems/path-with-maximum-minimum-value/">1102. Path With Maximum Minimum Value</a> 思路完全一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">swimInWater</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;](<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;lhs, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;rhs) &#123;<span class="keyword">return</span> grid[lhs.first][lhs.second] &gt; grid[rhs.first][rhs.second];&#125;;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; q(cmp);</span><br><span class="line">        q.emplace(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dr[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dc[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.top(); q.pop();</span><br><span class="line">            res = max(res, grid[p.first][p.second]);</span><br><span class="line">            <span class="keyword">if</span> (p.first == n - <span class="number">1</span> &amp;&amp; p.second == n - <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = p.first + dr[i], c = p.second + dc[i];</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= r &amp;&amp; r &lt; n &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; n &amp;&amp; !visited[r][c]) &#123;</span><br><span class="line">                    q.emplace(r, c);</span><br><span class="line">                    visited[r][c] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>采用队列进行局部优化后</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">swimInWater</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;](<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;lhs, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;rhs) &#123;<span class="keyword">return</span> grid[lhs.first][lhs.second] &gt; grid[rhs.first][rhs.second];&#125;;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; pq(cmp);</span><br><span class="line">        pq.emplace(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dr[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dc[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = pq.top(); pq.pop();</span><br><span class="line">            res = max(res, grid[p.first][p.second]);</span><br><span class="line">            <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">            q.push(p);</span><br><span class="line">            <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (p.first == n - <span class="number">1</span> &amp;&amp; p.second == n - <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = p.first + dr[i], c = p.second + dc[i];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= r &amp;&amp; r &lt; n &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; n &amp;&amp; !visited[r][c]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (grid[r][c] &lt;= res) &#123;</span><br><span class="line">                            q.emplace(r, c);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            pq.emplace(r, c);</span><br><span class="line">                        &#125;</span><br><span class="line">                        visited[r][c] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>二分+dfs O(n<sup>2</sup>logn) time<br>因为所有的海拔高度是从0到n<sup>2</sup>-1分布且最后答案一定在grid里面，所以适用二分查找，对于每一个candidate值，dfs遍历整个grid看是否能在candidate值以内（不超过）找到一条从grid[0][0]到grid[n - 1][n - 1]的路径</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">swimInWater</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        n = grid.size();</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n * n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isValid(grid, m)) &#123;</span><br><span class="line">                hi = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> mx)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">        <span class="keyword">int</span> dr[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dc[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> dfs(grid, visited, <span class="number">0</span>, <span class="number">0</span>, mx, dr, dc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;visited, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> mx, <span class="keyword">int</span> dr[], <span class="keyword">int</span> dc[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= n || c &lt; <span class="number">0</span> || c &gt;= n || visited[r][c] || grid[r][c] &gt; mx) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r == n - <span class="number">1</span> &amp;&amp; c == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        visited[r][c] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(grid, visited, r + dr[i], c + dc[i], mx, dr, dc)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
        <tag>Breadth first search</tag>
        <tag>Depth first search</tag>
        <tag>Dijkstra</tag>
        <tag>Graph</tag>
        <tag>Union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>283. Move Zeroes</title>
    <url>/2021/01/10/283-Move-Zeroes/</url>
    <content><![CDATA[<p>直接覆盖 O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[j++] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fill(begin(nums) + j, end(nums), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>swap O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; nums[i] != <span class="number">0</span>) ++i;</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n &amp;&amp; nums[j] == <span class="number">0</span>; ++j);</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>406. Queue Reconstruction by Height</title>
    <url>/2021/01/10/406-Queue-Reconstruction-by-Height/</url>
    <content><![CDATA[<p>greedy O(n<sup>2</sup>) time<br>先排序，第一位降序，第二位升序，然后按照第二位插入排序<br>第一位小说明矮，靠后排，第二位大说明比他高的人多，靠后排<br>每次把一个人往前放，不会影响比他高的人的位置，不管是在他之前还是之后，之后影响比他矮且比他更靠后的人的位置，但是我们后面会处理他们，所以不用管他们<br>People are only counting (in their k-value) taller or equal-height others standing in front of them. So a smallest person is completely irrelevant for all taller ones. And of all smallest people, the one standing most in the back is even completely irrelevant for everybody else. Nobody is counting that person. So we can first arrange everybody else, ignoring that one person. And then just insert that person appropriately. Now note that while this person is irrelevant for everybody else, everybody else is relevant for this person - this person counts exactly everybody in front of them. So their count-value tells you exactly the index they must be standing.</p>
<p>So you can first solve the sub-problem with all but that one person and then just insert that person appropriately. And you can solve that sub-problem the same way, first solving the sub-sub-problem with all but the last-smallest person of the subproblem. And so on. The base case is when you have the sub-…-sub-problem of zero people. You’re then inserting the people in the reverse order, i.e., that overall last-smallest person in the very end and thus the first-tallest person in the very beginning. That’s what the above solution does, Sorting the people from the first-tallest to the last-smallest, and inserting them one by one as appropriate.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reconstructQueue(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        sort(begin(people), end(people), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;lhs, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;rhs) &#123;</span><br><span class="line">            <span class="keyword">return</span> (lhs[<span class="number">0</span>] == rhs[<span class="number">0</span>]) ? (lhs[<span class="number">1</span>] &lt; rhs[<span class="number">1</span>]) : (lhs[<span class="number">0</span>] &gt; rhs[<span class="number">0</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; v : people) &#123;</span><br><span class="line">            res.insert(begin(res) + v[<span class="number">1</span>], v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>480. Sliding Window Median</title>
    <url>/2021/01/10/480-Sliding-Window-Median/</url>
    <content><![CDATA[<p>multiset/hashheap O(nlogk)<br>跟<a href="https://leetcode.com/problems/sliding-window-maximum/">239. Sliding Window Maximum</a>方法不一样，太smart了<br>讨论一下添加删除的四种情况即可，两个if都能cover</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(begin(nums), begin(nums) + k)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> m = next(begin(s), k / <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n; ++i) &#123;</span><br><span class="line">            res.push_back((k &amp; <span class="number">1</span>) ? *m : (*prev(m) + <span class="keyword">double</span>(*m)) * <span class="number">0.5</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == n) <span class="keyword">break</span>;</span><br><span class="line">            s.insert(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; *m) &#123; <span class="comment">// 偶变奇则需要前移</span></span><br><span class="line">                --m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - k] &lt;= *m) &#123; <span class="comment">// 如果要删除的数有可能是*m要提前对m作调整，否则删除以后m就spoil了</span></span><br><span class="line">                ++m; <span class="comment">// 奇变偶需要后移</span></span><br><span class="line">            &#125;</span><br><span class="line">            s.erase(s.find(nums[i - k]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; max, min;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            max.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            min.insert(*max.rbegin());</span><br><span class="line">            max.erase(max.find(*max.rbegin())); <span class="comment">// Remember this usage!</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max.size() == min.size()) &#123;</span><br><span class="line">                res.push_back(*max.rbegin() / <span class="number">2.0</span> + *min.begin() / <span class="number">2.0</span>); <span class="comment">// (a + b) / 2.0 could overflow!</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(*max.rbegin());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (max.count(nums[i - k])) &#123;</span><br><span class="line">                max.erase(max.find(nums[i - k]));</span><br><span class="line">                max.insert(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                min.erase(min.find(nums[i - k]));</span><br><span class="line">                min.insert(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!max.empty() &amp;&amp; !min.empty() &amp;&amp; *max.rbegin() &gt; *min.begin()) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = *max.rbegin();</span><br><span class="line">                max.erase(max.find(tmp));</span><br><span class="line">                max.insert(*min.begin());</span><br><span class="line">                min.erase(min.begin());</span><br><span class="line">                min.insert(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max.size() == min.size()) &#123;</span><br><span class="line">            res.push_back(*max.rbegin() / <span class="number">2.0</span> + *min.begin() / <span class="number">2.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push_back(*max.rbegin());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>691. Stickers to Spell Word</title>
    <url>/2021/01/10/691-Stickers-to-Spell-Word/</url>
    <content><![CDATA[<p>用这个 dp + memo O(N + N<sup>2</sup> + … + N<sup>T</sup>) = O((N * (N<sup>T</sup> - 1) / (N - 1))即每一层有N次循环 一共T层 N是sticker个数 T是target长度<br>cache[target]是所求结果，cache[“”] = 0<br>对每个sticker统计字母频<br>对每一层的target统计字母频<br>用每一个sticker去尝试拼凑部分target，拼不上的部分组成新的target再递归<br>遍历所有的可能，不断更新最小值即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minStickers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; stickers, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stickers.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">26</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : stickers[i]) &#123;</span><br><span class="line">                ++m[i][c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = dfs(m, target);</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;m, <span class="keyword">const</span> <span class="built_in">string</span> &amp;target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (cache.count(target)) <span class="keyword">return</span> cache[target];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mt</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : target) &#123;</span><br><span class="line">            ++mt[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = m.size();</span><br><span class="line">        <span class="keyword">long</span> res = INT_MAX; <span class="comment">// 把当前结果初始化为INT_MAX</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// if (m[i][target[0] - &#x27;a&#x27;] == 0) continue; // 这个优化剪枝很神奇，可以避免潜在的对target完全没有贡献的sticker，暂时无法贡献的sticker等到其他sticker把部分target拼凑出来以后再贡献</span></span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mt[j] &gt; m[i][j]) &#123; <span class="comment">// 这里大于或者大于等于无异，因为是要去掉当前sticker中可以拼成target的字母，所以如果sticker中的某个对应字母比target中的多，那么新组成的target就不需要添加该字母，所以只需要考虑sticker中对应字母不够拼成target的情况</span></span><br><span class="line">                    s.append(mt[j] - m[i][j], <span class="string">&#x27;a&#x27;</span> + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s == target) <span class="keyword">continue</span>; <span class="comment">// 如果没有之前那个优化，一定要判断新target和原target是否一样，避免重复递归</span></span><br><span class="line">            res = min(res, dfs(m, s) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[target] = res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">long</span>&gt; cache;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>状态压缩dp O(2<sup>n</sup>*(S+n*s)) n是target长度 S是stickers所有字母个数 s是stickers的个数<br>target从一个字母都找不到匹配到所有字母都匹配上一共2<sup>n</sup>个状态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minStickers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; stickers, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = target.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">1</span> &lt;&lt; n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">0</span>; state &lt; (<span class="number">1</span> &lt;&lt; n); ++state) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[state] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : stickers) &#123;</span><br><span class="line">                <span class="keyword">int</span> now = state;</span><br><span class="line">                <span class="keyword">int</span> m[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">                    ++m[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((now &gt;&gt; i) &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (m[target[i] - <span class="string">&#x27;a&#x27;</span>]-- &gt; <span class="number">0</span>) &#123; <span class="comment">// 用在哪个位置上无所谓，最后结果不影响</span></span><br><span class="line">                        now |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (f[now] == <span class="number">-1</span> || f[now] &gt; f[state] + <span class="number">1</span>) &#123;</span><br><span class="line">                    f[now] = f[state] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>状态压缩dp O(2<sup>n</sup>*n*S) n是target长度 S是stickers所有字母个数<br>target从一个字母都找不到匹配到所有字母都匹配上一共2<sup>n</sup>个状态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minStickers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; stickers, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = target.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">1</span> &lt;&lt; n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">0</span>; state &lt; (<span class="number">1</span> &lt;&lt; n); ++state) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[state] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s : stickers) &#123;</span><br><span class="line">                <span class="keyword">int</span> now = state;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((now &gt;&gt; i) &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (target[i] == c) &#123;</span><br><span class="line">                            now |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (f[now] == <span class="number">-1</span> || f[now] &gt; f[state] + <span class="number">1</span>) &#123;</span><br><span class="line">                    f[now] = f[state] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>92. Reverse Linked List II</title>
    <url>/2021/01/10/92-Reverse-Linked-List-II/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>这道题的思路跟普通的reverse不一样！！<br>curr是固定的，永远指向初始的第m个结点，anchor也是固定的，永远是curr的前继结点<br>每次curr都是和它的succ交换，然后让next的下一个指向anchor的下一个结点，最后anchor的下一个指向那个succ结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy_head(0), *anchor = &amp;dummy_head;</span><br><span class="line">        dummy_head.next = head;</span><br><span class="line">        n -= m;</span><br><span class="line">        <span class="keyword">while</span> (--m &gt; <span class="number">0</span>)</span><br><span class="line">            anchor = anchor-&gt;next;</span><br><span class="line">        <span class="keyword">auto</span> curr = anchor-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> succ = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = succ-&gt;next;</span><br><span class="line">            succ-&gt;next = anchor-&gt;next;</span><br><span class="line">            anchor-&gt;next = succ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>1094. Car Pooling</title>
    <url>/2021/01/11/1094-Car-Pooling/</url>
    <content><![CDATA[<p>扫描线</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">carPooling</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;t : trips) &#123;</span><br><span class="line">            m[t[<span class="number">1</span>]] += t[<span class="number">0</span>];</span><br><span class="line">            m[t[<span class="number">2</span>]] -= t[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[k, v] : m) &#123;</span><br><span class="line">            cnt += v;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sweep line</tag>
      </tags>
  </entry>
  <entry>
    <title>1262. Greatest Sum Divisible by Three</title>
    <url>/2021/01/11/1262-Greatest-Sum-Divisible-by-Three/</url>
    <content><![CDATA[<p>dp O(n) time O(1) space<br><a href="https://leetcode.com/problems/greatest-sum-divisible-by-three/discuss/927253/step-by-step%3A-top-down-greater-bottom-up-greater-optimised-DP-U-should-do-a-recursive-solution-first">思考过程</a><br>f[0] f[1] f[2]分别表示到当前数为止模3结果为0 1 2的最大和<br>0可以由0 + 0，1 + 2， 2 + 1生成<br>1可以由0 + 1, 1 + 0, 2 + 2生成<br>2可以由0 + 2， 1 + 1， 2 + 0生成<br>用这个<br>每得到一个新结果就尝试去更新对应的最大和<br>下面这种做法的转移方程为<br>f[{(f[i] + x) % 3}] = max{f[{(f[i] + x) % 3}], f[i] + x}, where i ~ [0, 2]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 要初始化为0，因为后边要做加法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = f;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y : f) &#123;</span><br><span class="line">                t[(y + x) % <span class="number">3</span>] = max(t[(y + x) % <span class="number">3</span>], y + x);</span><br><span class="line">            &#125;</span><br><span class="line">            f = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面这些方法f[1] f[2]必须初始化为无穷小表示不存在，因为最开始一个数都没有是不可能出现余数为1或2的最大和的，上面那种解法初始化为0是因为要用前一次迭代的最大和直接参与计算本次迭代的结果应该给哪个余数下标，算法上有区别</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f&#123;<span class="number">0</span>, INT_MIN, INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = f;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">                t[(x + i) % <span class="number">3</span>] = max(f[(x + i) % <span class="number">3</span>], f[i] + x);</span><br><span class="line">            &#125;</span><br><span class="line">            f = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f&#123;<span class="number">0</span>, INT_MIN, INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (x % <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                    f[<span class="number">0</span>] += x;</span><br><span class="line">                    f[<span class="number">1</span>] += x;</span><br><span class="line">                    f[<span class="number">2</span>] += x;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                    <span class="keyword">auto</span> t = &#123;max(f[<span class="number">0</span>], f[<span class="number">2</span>] + x),</span><br><span class="line">                              max(f[<span class="number">1</span>], f[<span class="number">0</span>] + x),</span><br><span class="line">                              max(f[<span class="number">2</span>], f[<span class="number">1</span>] + x)&#125;; <span class="comment">// t的type是initializer_list&lt;int&gt;</span></span><br><span class="line">                    f = t; <span class="comment">// vector&lt;int&gt;的operator=支持initializer_list&lt;int&gt;传参</span></span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: &#123;</span><br><span class="line">                    <span class="keyword">auto</span> t = &#123;max(f[<span class="number">0</span>], f[<span class="number">1</span>] + x),</span><br><span class="line">                              max(f[<span class="number">1</span>], f[<span class="number">2</span>] + x),</span><br><span class="line">                              max(f[<span class="number">2</span>], f[<span class="number">0</span>] + x)&#125;;</span><br><span class="line">                    f = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>NP</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(begin(nums), end(nums));</span><br><span class="line">        t = accumulate(begin(nums), end(nums), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t % <span class="number">3</span> == <span class="number">0</span>) <span class="keyword">return</span> t;</span><br><span class="line">        dfs(<span class="number">0</span>, nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; A.size(); ++i) &#123;</span><br><span class="line">            s += A[i];</span><br><span class="line">            <span class="keyword">if</span> (t - s &lt;= res) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> ((t - s) % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                res = max(res, t - s);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dfs(s, A, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s -= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>1344. Angle Between Hands of a Clock</title>
    <url>/2021/01/11/1344-Angle-Between-Hands-of-a-Clock/</url>
    <content><![CDATA[<p>O(1) time O(1) space<br>表盘360度 每一分钟360 / 60 = 6度 每一小时360 / 12 = 30度<br>注意分针在走时 时针也在走 所以时针可能不是指向整点位置<br>分针距离0点的度数 min * 6<br>时针距离0点的度数 (hr + min / 60) * 30<br>两者相减后求绝对值即为diff<br>最后只需要返回min{diff, 360 - diff}即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">angleClock</span><span class="params">(<span class="keyword">int</span> hour, <span class="keyword">int</span> minutes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> diff = <span class="built_in">fabs</span>(minutes * <span class="number">5.5</span> - hour * <span class="number">30</span>);</span><br><span class="line">        <span class="keyword">return</span> min(diff, <span class="number">360</span> - diff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">angleClock</span><span class="params">(<span class="keyword">int</span> hour, <span class="keyword">int</span> minutes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> diff = <span class="built_in">fabs</span>(minutes * <span class="number">5.5</span> - hour * <span class="number">30</span>);</span><br><span class="line">        <span class="keyword">return</span> diff &lt;= <span class="number">180</span> ? diff : <span class="number">360</span> - diff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>161. One Edit Distance</title>
    <url>/2021/01/11/161-One-Edit-Distance/</url>
    <content><![CDATA[<p>O(m+n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOneEditDistance</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = t.length();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">            swap(s, t);</span><br><span class="line">            swap(m, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n - m &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != t[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m &lt; n) <span class="keyword">return</span> s.substr(i) == t.substr(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> s.substr(i + <span class="number">1</span>) == t.substr(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span> == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOneEditDistance</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = t.length();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> isOneEditDistance(t, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n - m &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != t[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m &lt; n) <span class="keyword">return</span> s.substr(i) == t.substr(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> s.substr(i + <span class="number">1</span>) == t.substr(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span> == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOneEditDistance</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = t.length();</span><br><span class="line">        <span class="keyword">if</span> (m == n) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] != t[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (diff == <span class="number">1</span>) &#123;</span><br><span class="line">                        diff = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> diff == <span class="number">0</span>; <span class="comment">// s和t都为空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">            s.swap(t);</span><br><span class="line">            swap(m, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n - m != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m &amp;&amp; j &lt; n; ++i, ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != t[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (diff == <span class="number">1</span>) &#123;</span><br><span class="line">                    --i;</span><br><span class="line">                    diff = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>1650. Lowest Common Ancestor of a Binary Tree III</title>
    <url>/2021/01/11/1650-Lowest-Common-Ancestor-of-a-Binary-Tree-III/</url>
    <content><![CDATA[<p>O(h) time O(1) space<br>跟<a href="https://leetcode.com/problems/intersection-of-two-linked-lists/">160. Intersection of Two Linked Lists</a>一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* parent;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">lowestCommonAncestor</span><span class="params">(Node* p, Node * q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> a = p, b = q;</span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            a = a ? a-&gt;parent : q;</span><br><span class="line">            b = b ? b-&gt;parent : p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>277. Find the Celebrity</title>
    <url>/2021/01/11/277-Find-the-Celebrity/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>先扫描找出一个candidate再验证是不是真正的celebrity，只需要证明不会丢失真正的celebrity，因为所有人都会被check，真正的celebrity一定能成为candidate</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of the knows API.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">knows</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cand = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// if (!knows(i, cand)) &#123; // 理论上也可以</span></span><br><span class="line">            <span class="keyword">if</span> (knows(cand, i)) &#123;</span><br><span class="line">                cand = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != cand &amp;&amp; (knows(cand, i) || !knows(i, cand))) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>295. Find Median from Data Stream</title>
    <url>/2021/01/11/295-Find-Median-from-Data-Stream/</url>
    <content><![CDATA[<p>heap O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds a number into the data structure.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123; <span class="comment">// 3次调整</span></span><br><span class="line">        left.push(num); <span class="comment">// 先放到左边最大堆调整</span></span><br><span class="line">        right.push(left.top()); left.pop(); <span class="comment">// 再取左边最大堆最大的数放到右边最小堆调整</span></span><br><span class="line">        <span class="keyword">if</span> (left.size() &lt; right.size()) &#123; <span class="comment">// 如果左边数少则取右边最小堆最小的数放到左边最大堆再调整，要始终保持左边最大堆的数不少于右边最小堆的数</span></span><br><span class="line">            left.push(right.top()); right.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the median of current data stream</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left.size() &gt; right.size() ? left.top() : (left.top() + right.top()) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; left;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// MedianFinder mf;</span></span><br><span class="line"><span class="comment">// mf.addNum(1);</span></span><br><span class="line"><span class="comment">// mf.findMedian();</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds a number into the data structure.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left.empty() &amp;&amp; right.empty()) &#123;</span><br><span class="line">            median = num;</span><br><span class="line">            left.push(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; median) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.size() &gt; right.size()) &#123;</span><br><span class="line">                right.push(left.top());</span><br><span class="line">                left.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (right.size() &gt; left.size()) &#123;</span><br><span class="line">                left.push(right.top());</span><br><span class="line">                right.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            right.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left.size() &gt; right.size())</span><br><span class="line">            median = left.top();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (right.size() &gt; left.size())</span><br><span class="line">            median = right.top();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            median = (left.top() + right.top()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the median of current data stream</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> median;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; left;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; right;</span><br><span class="line">    <span class="keyword">double</span> median;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// MedianFinder mf;</span></span><br><span class="line"><span class="comment">// mf.addNum(1);</span></span><br><span class="line"><span class="comment">// mf.findMedian();</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>336. Palindrome Pairs</title>
    <url>/2021/01/11/336-Palindrome-Pairs/</url>
    <content><![CDATA[<p>O(n*k*k) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; palindromePairs(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            m[words[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= words[i].length(); ++j) &#123; <span class="comment">// 这里必须是&lt;=，反例[&quot;a&quot;, &quot;&quot;]，否则答案会少一组，如果没有空串则不需要</span></span><br><span class="line">                <span class="keyword">auto</span> left = words[i].substr(<span class="number">0</span>, j);</span><br><span class="line">                <span class="keyword">auto</span> right = words[i].substr(j);</span><br><span class="line">                <span class="keyword">if</span> (isValid(left)) &#123;</span><br><span class="line">                    <span class="function"><span class="built_in">string</span> <span class="title">t</span><span class="params">(rbegin(right), rend(right))</span></span>;</span><br><span class="line">                    <span class="keyword">if</span> (m.count(t) &amp;&amp; m[t] != i) &#123;</span><br><span class="line">                        res.push_back(&#123;m[t], i&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!right.empty() &amp;&amp; isValid(right)) &#123; <span class="comment">// 这里要对right判空，因为之前left已经处理过完整字符串了，避免重复处理添加，反例[&quot;ab&quot;, &quot;ba&quot;]</span></span><br><span class="line">                    <span class="function"><span class="built_in">string</span> <span class="title">t</span><span class="params">(rbegin(left), rend(left))</span></span>;</span><br><span class="line">                    <span class="keyword">if</span> (m.count(t) &amp;&amp; m[t] != i) &#123;</span><br><span class="line">                        res.push_back(&#123;i, m[t]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l++] != s[r--]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Trie版本O(n*k<sup>2</sup>)k是每个单词平均长度，n是单词个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; palindromePairs(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        Trie t;</span><br><span class="line">        <span class="keyword">int</span> n = words.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            t.add(words, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> idx : t.find(words[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (idx != i &amp;&amp; isPalindrome(words[i] + words[idx])) &#123; <span class="comment">// 连接所有的可能单词并检查合法性</span></span><br><span class="line">                    res.push_back(&#123;i, idx&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; j &amp;&amp; s[i] == s[j]; ++i, --j);</span><br><span class="line">        <span class="keyword">return</span> i &gt;= j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        TrieNode() : idx(<span class="number">-1</span>), children(&#123;<span class="literal">nullptr</span>&#125;) &#123;&#125;</span><br><span class="line">        TrieNode *children[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> idx; <span class="comment">// 如果单词到此结束，保存其下标</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indices; <span class="comment">// 保存所有长度大于等于 到此为止的单词 的单词的下标</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">        Trie() : root(<span class="keyword">new</span> TrieNode()) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> node = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> rit = words[idx].rbegin(); rit != words[idx].rend(); ++rit) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!node-&gt;children[*rit - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                    node-&gt;children[*rit - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;indices.push_back(idx); <span class="comment">// 如果当前单词不在此结束，当前节点保存该单词的下标</span></span><br><span class="line">                node = node-&gt;children[*rit - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            node-&gt;idx = idx; <span class="comment">// 当前单词结束于此，保存其下标</span></span><br><span class="line">            node-&gt;indices.push_back(idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> node = root;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : s) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                    res.insert(res.end(), node-&gt;indices.begin(), node-&gt;indices.end()); <span class="comment">// 虽然当前查找的目标单词不在Trie上，但是仍然要把一路遇到的所有下标以及本来继续往下可能会遇到的所有下标全部返回</span></span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;idx != <span class="number">-1</span>) &#123;</span><br><span class="line">                        res.push_back(node-&gt;idx); <span class="comment">// 路过此节点，保存其代表的单词的下标</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    node = node-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.insert(res.end(), node-&gt;indices.begin(), node-&gt;indices.end());</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode *root;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
        <tag>Implementation</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>358. Rearrange String k Distance Apart</title>
    <url>/2021/01/11/358-Rearrange-String-k-Distance-Apart/</url>
    <content><![CDATA[<p>max heap+greedy O(nlog26) time O(26) space<br>跟<a href="https://leetcode.com/problems/task-scheduler/">621. Task Scheduler</a>很像<br>按照字符频数由大到小放到k个slot里，用一个最大堆来维护字符顺序（频数高的在前，相同频数的ASCII码小的在前），每次从最大堆里pop出k个不同字符缓存起来并更新每个字符的频数（减1），如果字符频数不为0则加入缓存，则最后统一从缓存里加回最大堆，如果一旦中间过程中最大堆为空了而字符还没填满，说明有的字符频数过高，无法满足相同字符间距至少为k的要求，直接返回空串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">rearrangeString</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            ++f[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;f](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> f[a] == f[b] ? a &gt; b : f[a] &lt; f[b]; &#125;; <span class="comment">// 频数高的优先，相同频数的ASCII码小的优先</span></span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; q(cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v; <span class="comment">// 每次缓存k个字符</span></span><br><span class="line">            <span class="keyword">int</span> sz = min(k, n); <span class="comment">// 这里由于要对n进行更新所以要提前判断还需要append几个字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q.empty()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// q为空，说明有字符过多，不满足相同字符间隔至少为k的要求</span></span><br><span class="line">                <span class="keyword">int</span> x = q.top(); q.pop();</span><br><span class="line">                res += <span class="string">&#x27;a&#x27;</span> + x;</span><br><span class="line">                <span class="keyword">if</span> (--f[x] &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果放完当前字符还有剩余，则稍后放回堆</span></span><br><span class="line">                    v.push_back(x);</span><br><span class="line">                &#125;</span><br><span class="line">                --n; <span class="comment">// 每append一个字符，更新需求n</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x : v) &#123; <span class="comment">// 最后统一从缓存加回最大堆</span></span><br><span class="line">                q.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用类似<a href="https://leetcode.com/problems/reorganize-string/">767. Reorganize String</a>的处理方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">rearrangeString</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        iota(f, f + <span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            f[c - <span class="string">&#x27;a&#x27;</span>] += <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i] &gt; <span class="number">99</span>) &#123;</span><br><span class="line">                q.push(f[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v; <span class="comment">// 每次缓存k个字符</span></span><br><span class="line">            <span class="keyword">int</span> sz = min(k, n); <span class="comment">// 这里由于要对n进行更新所以要提前判断还需要append几个字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q.empty()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// q为空，说明有字符过多，不满足相同字符间隔至少为k的要求</span></span><br><span class="line">                <span class="keyword">int</span> x = q.top(); q.pop();</span><br><span class="line">                res += <span class="string">&#x27;a&#x27;</span> + x % <span class="number">100</span>;</span><br><span class="line">                x -= <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">if</span> (x &gt; <span class="number">99</span>) &#123; <span class="comment">// 如果放完当前字符还有剩余，则稍后放回堆</span></span><br><span class="line">                    v.push_back(x);</span><br><span class="line">                &#125;</span><br><span class="line">                --n; <span class="comment">// 每append一个字符，更新需求n</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x : v) &#123; <span class="comment">// 最后统一从缓存加回最大堆</span></span><br><span class="line">                q.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Heap</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>360. Sort Transformed Array</title>
    <url>/2021/01/11/360-Sort-Transformed-Array/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>双指针<br>如果抛物线parabola开口朝上（a &gt; 0）则取较大的那个数从后往前放<br>如果抛物线开口朝下（a &lt; 0）则取较小的那个数从前往后放<br>可以看做<a href="https://leetcode.com/problems/squares-of-a-sorted-array/">977. Squares of a Sorted Array</a>的followup</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortTransformedArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), l = <span class="number">0</span>, r = n - <span class="number">1</span>, i = a &lt; <span class="number">0</span> ? <span class="number">0</span> : n - <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> f = [a, b, c](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> (a * x + b) * x + c; &#125;;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123; <span class="comment">// 注意这里必须是l &lt;= r因为l和r相遇时的那个数也要处理</span></span><br><span class="line">            <span class="keyword">int</span> fl = f(nums[l]), fr = f(nums[r]), mn = min(fl, fr), mx = max(fl, fr);</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                res[i++] = mn;</span><br><span class="line">                mn == fl ? ++l : --r;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i--] = mx;</span><br><span class="line">                mx == fl ? ++l : --r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortTransformedArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), l = <span class="number">0</span>, r = n - <span class="number">1</span>, i = a &lt; <span class="number">0</span> ? <span class="number">0</span> : n - <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> f = [a, b, c](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> (a * x + b) * x + c; &#125;;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> fl = f(nums[l]), fr = f(nums[r]);</span><br><span class="line">            <span class="keyword">if</span> (fl &gt; fr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res[i++] = fr;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[i--] = fl;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res[i++] = fl;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[i--] = fr;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortTransformedArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = -b;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), l = <span class="number">0</span>, r = n - <span class="number">1</span>, i = a &lt; <span class="number">0</span> ? <span class="number">0</span> : n - <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = a * (nums[l] + nums[r]);</span><br><span class="line">            <span class="keyword">if</span> (s &lt; t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res[i++] = nums[r--];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[i--] = nums[l++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res[i++] = nums[l++];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[i--] = nums[r--];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : res) &#123;</span><br><span class="line">            x = (a * x + b) * x + c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortTransformedArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c = c;</span><br><span class="line">        <span class="keyword">int</span> t = -b;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), l = <span class="number">0</span>, r = n - <span class="number">1</span>, i = a &lt; <span class="number">0</span> ? <span class="number">0</span> : n - <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = a * (nums[l] + nums[r]);</span><br><span class="line">            <span class="keyword">if</span> (s &lt; t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res[i++] = f(nums[r--]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[i--] = f(nums[l++]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res[i++] = f(nums[l++]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[i--] = f(nums[r--]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * x * x + b * x + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>435. Non-overlapping Intervals</title>
    <url>/2021/01/11/435-Non-overlapping-Intervals/</url>
    <content><![CDATA[<p>greedy O(nlogn)<br>思路很基本，维护一个当前全局结束时间，先按开始时间排序，再扫描看当前interval是否和当前全局最晚结束的一个interval有overlap（即当前interval的开始时间早于当前全局结束时间）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(begin(intervals), end(intervals));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, e = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i[<span class="number">0</span>] &lt; e) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                e = min(e, i[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                e = i[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(intervals);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(begin(intervals), end(intervals));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e = intervals[<span class="number">0</span>][<span class="number">1</span>], i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; e) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                e = min(e, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                e = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>540. Single Element in a Sorted Array</title>
    <url>/2021/01/11/540-Single-Element-in-a-Sorted-Array/</url>
    <content><![CDATA[<p>二分 O(logn) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] == nums[m + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    r = m - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = m + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (m &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    l = m + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = m;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>too smart</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] == nums[m ^ <span class="number">1</span>]) &#123; <span class="comment">// 任一数m异或1得到其相邻的数，偶数则是相邻较大的奇数，奇数则是相邻较小的偶数</span></span><br><span class="line">                l = m + <span class="number">1</span>; <span class="comment">// 如果相邻两数相等，则所求的数肯定在右侧，因为两个数左边是偶数个数右边是奇数个数</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果相邻两数不等，则所求的数要不是nums[m]要不在左侧</span></span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>767. Reorganize String</title>
    <url>/2021/01/11/767-Reorganize-String/</url>
    <content><![CDATA[<p>可以利用<a href="https://leetcode.com/problems/rearrange-string-k-distance-apart/">358. Rearrange String k Distance Apart</a><br>O(n) time O(n) space<br>把原字符串按字母频重组成一个字符串，再用两个指针，一个从头，一个从中间（+1），往结果字符串里插，一定可以保证没有重复字母出现<br>aaaaabbcc ==&gt; ababacaca<br>这里需要证明：</p>
<ol>
<li>每次append的两个字符不一样<br>因为每个字符频数最多只能是(n + 1) / 2，所以第二个字符一定是从中间的下一个开始取，所以一定不一样</li>
<li>上一次append的第二个字符和本次append的第一个字符不一样<br>反证法，如果两个字符一样，说明该字符频数至少是(n + 1) / 2，但是因为该字符频数最多只能排到第二，所以一定还有一个字符频数至少是(n + 1) / 2，这样两个字符频数和就超过n了，所以两个字符一定不一样</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reorganizeString</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = S.length();</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 很牛逼的编码方式，f[i] = freq * 100 + i，避免使用pair的麻烦</span></span><br><span class="line">        iota(f, f + <span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : S) &#123;</span><br><span class="line">            f[c - <span class="string">&#x27;a&#x27;</span>] += <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(f, f + <span class="number">26</span>, greater&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span> (f[<span class="number">0</span>] / <span class="number">100</span> &gt; (n + <span class="number">1</span>) / <span class="number">2</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 如果某个字符过多，直接返回空串</span></span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            s.append(f[i] / <span class="number">100</span>, <span class="string">&#x27;a&#x27;</span> + f[i] % <span class="number">100</span>); <span class="comment">// 按频数由大到小重组字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            res += s[i];</span><br><span class="line">            <span class="keyword">int</span> j = i + (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n) &#123;</span><br><span class="line">                res += s[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>heap O(n) time O(1) space<br>这里需要证明：</p>
<ol>
<li>每次push的两个字符不一样<br>heap每个元素都是针对一个字符的，所以一定不一样</li>
<li>上一次push的第二个字符和本次push的第一个字符不一样<br>因为每次push的第一个字符的频数一定大于等于push的第二个字符的频数，所以本次push的第一个字符不可能比上次push的第一个字符优先级更高</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reorganizeString</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = S.length();</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : S) &#123;</span><br><span class="line">            f[c - <span class="string">&#x27;a&#x27;</span>] += <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i] / <span class="number">100</span> &gt; (n + <span class="number">1</span>) / <span class="number">2</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (f[i]) &#123;</span><br><span class="line">                q.push(f[i] + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span> (q.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> f1 = q.top(); q.pop();</span><br><span class="line">            <span class="keyword">int</span> f2 = q.top(); q.pop();</span><br><span class="line">            res += (<span class="string">&#x27;a&#x27;</span> + f1 % <span class="number">100</span>); f1 -= <span class="number">100</span>;</span><br><span class="line">            res += (<span class="string">&#x27;a&#x27;</span> + f2 % <span class="number">100</span>); f2 -= <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">if</span> (f1 &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">                q.push(f1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f2 &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">                q.push(f2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!q.empty()) &#123;</span><br><span class="line">            res += (<span class="string">&#x27;a&#x27;</span> + q.top() % <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Heap</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>791. Custom Sort String</title>
    <url>/2021/01/11/791-Custom-Sort-String/</url>
    <content><![CDATA[<p>O(m+n) time O(1) space<br>按照S的顺序把T中所有的字符重排即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">customSortString</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : T) &#123; <span class="comment">// 先统计T中字母频数</span></span><br><span class="line">            ++f[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : S) &#123;</span><br><span class="line">            s.append(f[c - <span class="string">&#x27;a&#x27;</span>], c); <span class="comment">// 按照S中的顺序重排</span></span><br><span class="line">            f[c - <span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>; <span class="comment">// 重排后频数清零</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            s.append(f[i], <span class="string">&#x27;a&#x27;</span> + i); <span class="comment">// 剩余没出现在S中的字母依次放到尾部即可</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>824. Goat Latin</title>
    <url>/2021/01/11/824-Goat-Latin/</url>
    <content><![CDATA[<p>O(n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toGoatLatin</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(S)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> res, s;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; vowel = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;U&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (input &gt;&gt; s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vowel.count(s[<span class="number">0</span>])) &#123;</span><br><span class="line">                s += s[<span class="number">0</span>];</span><br><span class="line">                s.erase(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s += <span class="string">&quot;ma&quot;</span>;</span><br><span class="line">            s.append(++i, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            res += s;</span><br><span class="line">            res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.pop_back();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>875. Koko Eating Bananas</title>
    <url>/2021/01/11/875-Koko-Eating-Bananas/</url>
    <content><![CDATA[<p>二分猜数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>, hi = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isValid(piles, H, m)) &#123;</span><br><span class="line">                hi = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;piles, <span class="keyword">int</span> H, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulate(begin(piles), end(piles), <span class="number">0</span>, [m](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x + (y - <span class="number">1</span>) / m + <span class="number">1</span>; &#125;) &lt;= H;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>, hi = *max_element(begin(piles), end(piles));</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isValid(piles, H, m)) &#123;</span><br><span class="line">                hi = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;piles, <span class="keyword">int</span> H, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulate(begin(piles), end(piles), <span class="number">0</span>, [m](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x + <span class="built_in">ceil</span>(y / (<span class="keyword">double</span>)m); &#125;) &lt;= H;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>885. Spiral Matrix III</title>
    <url>/2021/01/11/885-Spiral-Matrix-III/</url>
    <content><![CDATA[<p>O(max(R, C)<sup>2</sup>) time O(1) space<br>思路就是按照旋转方向走一遍即可，出界也照走，只有在界内才放到res里</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; spiralMatrixIII(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res = &#123;&#123;r0, c0&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> dr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dc[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> sz = <span class="number">1</span>, dir = <span class="number">0</span>, r = r0, c = c0;</span><br><span class="line">        <span class="keyword">while</span> (res.size() &lt; R * C) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">                r += dr[dir];</span><br><span class="line">                c += dc[dir];</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= r &amp;&amp; r &lt; R &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; C) &#123;</span><br><span class="line">                    res.push_back(&#123;r, c&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = (dir + <span class="number">1</span>) % <span class="number">4</span>; <span class="comment">// 方向每次转一下</span></span><br><span class="line">            sz += !(dir &amp; <span class="number">1</span>); <span class="comment">// 在每个方向上走的步数，每两个方向加一，即dir模2为0时加一</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>939. Minimum Area Rectangle</title>
    <url>/2021/01/11/939-Minimum-Area-Rectangle/</url>
    <content><![CDATA[<p>O(nx * nx * ny) time O(nx * ny) space<br>当nx趋近于n时时间复杂度上界是O(n<sup>2</sup>)所以理论上更优<br>把所有点按序存起来，先按x轴枚举任意两列，再对这两列依次比较相邻两行，找到最小矩形即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAreaRect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; m; <span class="comment">// 排序+去重</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : points) &#123;</span><br><span class="line">            m[p[<span class="number">0</span>]].insert(p[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = begin(m); i != end(m); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;&amp;si = i-&gt;second;</span><br><span class="line">            <span class="keyword">if</span> (si.size() == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = next(i); j != end(m); ++j) &#123;</span><br><span class="line">                <span class="keyword">auto</span> &amp;&amp;sj = j-&gt;second;</span><br><span class="line">                <span class="keyword">if</span> (sj.size() == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">bool</span> found_one = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">int</span> prev = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> y : sj) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!si.count(y)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prev &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">                        res = min(res, (j-&gt;first - i-&gt;first) * (y - prev));</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = y;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n<sup>2</sup>) time O(n) space<br>用对角线上两点找符合要求的矩形</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAreaRect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : points) &#123;</span><br><span class="line">            s.insert(p[<span class="number">0</span>] * <span class="number">40001</span> + p[<span class="number">1</span>]); <span class="comment">// 把所有点用int来表示</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (points[i][<span class="number">0</span>] == points[j][<span class="number">0</span>] || points[i][<span class="number">1</span>] == points[j][<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (s.count(points[i][<span class="number">0</span>] * <span class="number">40001</span> + points[j][<span class="number">1</span>]) &amp;&amp; s.count(points[j][<span class="number">0</span>] * <span class="number">40001</span> + points[i][<span class="number">1</span>])) &#123; <span class="comment">// 如果对角线两个点能找到对应的组成矩形的反对角线的另外两个点</span></span><br><span class="line">                    res = min(res, <span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) * <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAreaRect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>] || a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">        sort(begin(points), end(points), cmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; xs;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : points) &#123;</span><br><span class="line">            m[p[<span class="number">0</span>]].push_back(p[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (xs.empty() || xs.back() != p[<span class="number">0</span>]) &#123;</span><br><span class="line">                xs.push_back(p[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> nx = xs.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nx; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[xs[i]].size() == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nx; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m[xs[j]].size() == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                res = min(res, helper(m, xs[i], xs[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;m, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(begin(m[a]), end(m[a]))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> n = m[b].size();</span><br><span class="line">        <span class="keyword">int</span> diff = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!s.count(m[b][i])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; !s.count(m[b][j])) ++j;</span><br><span class="line">            <span class="keyword">if</span> (j == n) <span class="keyword">break</span>;</span><br><span class="line">            diff = min(diff, m[b][j] - m[b][i]);</span><br><span class="line">            i = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff == INT_MAX ? diff : (b - a) * diff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Geometry</tag>
      </tags>
  </entry>
  <entry>
    <title>958. Check Completeness of a Binary Tree</title>
    <url>/2021/01/11/958-Check-Completeness-of-a-Binary-Tree/</url>
    <content><![CDATA[<p>O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> n = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (!n) &#123; <span class="comment">// 完全二叉树必须后边所有的都是nullptr</span></span><br><span class="line">                <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> x = q.front(); q.pop();</span><br><span class="line">                    <span class="keyword">if</span> (x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q.push(n-&gt;left);</span><br><span class="line">            q.push(n-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Binary tree</tag>
        <tag>Level order traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>977. Squares of a Sorted Array</title>
    <url>/2021/01/11/977-Squares-of-a-Sorted-Array/</url>
    <content><![CDATA[<p>two pointer O(n) time O(1) space<br>跟<a href="https://leetcode.com/problems/sort-transformed-array/">360. Sort Transformed Array</a>不完全一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(A);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, i = n - <span class="number">1</span>; l &lt;= r; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(A[l]) &lt; <span class="built_in">abs</span>(A[r])) &#123;</span><br><span class="line">                res[i] = A[r] * A[r];</span><br><span class="line">                --r;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i] = A[l] * A[l];</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>; l &lt;= r;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(A[l]) &lt; <span class="built_in">abs</span>(A[r])) &#123;</span><br><span class="line">                res.push_back(A[r] * A[r]);</span><br><span class="line">                --r;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(A[l] * A[l]);</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(rbegin(res), rend(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>1329. Sort the Matrix Diagonally</title>
    <url>/2021/01/12/1329-Sort-the-Matrix-Diagonally/</url>
    <content><![CDATA[<p>heap O((m+n)max(m, n)log(max(m, n))) time O(mn) space<br>从右上到左下r - c的差递增，从左上往右下扫描，根据差值存入对应的heap，再扫描一遍取出来即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; diagonalSort(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.size(), n = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;&gt;&gt;&gt; hm;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c) &#123;</span><br><span class="line">                hm[r - c].push(mat[r][c]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c) &#123;</span><br><span class="line">                mat[r][c] = hm[r - c].top();</span><br><span class="line">                hm[r - c].pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O((m+n)max(m, n)log(max(m, n))) time O(max(m, n)) space<br>这个方法节省空间，但算边界比较麻烦，外层循环根据r - c的差值递增，内层循环根据r递增，d = r - c，因为0 &lt;= c = r - d &lt;= n - 1所以d &lt;= r &lt;= n - 1 + d并且0 &lt;= r &lt;= m - 1，所以max(d, 0) &lt;= r &lt;= min(m - 1, n - 1 + d)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; diagonalSort(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.size(), n = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span> - n; d &lt;= m - <span class="number">1</span>; ++d) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = max(d, <span class="number">0</span>); r &lt;= min(m - <span class="number">1</span>, n - <span class="number">1</span> + d); ++r) &#123;</span><br><span class="line">                v.push_back(mat[r][r - d]);</span><br><span class="line">            &#125;</span><br><span class="line">            sort(begin(v), end(v), greater());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = max(d, <span class="number">0</span>); r &lt;= min(m - <span class="number">1</span>, n - <span class="number">1</span> + d); ++r) &#123;</span><br><span class="line">                mat[r][r - d] = v.back();</span><br><span class="line">                v.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Heap</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>257. Binary Tree Paths</title>
    <url>/2021/01/12/257-Binary-Tree-Paths/</url>
    <content><![CDATA[<p>postorder</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">auto</span> val = to_string(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> &#123;val&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;str : binaryTreePaths(root-&gt;left)) &#123;</span><br><span class="line">            res.push_back(val + <span class="string">&quot;-&gt;&quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;str : binaryTreePaths(root-&gt;right)) &#123;</span><br><span class="line">            res.push_back(val + <span class="string">&quot;-&gt;&quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Postorder traversal</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>332. Reconstruct Itinerary</title>
    <url>/2021/01/12/332-Reconstruct-Itinerary/</url>
    <content><![CDATA[<p>基于dfs的类拓扑排序（不是真的拓扑排序） O(n) time O(n) space<br>后序遍历，当一个节点的所有子节点都被遍历过之后，将该节点加入，因为是倒序，所有最后要翻转过来，因为是类似拓扑排序，所以出度为0的末端点（最多一个）即便最先被访问也是第一个入栈，要排在最后<br>如果没有出度为0的点，前序遍历也是可以的，但是出度为0的点没有子节点所以必须最后访问，只有栈+后序遍历才能做到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findItinerary</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;e : tickets) &#123;</span><br><span class="line">            g[e[<span class="number">0</span>]].insert(e[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(rbegin(res), rend(res));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!g[u].empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = begin(g[u]);</span><br><span class="line">            <span class="keyword">auto</span> v = *it;</span><br><span class="line">            g[u].erase(it); <span class="comment">// 删除以避免重复访问</span></span><br><span class="line">            dfs(v);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt;&gt; g; <span class="comment">// 因为需要字典序所以要用set，因为一个起点可以多次去一个中点所以要用multiset</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Topological sort</tag>
      </tags>
  </entry>
  <entry>
    <title>408. Valid Word Abbreviation</title>
    <url>/2021/01/12/408-Valid-Word-Abbreviation/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validWordAbbreviation</span><span class="params">(<span class="built_in">string</span> word, <span class="built_in">string</span> abbr)</span> </span>&#123;</span><br><span class="line">        word += <span class="string">&quot; &quot;</span>, abbr += <span class="string">&quot; &quot;</span>; <span class="comment">// padding方便处理</span></span><br><span class="line">        <span class="keyword">int</span> m = word.length(), n = abbr.length(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; i &lt; m &amp;&amp; j &lt; n; i += s, ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(abbr[j])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (abbr[j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 以0开头的数是非法的</span></span><br><span class="line">                <span class="keyword">int</span> x = <span class="number">0</span>; <span class="comment">// 一次性把整个数取出来</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">isdigit</span>(abbr[j])) &#123;</span><br><span class="line">                    x = x * <span class="number">10</span> + abbr[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">                --j; <span class="comment">// 注意下标要回退一个</span></span><br><span class="line">                s = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (word[i] != abbr[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                s = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == m &amp;&amp; j == n; <span class="comment">// 最后判断是否两个指针同时达到结尾</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validWordAbbreviation</span><span class="params">(<span class="built_in">string</span> word, <span class="built_in">string</span> abbr)</span> </span>&#123;</span><br><span class="line">        word += <span class="string">&quot; &quot;</span>, abbr += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> m = word.length(), n = abbr.length(), s = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; m &amp;&amp; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(abbr[j])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="number">0</span> &amp;&amp; abbr[j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                s = s * <span class="number">10</span> + abbr[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i += s;</span><br><span class="line">                s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; m &amp;&amp; word[i] != abbr[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == m &amp;&amp; j == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>416. Partition Equal Subset Sum</title>
    <url>/2021/01/12/416-Partition-Equal-Subset-Sum/</url>
    <content><![CDATA[<p><a href="http://www.cnblogs.com/grandyang/p/5951422.html">solution</a><br>O(n)<br>bitset的第i位表示数i能不能通过若干个数组成，通过左移+或可以求出所有可能的和，左移相当于在利用之前所有数得到的所有可能的和的基础上再加上当前这个数，为了不丢失之前的结果还需要或上之前的所有可能的和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">bitset</span>&lt;10001&gt; <span class="title">sums</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 这里10001够了，因为累加和的一半不会超过10001</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sums |= (sums &lt;&lt; num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sums[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>knapsack O(n * sum/2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = accumulate(begin(nums), end(nums), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (s &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(s + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = s; t &gt;= x; --t) &#123;</span><br><span class="line">                f[t] = f[t] || f[t - x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[s];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>Knapsack</tag>
      </tags>
  </entry>
  <entry>
    <title>54. Spiral Matrix</title>
    <url>/2021/01/12/54-Spiral-Matrix/</url>
    <content><![CDATA[<p>O(mn) time O(mn) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> dr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dc[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, m = matrix.size(), n = matrix[<span class="number">0</span>].size(), sz = m * n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; v(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (sz-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(matrix[r][c]);</span><br><span class="line">            v[r][c] = <span class="literal">true</span>;</span><br><span class="line">            r += dr[i];</span><br><span class="line">            c += dc[i];</span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || v[r][c]) &#123;</span><br><span class="line">                r -= dr[i];</span><br><span class="line">                c -= dc[i];</span><br><span class="line">                i = (i + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                r += dr[i];</span><br><span class="line">                c += dc[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size(), sz = m * n;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(sz)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> dr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dc[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;; <span class="comment">// 按右下左上的顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, r = <span class="number">0</span>, c = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= r &amp;&amp; r &lt; m &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; n &amp;&amp; !visited[r * n + c]) &#123;</span><br><span class="line">                res.push_back(matrix[r][c]);</span><br><span class="line">                visited[r * n + c] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果越界</span></span><br><span class="line">                r -= dr[j]; <span class="comment">// 回退</span></span><br><span class="line">                c -= dc[j];</span><br><span class="line">                --i;</span><br><span class="line">                j = (j + <span class="number">1</span>) % <span class="number">4</span>; <span class="comment">// 换向</span></span><br><span class="line">            &#125;</span><br><span class="line">            r += dr[j]; <span class="comment">// 尝试前进一步</span></span><br><span class="line">            c += dc[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">D</span> &#123;</span>N, E, W, S&#125;;</span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> size = n * m;</span><br><span class="line">        D d = E;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, row = <span class="number">0</span>, col = <span class="number">0</span>, t = <span class="number">-1</span>, b = n, l = <span class="number">-1</span>, r = m; i &lt; size; ++i) &#123; <span class="comment">// 用tblr来标记当前的上下左右的bound</span></span><br><span class="line">            res.push_back(matrix[row][col]);</span><br><span class="line">            <span class="keyword">switch</span> (d) &#123;</span><br><span class="line">                <span class="keyword">case</span> N: <span class="keyword">if</span> (row + dy[d] == t) &#123; d = E; ++l; &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> E: <span class="keyword">if</span> (col + dx[d] == r) &#123; d = S; ++t; &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> W: <span class="keyword">if</span> (col + dx[d] == l) &#123; d = N; --b; &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> S: <span class="keyword">if</span> (row + dy[d] == b) &#123; d = W; --r; &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            row += dy[d];</span><br><span class="line">            col += dx[d];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>703. Kth Largest Element in a Stream</title>
    <url>/2021/01/12/703-Kth-Largest-Element-in-a-Stream/</url>
    <content><![CDATA[<p>minheap O(klogk) time O(k) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    KthLargest(<span class="keyword">int</span> k, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) : k(k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            q.push(x);</span><br><span class="line">            <span class="keyword">if</span> (q.size() &gt; k) &#123;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        q.push(val);</span><br><span class="line">        <span class="keyword">if</span> (q.size() &gt; k) &#123;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your KthLargest object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * KthLargest* obj = new KthLargest(k, nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;add(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>1053. Previous Permutation With One Swap</title>
    <url>/2021/01/13/1053-Previous-Permutation-With-One-Swap/</url>
    <content><![CDATA[<p>O(n) time<br>相当于找prev_permutation，要在右边找一个小数换左边的一个大数，右边的小数要在尾部的升序序列里找<br>312右侧升序，从后往前找到第一个违反升序的31，再在升序序列里找『第一个』比3小的最大的数，也就是先找3的下界再往前找第一次出现的最大的数跟3交换即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prevPermOpt1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(A), i = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; A[i - <span class="number">1</span>] &lt;= A[i]) --i;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> A;</span><br><span class="line">        <span class="keyword">int</span> j = lower_bound(begin(A) + i, end(A), A[i - <span class="number">1</span>]) - begin(A) - <span class="number">1</span>;</span><br><span class="line">        j = lower_bound(begin(A) + i, begin(A) + j + <span class="number">1</span>, A[j]) - begin(A);</span><br><span class="line">        swap(A[i - <span class="number">1</span>], A[j]);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prevPermOpt1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), x = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                x = i; <span class="comment">// 先从后往前找到第一个违反递减关系的数A[x]</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == n) <span class="keyword">return</span> A;</span><br><span class="line">        <span class="keyword">int</span> y = lower_bound(begin(A) + x + <span class="number">1</span>, end(A), A[x]) - begin(A) - <span class="number">1</span>; <span class="comment">// 从后往前二分找到第一个小于A[x]的数A[y]</span></span><br><span class="line">        y = lower_bound(begin(A) + x + <span class="number">1</span>, begin(A) + y + <span class="number">1</span>, A[y]) - begin(A); <span class="comment">// 再找到第一个A[y]跟A[x]交换</span></span><br><span class="line">        swap(A[x], A[y]);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prevPermOpt1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), x = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                x = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == n) <span class="keyword">return</span> A;</span><br><span class="line">        <span class="keyword">auto</span> y = lower_bound(begin(A) + x + <span class="number">1</span>, end(A), A[x]) - begin(A) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; y &amp;&amp; A[y - <span class="number">1</span>] == A[y]) &#123;</span><br><span class="line">            --y;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(A[x], A[y]);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Permutation</tag>
      </tags>
  </entry>
  <entry>
    <title>286. Walls and Gates</title>
    <url>/2021/01/13/286-Walls-and-Gates/</url>
    <content><![CDATA[<p>bfs O(mn) time O(mn) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rooms.empty() || rooms[<span class="number">0</span>].empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = rooms.size(), n = rooms[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rooms[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.emplace(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dr[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dc[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> rr = r + dr[j], cc = c + dc[j];</span><br><span class="line">                <span class="keyword">if</span> (rr &lt; <span class="number">0</span> || rr &gt;= m || cc &lt; <span class="number">0</span> || cc &gt;= n || rooms[rr][cc] != INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">                q.emplace(rr, cc);</span><br><span class="line">                rooms[rr][cc] = rooms[r][c] + <span class="number">1</span>; <span class="comment">// 提前修改可以避免后期处理的麻烦</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rooms.empty() || rooms[<span class="number">0</span>].empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = rooms.size(), n = rooms[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rooms[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.emplace(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dr[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dc[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dist = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [r, c] = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> rr = r + dr[j], cc = c + dc[j];</span><br><span class="line">                    <span class="keyword">if</span> (rr &lt; <span class="number">0</span> || rr &gt;= m || cc &lt; <span class="number">0</span> || cc &gt;= n || rooms[rr][cc] != INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">                    q.emplace(rr, cc);</span><br><span class="line">                    rooms[rr][cc] = dist; <span class="comment">// 一定要提前修改</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++dist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title>288. Unique Word Abbreviation</title>
    <url>/2021/01/13/288-Unique-Word-Abbreviation/</url>
    <content><![CDATA[<p>O(n) time O(n) space<br>纯粹考对题目理解和corner case想的全不全<br>题目isunique的定义：</p>
<ol>
<li>词典里没有这个词的缩写</li>
<li>词典里有这个词的缩写，原词都是这个词（意味着词典里如果有缩写相同的词，则必须相同且只能是这个词，即不能有歧义，同一个缩写只能对应唯一的词）</li>
</ol>
<p>需要考虑的corner case：</p>
<ol>
<li>词典里有重复词</li>
<li>词典里有缩写一样的不同词</li>
</ol>
<p>为了节省空间，用一个hashmap，key是缩写，value存该缩写的唯一的这个词，如果词典里有重复词则跳过，如果词典里有缩写一样的不同词则把value置空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidWordAbbr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ValidWordAbbr(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; dictionary) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : dictionary) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;a = norm(w);</span><br><span class="line">            <span class="keyword">if</span> (m.count(a) == <span class="number">0</span>) &#123; <span class="comment">// 如果不存在这个词的缩写</span></span><br><span class="line">                m[a] = w;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!m[a].empty() &amp;&amp; m[a] != w) &#123; <span class="comment">// 如果词典里有缩写一样的不同词</span></span><br><span class="line">                m[a].clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUnique</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> a = norm(word);</span><br><span class="line">        <span class="keyword">return</span> m.count(a) == <span class="number">0</span> || m[a] == word; <span class="comment">// 如果找不到该词的缩写或者能找到该词的缩写且是同一个词的缩写，则是unique的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">norm</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (w.length() &lt; <span class="number">3</span>) <span class="keyword">return</span> w;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(<span class="number">1</span>, w[<span class="number">0</span>])</span></span>;</span><br><span class="line">        res += to_string(w.length() - <span class="number">2</span>);</span><br><span class="line">        res += w.back();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ValidWordAbbr object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ValidWordAbbr* obj = new ValidWordAbbr(dictionary);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;isUnique(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>325. Maximum Size Subarray Sum Equals k</title>
    <url>/2021/01/13/325-Maximum-Size-Subarray-Sum-Equals-k/</url>
    <content><![CDATA[<p>O(n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArrayLen</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m&#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;; <span class="comment">// 注意要初始化0的下标为-1</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">int</span> t = sum - k;</span><br><span class="line">            <span class="keyword">if</span> (m.count(t)) &#123;</span><br><span class="line">                res = max(res, i - m[t]);</span><br><span class="line">            &#125;</span><br><span class="line">            m[sum] = m.count(sum) ? m[sum] : i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArrayLen</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">presum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            presum[i] = presum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">            m[presum[i]] = max(m[presum[i]], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = presum[i] + k;</span><br><span class="line">            <span class="keyword">if</span> (m.count(t)) &#123;</span><br><span class="line">                res = max(res, m[t] - i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
        <tag>Prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>567. Permutation in String</title>
    <url>/2021/01/13/567-Permutation-in-String/</url>
    <content><![CDATA[<p>sliding window O(n) time O(1) space<br>维护定长sliding window和一个cnt，cnt表示当前sliding window内符合要求的字符的个数，只有当cnt为m即sliding window的长度时，说明所有字符都是符合要求的，则找到了一个permutation</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = size(s1), n = size(s2);</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s1) &#123;</span><br><span class="line">            ++f[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--f[s2[i] - <span class="string">&#x27;a&#x27;</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= m &amp;&amp; ++f[s2[i - m] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                --cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt == m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = size(s1), n = size(s2);</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s1) &#123;</span><br><span class="line">            ++f[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cnt = m, i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--f[s2[i] - <span class="string">&#x27;a&#x27;</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                --cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= m &amp;&amp; ++f[s2[i - m] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>朴素解法即可，维护两个map，每次移动窗口得到一个新map检查是不是一样<br>跟<a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">438. Find All Anagrams in a String</a>几乎一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">m1</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s1) &#123;</span><br><span class="line">            ++m1[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">m2</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ++m2[s2[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= m - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m1 == m2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                --m2[s2[i - m + <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">m1</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s1) &#123;</span><br><span class="line">            ++m1[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">m2</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= m) &#123;</span><br><span class="line">                --m2[s2[i - m] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            ++m2[s2[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (m1 == m2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m1[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;, m2[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s1) &#123;</span><br><span class="line">            ++m1[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        s2 += <span class="string">&quot;a&quot;</span>; <span class="comment">// padding简化代码</span></span><br><span class="line">        <span class="keyword">int</span> n1 = s1.length(), n2 = s2.length();</span><br><span class="line">        <span class="keyword">if</span> (n1 &gt; n2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n2; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= n1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isSame(m1, m2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                --m2[s2[i - n1] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            ++m2[s2[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> lhs[], <span class="keyword">int</span> rhs[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lhs[i] != rhs[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">m1</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s1) &#123;</span><br><span class="line">            ++m1[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">m2</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        s2 += <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m1 == m2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                --m2[s2[i - m] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            ++m2[s2[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>962. Maximum Width Ramp</title>
    <url>/2021/01/13/962-Maximum-Width-Ramp/</url>
    <content><![CDATA[<p>O(n) time O(n) space<br>小数在左边，大数在右边，对于右边每一个大数，尽可能找到左边第一个比大数小的数，所以在左边维护一个递减栈，所有可能的小数一定在这个栈里<br>greedy从后往前遍历每个数，对于每个数要找到从左边开始第一个不大于它的数，保存每个数字第一次出现的位置，而且依次只用保留最小的即可，比如[6, 0, 3]，只需要保存6和0即可，3在0的右边且大于0，则3永远不可能成为最优解，所以可以直接跳过</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxWidthRamp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty() || A[s.top()] &gt;= A[i]) &#123;</span><br><span class="line">                s.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; res; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; A[s.top()] &lt;= A[i]) &#123;</span><br><span class="line">                res = max(res, i - s.top());</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(nlogn) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxWidthRamp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">        iota(begin(v), end(v), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;A](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;<span class="keyword">return</span> A[i] &lt; A[j] || A[i] == A[j] &amp;&amp; i &lt; j;&#125;;</span><br><span class="line">        sort(begin(v), end(v), cmp);</span><br><span class="line">        <span class="keyword">int</span> mn = INT_MAX, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : v) &#123;</span><br><span class="line">            mn = min(mn, i);</span><br><span class="line">            res = max(res, i - mn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxWidthRamp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;A](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;<span class="keyword">return</span> A[i] &lt; A[j] || A[i] == A[j] &amp;&amp; i &lt; j;&#125;;</span><br><span class="line">        set&lt;int, decltype(cmp)&gt; s(cmp);</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            s.insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mn = INT_MAX, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : s) &#123;</span><br><span class="line">            mn = min(mn, i);</span><br><span class="line">            res = max(res, i - mn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>742. Closest Leaf in a Binary Tree</title>
    <url>/2021/01/13/742-Closest-Leaf-in-a-Binary-Tree/</url>
    <content><![CDATA[<p>O(n) time O(n) space<br>跟<a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/">863. All Nodes Distance K in Binary Tree</a>类似<br>把树转成图再bfs找最近端点，如果只有k一个点，则图为空，返回k，如果k只有一个邻居且k不是根，则k一定是叶子，返回k，如果图中某个『最近』端点不是根，返回该点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findClosestLeaf</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">        createGraph(root, g);</span><br><span class="line">        <span class="keyword">if</span> (g.empty() || g[k].size() == <span class="number">1</span> &amp;&amp; root-&gt;val != k) <span class="keyword">return</span> k; <span class="comment">// 如果k自己是leaf那就是他自己</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(k);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (g[p].empty() &amp;&amp; root-&gt;val != p) <span class="keyword">return</span> p; <span class="comment">// 没有邻居说明之前邻居已经把它从我的邻居里删除，我是根或者叶，如果我不是根，则返回我</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> n : g[p]) &#123;</span><br><span class="line">                q.push(n);</span><br><span class="line">                g[n].erase(p); <span class="comment">// 从邻居那移除我，防止邻居继续访问我</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(TreeNode *root, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            g[root-&gt;val].insert(root-&gt;left-&gt;val);</span><br><span class="line">            g[root-&gt;left-&gt;val].insert(root-&gt;val);</span><br><span class="line">            createGraph(root-&gt;left, g);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            g[root-&gt;val].insert(root-&gt;right-&gt;val);</span><br><span class="line">            g[root-&gt;right-&gt;val].insert(root-&gt;val);</span><br><span class="line">            createGraph(root-&gt;right, g);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>WA!</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findClosestLeaf</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k2root = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">auto</span> K = searchK(root, k, <span class="number">0</span>, k2root);</span><br><span class="line">        <span class="keyword">int</span> other2root = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">auto</span> other = searchOther(root, k, other2root);</span><br><span class="line">        <span class="keyword">int</span> child2k = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">auto</span> child = searchKTree(K, child2k);</span><br><span class="line">        <span class="keyword">return</span> k2root + other2root &lt; child2k ? other-&gt;val : child-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">searchK</span><span class="params">(TreeNode *root, <span class="keyword">int</span> k, <span class="keyword">int</span> lvl, <span class="keyword">int</span> &amp;k2root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == k) &#123;</span><br><span class="line">            k2root = lvl;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> l = searchK(root-&gt;left, k, lvl + <span class="number">1</span>, k2root);</span><br><span class="line">        <span class="keyword">if</span> (l &amp;&amp; l-&gt;val == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> r = searchK(root-&gt;right, k, lvl + <span class="number">1</span>, k2root);</span><br><span class="line">        <span class="keyword">if</span> (r &amp;&amp; r-&gt;val == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">searchKTree</span><span class="params">(TreeNode *K, <span class="keyword">int</span> &amp;child2k)</span> </span>&#123;</span><br><span class="line">        TreeNode *res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;TreeNode *, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.emplace(K, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty() &amp;&amp; child2k == <span class="number">10000</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> curr = q.front().first;</span><br><span class="line">            <span class="keyword">int</span> lvl = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (!curr-&gt;left &amp;&amp; !curr-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lvl &lt; child2k) &#123;</span><br><span class="line">                    child2k = lvl;</span><br><span class="line">                    res = curr;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!curr-&gt;left) &#123;</span><br><span class="line">                q.emplace(curr-&gt;right, lvl + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!curr-&gt;right) &#123;</span><br><span class="line">                q.emplace(curr-&gt;left, lvl + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                q.emplace(curr-&gt;left, lvl + <span class="number">1</span>);</span><br><span class="line">                q.emplace(curr-&gt;right, lvl + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">searchOther</span><span class="params">(TreeNode *root, <span class="keyword">int</span> k, <span class="keyword">int</span> &amp;other2root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;TreeNode *, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.emplace(root, <span class="number">0</span>);</span><br><span class="line">        TreeNode *res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty() &amp;&amp; other2root == <span class="number">10000</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> curr = q.front().first;</span><br><span class="line">            <span class="keyword">int</span> lvl = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;val == k) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!curr-&gt;left &amp;&amp; !curr-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lvl &lt; other2root) &#123;</span><br><span class="line">                    other2root = lvl;</span><br><span class="line">                    res = curr;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!curr-&gt;left) &#123;</span><br><span class="line">                q.emplace(curr-&gt;right, lvl + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!curr-&gt;right) &#123;</span><br><span class="line">                q.emplace(curr-&gt;left, lvl + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                q.emplace(curr-&gt;left, lvl + <span class="number">1</span>);</span><br><span class="line">                q.emplace(curr-&gt;right, lvl + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Depth first search</tag>
        <tag>Graph</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>1055. Shortest Way to Form String</title>
    <url>/2021/01/14/1055-Shortest-Way-to-Form-String/</url>
    <content><![CDATA[<p>greedy O(m+n) time<br>f[i][c]表示在source中从下标i开始第一次出现的字母c在source中的下标，这样做可以跳过中间不符合要求的那些字母方便快速查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestWay</span><span class="params">(<span class="built_in">string</span> source, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = source.length(), n = target.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">26</span>, <span class="number">-1</span>));</span><br><span class="line">        f[m - <span class="number">1</span>][source[m - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>] = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            f[i] = f[i + <span class="number">1</span>]; <span class="comment">// 先copy后一个index的内容</span></span><br><span class="line">            f[i][source[i] - <span class="string">&#x27;a&#x27;</span>] = i; <span class="comment">// 再修改当前index所对应的字符的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>, i = <span class="number">0</span>; <span class="comment">// res要从1开始因为target最后一个字符结束以后没法更新res</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[<span class="number">0</span>][c - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果source所有字符里都不包含c</span></span><br><span class="line">            <span class="keyword">if</span> (i == m || f[i][c - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>) &#123; <span class="comment">// 如果source所有字符都比对完或者尚未比对完但是source当前位置之后没有c（之前可能有）则重置指针并更新res</span></span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">            i = f[i][c - <span class="string">&#x27;a&#x27;</span>] + <span class="number">1</span>; <span class="comment">// 移动指针到下一个可能的位置（跳过中间不符合要求的字符）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>greedy O(m*n) time<br>worst case比如[“abcd”, “ddddd”]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestWay</span><span class="params">(<span class="built_in">string</span> source, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = size(source), n = size(target);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n &amp;&amp; source[j] == target[i]) &#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == t) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestWay</span><span class="params">(<span class="built_in">string</span> source, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = source.length(), n = target.length();</span><br><span class="line">        <span class="keyword">bool</span> f[<span class="number">26</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : source) &#123;</span><br><span class="line">            f[c - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; ++i, ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!f[target[i] - <span class="string">&#x27;a&#x27;</span>]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; m &amp;&amp; source[j] != target[i]) ++j;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                j = <span class="number">-1</span>;</span><br><span class="line">                --i;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp O(m*m+(n-m)*n) time<br>f[i]表示target前i个字符需要几个source的子序列才能构成</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestWay</span><span class="params">(<span class="built_in">string</span> source, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = source.length(), n = target.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; source[k] != target[j]) --k;</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (f[i] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i] = min(f[i], f[j] + <span class="number">1</span>);<span class="comment">//cout&lt;&lt;&quot;f[&quot;&lt;&lt;i&lt;&lt;&quot;] = &quot;&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class="line">                    --k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>152. Maximum Product Subarray</title>
    <url>/2021/01/14/152-Maximum-Product-Subarray/</url>
    <content><![CDATA[<p>dp O(n) time O(1) space<br>看到这道题首先应该想到<a href="https://leetcode.com/problems/maximum-subarray/">53. Maximum Subarray</a>所以是dp<br>难点在于乘积受负数影响，只找最大乘积是行不通的，比较tricky的地方是要维护最大乘积和最小乘积，然后分情况对正负数进行讨论，讨论的思路和求最大和一致<br>mn和mx分别表示以x为结尾的连续子数组的最小和最大值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> mn = <span class="number">1</span>, mx = <span class="number">1</span>, res = LONG_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t = mn;</span><br><span class="line">                mn = min(x, mx * x);</span><br><span class="line">                mx = max(x, t * x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mn = min(x, mn * x);</span><br><span class="line">                mx = max(x, mx * x);</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, mx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>494. Target Sum</title>
    <url>/2021/01/14/494-Target-Sum/</url>
    <content><![CDATA[<p>O(n*target)<br>把问题转换成真正的类背包问题<br>原来是每个数+或者-，现在每个数都乘2，这样就变成0个或者1个，也就是加这个数或者不加这个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; S) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 所有数都加起来都到不了S，直接返回0</span></span><br><span class="line">        for_each(nums.begin(), nums.end(), [](<span class="keyword">int</span> &amp;num)&#123;num &lt;&lt;= <span class="number">1</span>;&#125;);</span><br><span class="line">        <span class="keyword">long</span> target = sum + S; <span class="comment">// 背包的目标值也要调整</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(target + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.size() + <span class="number">1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= target; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; f[i].size(); ++j) &#123;</span><br><span class="line">                f[i][j] = f[i][j - <span class="number">1</span>] + (i &gt;= nums[j - <span class="number">1</span>] ? f[i - nums[j - <span class="number">1</span>]][j - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f.back().back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; S) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        for_each(nums.begin(), nums.end(), [](<span class="keyword">int</span> &amp;num)&#123;num &lt;&lt;= <span class="number">1</span>;&#125;);</span><br><span class="line">        <span class="keyword">int</span> target = sum + S, n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(target + <span class="number">1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= target; ++j) &#123;</span><br><span class="line">            <span class="comment">// for (int j = target; j &gt;= 0; --j) &#123;</span></span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j] + (j &gt;= nums[i - <span class="number">1</span>] ? f[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]] : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为转换后的背包问题要求原来的所有数都要double，则新的target = sum + S也必须是个偶数，这样其实不需要修改nums，只需要把新的target除2即可，前提是target必须是偶数</p>
<ol>
<li>原来的每个数放-1个或者1个转换成放0个或者2个</li>
<li>目标值从S变成sum + S，因为相当于在原来的每种可能基础上加了一个sum</li>
<li>这样相当于每个数都double了，进而变成标准0-1背包问题，即放这个数（原来的2倍）或者不放这个数</li>
<li>又因为原来的每个数要不是0个要不是2个，所以最后的目标值必须是偶数，所以可以不需要手动double每个数，仍然可以使用原来的数，只是目标值改成(sum + S) / 2</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">long</span> target = sum + S, n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; S || target &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果target不是偶数则得不到结果</span></span><br><span class="line">        target &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = target; t &gt;= x; --t) &#123; <span class="comment">// 注意一维0-1背包一定要倒序</span></span><br><span class="line">                f[t] += f[t - x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> target = sum + S, n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; S || target &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        target &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> f[target + <span class="number">1</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= nums[i - <span class="number">1</span>]; --j) &#123; <span class="comment">// 注意一维0-1背包一定要倒序</span></span><br><span class="line">                f[j] += f[j - nums[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; S) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        for_each(nums.begin(), nums.end(), [](<span class="keyword">int</span> &amp;num)&#123;num &lt;&lt;= <span class="number">1</span>;&#125;);</span><br><span class="line">        <span class="keyword">int</span> target = sum + S, n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= nums[i - <span class="number">1</span>]; --j) &#123;</span><br><span class="line">                f[j] += f[j - nums[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp 不转换成背包直接建模，需要用到hashmap</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>);</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;[t, cnt] : f[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                f[i][t + nums[i - <span class="number">1</span>]] += cnt;</span><br><span class="line">                f[i][t - nums[i - <span class="number">1</span>]] += cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][S];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; g;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;[t, cnt] : f) &#123;</span><br><span class="line">                g[t + nums[i - <span class="number">1</span>]] += cnt;</span><br><span class="line">                g[t - nums[i - <span class="number">1</span>]] += cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            f = g;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[S];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>Knapsack</tag>
      </tags>
  </entry>
  <entry>
    <title>153. Find Minimum in Rotated Sorted Array</title>
    <url>/2021/01/14/153-Find-Minimum-in-Rotated-Sorted-Array/</url>
    <content><![CDATA[<p>二分O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &gt; nums[r]) &#123; <span class="comment">// compare m with r rather than l because m could be l but never be r (in that case, m == r == l, impossible)</span></span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>399. Evaluate Division</title>
    <url>/2021/01/14/399-Evaluate-Division/</url>
    <content><![CDATA[<p>bfs O(n) 有向图连通性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">calcEquation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); ++i) &#123;</span><br><span class="line">            g[equations[i][<span class="number">0</span>]][equations[i][<span class="number">1</span>]] = values[i];</span><br><span class="line">            g[equations[i][<span class="number">1</span>]][equations[i][<span class="number">0</span>]] = <span class="number">1</span> / values[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; query : queries) &#123;</span><br><span class="line">            ret.emplace_back(helper(query[<span class="number">0</span>], query[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;begin, <span class="keyword">const</span> <span class="built_in">string</span> &amp;end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (g.count(begin) == <span class="number">0</span> || g.count(end) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.count(begin) &amp;&amp; g[begin].count(end)) <span class="keyword">return</span> g[begin][end]; <span class="comment">// 假如cache里有则直接返回</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; s; <span class="comment">// 避免重复访问</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt; q&#123;&#123;&#123;begin, <span class="number">1.0</span>&#125;&#125;&#125;; <span class="comment">// key是点value是从begin到这个点的累乘结果，也就是begin / key的结果</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [u, product] = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (s.count(u)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[u].count(end)) <span class="keyword">return</span> product * g[u][end];</span><br><span class="line">            s.emplace(u);</span><br><span class="line">            g[begin][u] = product; <span class="comment">// cache中间结果</span></span><br><span class="line">            g[u][begin] = <span class="number">1</span> / product;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [v, quotient] : g[u]) &#123;</span><br><span class="line">                q.emplace(v, product * quotient);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt; g; <span class="comment">// 这道题需要用邻接矩阵</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>698. Partition to K Equal Sum Subsets</title>
    <url>/2021/01/14/698-Partition-to-K-Equal-Sum-Subsets/</url>
    <content><![CDATA[<p>backtracking time O(2<sup>n</sup>) space O(n)<br>每次递归的深度是O(n)<br>先找到target，然后对数组从大到小排序，用回溯试数即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum / k;</span><br><span class="line">        sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; target) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 这行必须要有！全靠后边handle速度太慢！</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(target, nums, v, k, target); <span class="comment">// 从target往下减</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;v, <span class="keyword">int</span> k, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到了k组</span></span><br><span class="line">        <span class="comment">// if (s &lt; 0) return false; // 不合要求</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">0</span>) <span class="keyword">return</span> dfs(target, A, v, k - <span class="number">1</span>, target); <span class="comment">// 找到一组可能的，尝试找下一组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i] || A[i] &gt; s) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// if (A[i] &gt; s) return false; // 这行能加速？！匪夷所思</span></span><br><span class="line">            v[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (dfs(s - A[i], A, v, k, target)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            v[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最快版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum / k;</span><br><span class="line">        sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(target, nums, <span class="number">0</span>, v, k, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;v, <span class="keyword">int</span> k, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (s &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">0</span>) <span class="keyword">return</span> dfs(target, A, <span class="number">0</span>, v, k - <span class="number">1</span>, target); <span class="comment">// 注意是从0开始，因为找到一组并不意味着前边的都放到某个组里了，只能从头再找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; A.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i]) <span class="keyword">continue</span>;</span><br><span class="line">            v[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (dfs(s - A[i], A, i + <span class="number">1</span>, v, k, target)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            v[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum / k;</span><br><span class="line">        sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">// int i = 0; // 跳过那些自成一组的</span></span><br><span class="line">        <span class="comment">// for (; i &lt; n &amp;&amp; nums[i] == target; ++i) &#123;</span></span><br><span class="line">        <span class="comment">//     v[i] = true;</span></span><br><span class="line">        <span class="comment">//     --k;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, nums, v, k, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;v, <span class="keyword">int</span> k, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == target) &#123;</span><br><span class="line">            s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i] || s + A[i] &gt; target) <span class="keyword">continue</span>;</span><br><span class="line">            v[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (dfs(s + A[i], A, v, k, target)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            v[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>状态压缩dp O(n*2<sup>n</sup>) time O(2<sup>n</sup>) space<br>f[state]表示该state所指的这些数可以凑成多个和为target的partition外加一个和小于等于target的一部分，target是sum/k<br>s[state]为对应state所指的这些数构成的和<br>f[0] = true<br>对于每个state从小到大尝试加数看能不能凑成新的和为target的partition，即使不能凑成，能缩小gap也行，因为已知总和一定能被k和target整除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum / k;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (nums[n - <span class="number">1</span>] &gt; target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">f</span><span class="params">(<span class="number">1</span> &lt;&lt; n)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">0</span>; state &lt; (<span class="number">1</span> &lt;&lt; n); ++state) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!f[state]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> next = state | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                <span class="keyword">if</span> (next != state &amp;&amp; !f[next]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] &lt;= target - s[state] % target) &#123;</span><br><span class="line">                        f[next] = <span class="literal">true</span>;</span><br><span class="line">                        s[next] = s[state] + nums[i];</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>773. Sliding Puzzle</title>
    <url>/2021/01/14/773-Sliding-Puzzle/</url>
    <content><![CDATA[<p>bfs O(r*c*(r*c)!) time O(r*c*(r*c)!) space<br>这道题也可以用A*算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">slidingPuzzle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">string</span> target = <span class="string">&quot;123450&quot;</span>, start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;v : board) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : v) &#123;</span><br><span class="line">                start += <span class="string">&#x27;0&#x27;</span> + c; <span class="comment">// 得到初始状态的board</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; next&#123;&#123;<span class="number">1</span>,<span class="number">3</span>&#125;, &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>&#125;, &#123;<span class="number">1</span>,<span class="number">5</span>&#125;, &#123;<span class="number">0</span>,<span class="number">4</span>&#125;, &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;, &#123;<span class="number">2</span>,<span class="number">4</span>&#125;&#125;; <span class="comment">// 当0在每个位置时的下一步能去哪</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited&#123;start&#125;; <span class="comment">// 用字符串来保存状态</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q&#123;&#123;start&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (cur == target) <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">int</span> zero_idx = cur.find(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> v : next[zero_idx]) &#123; <span class="comment">// 查表来枚举所有可能产生的下个board状态</span></span><br><span class="line">                    swap(cur[v], cur[zero_idx]);</span><br><span class="line">                    <span class="keyword">if</span> (!visited.count(cur)) &#123;</span><br><span class="line">                        visited.insert(cur);</span><br><span class="line">                        q.push(cur);</span><br><span class="line">                    &#125;</span><br><span class="line">                    swap(cur[v], cur[zero_idx]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">slidingPuzzle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">string</span> target = <span class="string">&quot;123450&quot;</span>, start;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; next&#123;&#123;<span class="number">1</span>,<span class="number">3</span>&#125;, &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>&#125;, &#123;<span class="number">1</span>,<span class="number">5</span>&#125;, &#123;<span class="number">0</span>,<span class="number">4</span>&#125;, &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;, &#123;<span class="number">2</span>,<span class="number">4</span>&#125;&#125;; <span class="comment">// 当0在每个位置时的下一步能去哪</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                start += <span class="string">&#x27;0&#x27;</span> + board[i][j]; <span class="comment">// 得到初始状态的board</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited&#123;start&#125;; <span class="comment">// 用字符串来保存状态</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q&#123;&#123;start&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="built_in">string</span> cur = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (cur == target) <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">int</span> zero_idx = cur.find(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> v : next[zero_idx]) &#123; <span class="comment">// 查表来枚举所有可能产生的下个board状态</span></span><br><span class="line">                    <span class="built_in">string</span> cand = cur;</span><br><span class="line">                    swap(cand[v], cand[zero_idx]);</span><br><span class="line">                    <span class="keyword">if</span> (visited.count(cand)) <span class="keyword">continue</span>;</span><br><span class="line">                    visited.insert(cand);</span><br><span class="line">                    q.push(cand);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">slidingPuzzle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> hash = [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;b) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;v : b) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x : v) &#123;</span><br><span class="line">                    res = res * <span class="number">10</span> + x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(hash)&gt; m(<span class="number">33</span>, hash); <span class="comment">// 必须要提供初始桶的个数！！</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; q;</span><br><span class="line">        q.push(board);</span><br><span class="line">        <span class="keyword">int</span> dr[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dc[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> b = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (hash(b) == <span class="number">123450</span>) <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">if</span> (m.count(b)) <span class="keyword">continue</span>;</span><br><span class="line">                m.insert(b);</span><br><span class="line">                <span class="keyword">auto</span> v = find(b);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> t = v;</span><br><span class="line">                    t[<span class="number">0</span>] += dr[j];</span><br><span class="line">                    t[<span class="number">1</span>] += dc[j];</span><br><span class="line">                    <span class="keyword">if</span> (t[<span class="number">0</span>] &lt; <span class="number">0</span> || t[<span class="number">0</span>] &gt; <span class="number">1</span> || t[<span class="number">1</span>] &lt; <span class="number">0</span> || t[<span class="number">1</span>] &gt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    swap(b[v[<span class="number">0</span>]][v[<span class="number">1</span>]], b[t[<span class="number">0</span>]][t[<span class="number">1</span>]]);</span><br><span class="line">                    q.push(b);</span><br><span class="line">                    swap(b[v[<span class="number">0</span>]][v[<span class="number">1</span>]], b[t[<span class="number">0</span>]][t[<span class="number">1</span>]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">2</span>; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b[r][c] == <span class="number">0</span>) <span class="keyword">return</span> &#123;r, c&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>128. Longest Consecutive Sequence</title>
    <url>/2021/01/15/128-Longest-Consecutive-Sequence/</url>
    <content><![CDATA[<p>hashtable版本 O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(begin(nums), end(nums))</span></span>; <span class="comment">// 把所有数放到hashtable里</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.count(x - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (s.count(x)) &#123; <span class="comment">// 从nums[i]开始找递增连续数列</span></span><br><span class="line">                s.erase(x); <span class="comment">// 每找到一个数就删除</span></span><br><span class="line">                ++len;</span><br><span class="line">                ++x;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(nums.begin(), nums.end())</span></span>; <span class="comment">// 把所有数放到hashtable里</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; !s.empty(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = nums[i];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (s.count(curr)) &#123; <span class="comment">// 从nums[i]开始找递增连续数列</span></span><br><span class="line">                s.erase(curr);</span><br><span class="line">                ++len;</span><br><span class="line">                ++curr;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = nums[i] - <span class="number">1</span>; <span class="comment">// 从nums[i] - 1开始找递减连续数列</span></span><br><span class="line">            <span class="keyword">while</span> (s.count(curr)) &#123;</span><br><span class="line">                s.erase(curr);</span><br><span class="line">                ++len;</span><br><span class="line">                --curr;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>union-find O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        UF uf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uf.has(n)) <span class="keyword">continue</span>;</span><br><span class="line">            uf.add(n);</span><br><span class="line">            <span class="keyword">if</span> (uf.has(n - <span class="number">1</span>)) &#123;</span><br><span class="line">                uf.merge(n - <span class="number">1</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (uf.has(n + <span class="number">1</span>)) &#123;</span><br><span class="line">                uf.merge(n + <span class="number">1</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.mx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UF</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            parent[x] = x;</span><br><span class="line">            size[x] = <span class="number">1</span>;</span><br><span class="line">            mx = max(mx, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">has</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> parent.find(x) != parent.end();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getParent</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (parent[x] != parent[parent[x]]) &#123;</span><br><span class="line">                x = parent[x] = parent[parent[x]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> px = getParent(x);</span><br><span class="line">            <span class="keyword">int</span> py = getParent(y);</span><br><span class="line">            <span class="keyword">if</span> (px != py) &#123;</span><br><span class="line">                parent[px] = py;</span><br><span class="line">                <span class="keyword">int</span> sz = size[px] + size[py];</span><br><span class="line">                size[px] = size[py] = sz;</span><br><span class="line">                mx = max(mx, sz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; parent, size;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
        <tag>Implementation</tag>
        <tag>Union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>1305. All Elements in Two Binary Search Trees</title>
    <url>/2021/01/15/1305-All-Elements-in-Two-Binary-Search-Trees/</url>
    <content><![CDATA[<p><a href="https://leetcode.com/problems/binary-search-tree-iterator/">173. Binary Search Tree Iterator</a> O(n) time O(h) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getAllElements</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        pushAllLeft(root1, s1);</span><br><span class="line">        pushAllLeft(root2, s2);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!s1.empty() || !s2.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = s1.empty() ? <span class="literal">nullptr</span> : s1.top();</span><br><span class="line">            <span class="keyword">auto</span> q = s2.empty() ? <span class="literal">nullptr</span> : s2.top();</span><br><span class="line">            <span class="keyword">if</span> (p &amp;&amp; q) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;val &lt;= q-&gt;val) &#123;</span><br><span class="line">                    res.push_back(p-&gt;val);</span><br><span class="line">                    pushAllLeft(p-&gt;right, s1);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.push_back(q-&gt;val);</span><br><span class="line">                    pushAllLeft(q-&gt;right, s2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                res.push_back(p-&gt;val);</span><br><span class="line">                pushAllLeft(p-&gt;right, s1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(q-&gt;val);</span><br><span class="line">                pushAllLeft(q-&gt;right, s2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushAllLeft</span><span class="params">(TreeNode *p, <span class="built_in">stack</span>&lt;TreeNode *&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.empty()) &#123; <span class="comment">// 注意判空，因为一开始push的时候是空的</span></span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s1, s2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Merging</tag>
        <tag>Binary search tree</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>300. Longest Increasing Subsequence</title>
    <url>/2021/01/15/300-Longest-Increasing-Subsequence/</url>
    <content><![CDATA[<p>dp O(nlogn) dp[i]是 长度为i+1的递增子序列的 能找到的最小的第i大（最大）元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(dp.begin(), dp.end(), nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it == dp.end()) &#123;</span><br><span class="line">                dp.push_back(nums[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *it = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(f.begin(), f.end(), x);</span><br><span class="line">            <span class="keyword">if</span> (it == f.end()) &#123;</span><br><span class="line">                f.push_back(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *it = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp O(n<sup>2</sup>) dp[i]是LIS必须以nums[i]结尾的LIS的长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>51. N-Queens</title>
    <url>/2021/01/15/51-N-Queens/</url>
    <content><![CDATA[<p>backtracking O(n!) time O(n) space<br>There is N possibilities to put the first queen, not more than N * (N - 2) to put the second one, not more than N * (N - 2) * (N - 4) for the third one etc. In total that results in O(n!) time complexity.<br>按row去dfs，只需统计col以及两个方向的斜边即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        chessboard.resize(n, <span class="built_in">string</span>(n, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">        only_col.resize(n);</span><br><span class="line">        row_minus_col.resize((n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">        row_plus_col.resize((n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r == n) &#123;</span><br><span class="line">            res.push_back(chessboard);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!only_col[c]</span><br><span class="line">                &amp;&amp; !row_minus_col[n - <span class="number">1</span> + r - c]</span><br><span class="line">                &amp;&amp; !row_plus_col[r + c]) &#123;</span><br><span class="line">                only_col[c] = row_minus_col[n - <span class="number">1</span> + r - c] = row_plus_col[r + c] = <span class="literal">true</span>;</span><br><span class="line">                chessboard[r][c] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                dfs(r + <span class="number">1</span>);</span><br><span class="line">                chessboard[r][c] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                only_col[c] = row_minus_col[n - <span class="number">1</span> + r - c] = row_plus_col[r + c] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; only_col, row_minus_col, row_plus_col;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; chessboard;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>52. N-Queens II</title>
    <url>/2021/01/15/52-N-Queens-II/</url>
    <content><![CDATA[<p>O(n!) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        total = <span class="number">0</span>;</span><br><span class="line">        only_col.resize(n);</span><br><span class="line">        row_minus_col.resize((n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">        row_plus_col.resize((n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">        totalNQueens_helper(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">totalNQueens_helper</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            ++total;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col(<span class="number">0</span>); col &lt; n; ++col) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!only_col[col] &amp;&amp; !row_minus_col[n - <span class="number">1</span> + row - col] &amp;&amp; !row_plus_col[row + col]) &#123;</span><br><span class="line">                only_col[col] = row_minus_col[n - <span class="number">1</span> + row - col] = row_plus_col[row + col] = <span class="literal">true</span>;</span><br><span class="line">                totalNQueens_helper(row + <span class="number">1</span>);</span><br><span class="line">                only_col[col] = row_minus_col[n - <span class="number">1</span> + row - col] = row_plus_col[row + col] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; only_col;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; row_minus_col;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; row_plus_col;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>637. Average of Levels in Binary Tree</title>
    <url>/2021/01/15/637-Average-of-Levels-in-Binary-Tree/</url>
    <content><![CDATA[<p>bfs O(n) time O(logn) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.size();</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                sum += node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(sum / n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Binary tree</tag>
        <tag>Level order traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>686. Repeated String Match</title>
    <url>/2021/01/16/686-Repeated-String-Match/</url>
    <content><![CDATA[<p>ad-hoc O(n*(n+m)) m是A的长度 n是B的长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s.length() &lt; B.length()) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            s += A;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.find(B) != <span class="built_in">string</span>::npos) <span class="keyword">return</span> cnt;</span><br><span class="line">        s += A; <span class="comment">// 长度超过B未必一定包含B有可能最后还差A开头的几个字母</span></span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">return</span> s.find(B) == <span class="built_in">string</span>::npos ? <span class="number">-1</span> : cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这道题还有KMP和Rabin-Karp (Rolling Hash)两种做法 O(m+n)但是过于复杂</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s.length() &lt; B.length()) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            s += A;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (strStr(s, B) != <span class="number">-1</span>) <span class="keyword">return</span> cnt;</span><br><span class="line">        s += A; <span class="comment">// 长度超过B未必一定包含B有可能最后还差A开头的几个字母</span></span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">return</span> strStr(s, B) == <span class="number">-1</span> ? <span class="number">-1</span> : cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;haystack, <span class="keyword">const</span> <span class="built_in">string</span> &amp;needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = haystack.length(), n = needle.length();</span><br><span class="line">        <span class="keyword">long</span> M = INT_MAX, B = <span class="number">256</span>; <span class="comment">// INT_MAX是质数！</span></span><br><span class="line">        <span class="keyword">if</span> (h &lt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> highest_power = <span class="number">1</span>, hh = <span class="number">0</span>, nh = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            highest_power = (highest_power * B) % M;</span><br><span class="line">            nh = (nh * B + needle[i]) % M;</span><br><span class="line">            hh = (hh * B + haystack[i]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= h - n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                hh = (hh * B + M - haystack[i - <span class="number">1</span>] * highest_power % M + haystack[i + n - <span class="number">1</span>]) % M; <span class="comment">// 这里highest_power是B的n次方，因为先整体左移再减高位，如果先减高位再整体左移就是n-1次方了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hh == nh &amp;&amp; haystack.substr(i, n) == needle) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Rolling hash</tag>
      </tags>
  </entry>
  <entry>
    <title>839. Similar String Groups</title>
    <url>/2021/01/15/839-Similar-String-Groups/</url>
    <content><![CDATA[<p>O(n*m*min(n, m<sup>2</sup>)) time<br>两种方法根据数据不同决定用那种</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), m = A[<span class="number">0</span>].length();</span><br><span class="line">        res = n;</span><br><span class="line">        parent.resize(n);</span><br><span class="line">        iota(begin(parent), end(parent), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m * m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isSimilar(A[i], A[j])) &#123;</span><br><span class="line">                        merge(i, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; hm;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> s = A[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; m; ++k) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s[j] == s[k]) <span class="keyword">continue</span>;</span><br><span class="line">                        swap(s[j], s[k]);</span><br><span class="line">                        hm[s].push_back(i); <span class="comment">// 把每个词能转换成的词都枚举出来，注意原始词不放进去，后面用来merge</span></span><br><span class="line">                        swap(s[j], s[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hm.count(A[i])) &#123; <span class="comment">// 用每个词去找哪些词能转换成这个词</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j : hm[A[i]]) &#123;</span><br><span class="line">                        merge(i, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">            x = parent[x] = parent[parent[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line">        <span class="keyword">if</span> (px != py) &#123;</span><br><span class="line">            parent[px] = py;</span><br><span class="line">            --res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSimilar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">-1</span>, y = <span class="number">-1</span>, n = a.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> a == b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">-1</span>) &#123;</span><br><span class="line">                x = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">-1</span>) &#123;</span><br><span class="line">                y = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">-1</span> || y != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用这个<br>O(nnm) time where n是字符串个数m是字符串长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        res = n;</span><br><span class="line">        parent.resize(n);</span><br><span class="line">        iota(begin(parent), end(parent), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isSimilar(A[i], A[j])) &#123;</span><br><span class="line">                    merge(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">            x = parent[x] = parent[parent[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line">        <span class="keyword">if</span> (px != py) &#123;</span><br><span class="line">            parent[px] = py;</span><br><span class="line">            --res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSimilar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">-1</span>, y = <span class="number">-1</span>, n = a.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> a == b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">-1</span>) &#123;</span><br><span class="line">                x = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">-1</span>) &#123;</span><br><span class="line">                y = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">-1</span> || y != <span class="number">-1</span>; <span class="comment">// 两个词要不相同，要不只能有两个字母不一样，前提是所有词都是anagram</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>935. Knight Dialer</title>
    <url>/2021/01/15/935-Knight-Dialer/</url>
    <content><![CDATA[<p>dp优化矩阵乘法 O(logn) time O(1) space<br>状态转移矩阵用column-based竖着看才行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">knightDialer</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; mtx = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        mtx = <span class="built_in">pow</span>(mtx, N - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; f&#123;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;(<span class="number">10</span>, <span class="number">1</span>)&#125;;</span><br><span class="line">        f = mul(f, mtx);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            res = (res + f[<span class="number">0</span>][i]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; <span class="built_in">pow</span>(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; &amp;mtx, <span class="keyword">int</span> N) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = mtx.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; res(n, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                res = mul(res, mtx);</span><br><span class="line">            &#125;</span><br><span class="line">            mtx = mul(mtx, mtx);</span><br><span class="line">            N &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; mul(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; &amp;a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; &amp;b) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = a.size(), n = b.size(), p = b[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; res(m, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;(p));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % M;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp O(N) time O(1) space<br>bottom up<br>最底层是N=1每一层往上迭代累加即可<br>f[i]表示最后一个数为i的可能的拨号方式有多少种<br>f[i]表示当前层到最底层从i开始的不同number的个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">knightDialer</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; next = &#123;&#123;<span class="number">4</span>, <span class="number">6</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>&#125;, &#123;<span class="number">7</span>, <span class="number">9</span>&#125;, &#123;<span class="number">4</span>, <span class="number">8</span>&#125;, &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>&#125;, &#123;&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">7</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">            t.swap(f);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; <span class="number">10</span>; ++u) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> v : next[u]) &#123;</span><br><span class="line">                    f[v] = (f[v] + t[u]) % M;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            res = (res + f[i]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dfs+memo O(N) time O(N) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">knightDialer</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        next = &#123;&#123;<span class="number">4</span>, <span class="number">6</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>&#125;, &#123;<span class="number">7</span>, <span class="number">9</span>&#125;, &#123;<span class="number">4</span>, <span class="number">8</span>&#125;, &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>&#125;, &#123;&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">7</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">        m.resize(<span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            res = (res + count(i, N)) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (m[u][N] != <span class="number">-1</span>) <span class="keyword">return</span> m[u][N];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : next[u]) &#123;</span><br><span class="line">            res = (res + count(v, N - <span class="number">1</span>)) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[u][N] = res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m, next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>983. Minimum Cost For Tickets</title>
    <url>/2021/01/15/983-Minimum-Cost-For-Tickets/</url>
    <content><![CDATA[<p>dp + memo<br>O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        n = days.size();</span><br><span class="line">        cost.resize(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; passes = &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> mincost(<span class="number">0</span>, days, <span class="number">0</span>, passes, costs); <span class="comment">// lastDay从0开始，因为不知道days都是哪些天</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincost</span><span class="params">(<span class="keyword">int</span> lastDay, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;days, <span class="keyword">int</span> nextIdx, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;passes, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextIdx &gt;= n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (days[nextIdx] &lt;= lastDay) <span class="keyword">return</span> mincost(lastDay, days, nextIdx + <span class="number">1</span>, passes, costs); <span class="comment">// 如果之前买的票可以cover当前这一天days[nextIdx]则继续测试days[nextIdx + 1]</span></span><br><span class="line">        <span class="keyword">if</span> (cost[nextIdx] &gt; <span class="number">0</span>) <span class="keyword">return</span> cost[nextIdx];</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            res = min(res, mincost(days[nextIdx] + passes[i] - <span class="number">1</span>, days, nextIdx + <span class="number">1</span>, passes, costs) + costs[i]); <span class="comment">// 分别测试三种票哪种可以使得总票价最低</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost[nextIdx] = res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cost; <span class="comment">// cache</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>102. Binary Tree Level Order Traversal</title>
    <url>/2021/01/16/102-Binary-Tree-Level-Order-Traversal/</url>
    <content><![CDATA[<p>bfs O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            res.push_back(&#123;&#125;);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size(q); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (!p) <span class="keyword">continue</span>;</span><br><span class="line">                res.back().push_back(p-&gt;val);</span><br><span class="line">                q.push(p-&gt;left);</span><br><span class="line">                q.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.back().empty()) &#123; <span class="comment">// 别忘了最后要弹出空数组</span></span><br><span class="line">            res.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;TreeNode *, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.emplace(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (p.first) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.second &lt; res.size()) res[p.second].push_back(p.first-&gt;val);</span><br><span class="line">                <span class="keyword">else</span> res.push_back(&#123;p.first-&gt;val&#125;);</span><br><span class="line">                q.emplace(p.first-&gt;left, p.second + <span class="number">1</span>);</span><br><span class="line">                q.emplace(p.first-&gt;right, p.second + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>preorder traversal O(n) time O(1) extra space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        preorder(root, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res, <span class="keyword">int</span> lvl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (res.size() == lvl) &#123;</span><br><span class="line">            res.resize(lvl + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res[lvl].push_back(root-&gt;val);</span><br><span class="line">        preorder(root-&gt;left, res, lvl + <span class="number">1</span>);</span><br><span class="line">        preorder(root-&gt;right, res, lvl + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Depth first search</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>1091. Shortest Path in Binary Matrix</title>
    <url>/2021/01/16/1091-Shortest-Path-in-Binary-Matrix/</url>
    <content><![CDATA[<p>O(n<sup>2</sup>) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">int</span> dr[] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dc[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.emplace(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [r, c] = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (r == n - <span class="number">1</span> &amp;&amp; c == n - <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                    <span class="keyword">int</span> rr = r + dr[i], cc = c + dc[i];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= rr &amp;&amp; rr &lt; n &amp;&amp; <span class="number">0</span> &lt;= cc &amp;&amp; cc &lt; n &amp;&amp; grid[rr][cc] == <span class="number">0</span>) &#123;</span><br><span class="line">                        q.emplace(rr, cc);</span><br><span class="line">                        grid[rr][cc] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title>143. Reorder List</title>
    <url>/2021/01/16/143-Reorder-List/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy_head</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy_head.next = head;</span><br><span class="line">        <span class="keyword">auto</span> slow = &amp;dummy_head, fast = slow; <span class="comment">// 如果希望最后slow落在(n - 1) / 2的那个，要从dummy_head开始</span></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *curr = fast;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = prev;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = fast-&gt;next;</span><br><span class="line">            fast-&gt;next = slow-&gt;next;</span><br><span class="line">            slow-&gt;next = fast;</span><br><span class="line">            slow = fast-&gt;next;</span><br><span class="line">            fast = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy_head</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy_head.next = head;</span><br><span class="line">        <span class="keyword">auto</span> slow = &amp;dummy_head, fast = slow;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode *&gt; s;</span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            s.push(fast);</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = slow-&gt;next;</span><br><span class="line">            s.top()-&gt;next = next;</span><br><span class="line">            slow-&gt;next = s.top(); s.pop();</span><br><span class="line">            slow = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>345. Reverse Vowels of a String</title>
    <url>/2021/01/16/345-Reverse-Vowels-of-a-String/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseVowels</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> m[<span class="number">256</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> v : <span class="string">&quot;aeiouAEIOU&quot;</span>) &#123;</span><br><span class="line">            m[v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = size(s), l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !m[s[l]]) ++l;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; !m[s[r]]) --r;</span><br><span class="line">            swap(s[l++], s[r--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>452. Minimum Number of Arrows to Burst Balloons</title>
    <url>/2021/01/16/452-Minimum-Number-of-Arrows-to-Burst-Balloons/</url>
    <content><![CDATA[<p>O(nlogn + n)<br>问贴海报需要几根钉子，扫描线做不了<br>贪心，先排序，只要左端升序即可，右端无所谓，因为始终维护右端最小值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(begin(points), end(points));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> r = LONG_MIN; <span class="comment">// 必须要用long，反例[INT_MIN, INT_MAX]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;v : points) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[<span class="number">0</span>] &gt; r) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                r = v[<span class="number">1</span>]; <span class="comment">// 因为要开启一个新的区间，所以直接使用这个区间的最右端</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = min(r, (<span class="keyword">long</span>)v[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>449. Serialize and Deserialize BST</title>
    <url>/2021/01/16/449-Serialize-and-Deserialize-BST/</url>
    <content><![CDATA[<p>postorder DFS O(n) serialize O(n) deserialize O(n) space<br>serialize时是左右中，deserialize的时候是中右左<br>digit转一字节字符+delimiter</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root ? serialize(root-&gt;left) + serialize(root-&gt;right) + to_string(root-&gt;val) + <span class="string">&quot; &quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">while</span> (input &gt;&gt; x) &#123;</span><br><span class="line">            v.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> insert(v, INT_MIN, INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build BST</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">insert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> mn, <span class="keyword">int</span> mx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.empty() || v.back() &lt; mn || v.back() &gt; mx) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(v.back());</span><br><span class="line">        v.pop_back();</span><br><span class="line">        root-&gt;right = insert(v, root-&gt;val, mx);</span><br><span class="line">        root-&gt;left = insert(v, mn, root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>
<p>int转4字节字符串，不需要delimiter</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root ? serialize(root-&gt;left) + serialize(root-&gt;right) + toByte(root-&gt;val) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toByte</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(<span class="number">4</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span>; --i, x &gt;&gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            res[i] = x &amp; <span class="number">15</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size(data); i += <span class="number">4</span>) &#123;</span><br><span class="line">            v.push_back(toInt(data, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> insert(v, INT_MIN, INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toInt</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = s[b];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            res &lt;&lt;= <span class="number">4</span>; <span class="comment">// 注意只左移3次！！</span></span><br><span class="line">            res |= s[b + i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build BST</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">insert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> mn, <span class="keyword">int</span> mx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.empty() || v.back() &lt; mn || v.back() &gt; mx) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(v.back());</span><br><span class="line">        v.pop_back();</span><br><span class="line">        root-&gt;right = insert(v, root-&gt;val, mx);</span><br><span class="line">        root-&gt;left = insert(v, mn, root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>
<p>去掉vector</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root ? serialize(root-&gt;left) + serialize(root-&gt;right) + toByte(root-&gt;val) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toByte</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(<span class="number">4</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span>; --i, x &gt;&gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            res[i] = x &amp; <span class="number">15</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        string_view sv&#123;data&#125;;</span><br><span class="line">        <span class="keyword">return</span> insert(sv, INT_MIN, INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int toInt(string_view sv) &#123;</span></span><br><span class="line">    <span class="comment">//     int res = 0, n = size(sv);</span></span><br><span class="line">    <span class="comment">//     for (int i = 0, shift = 0; i &lt; 4; ++i, shift += 4) &#123;</span></span><br><span class="line">    <span class="comment">//         res |= (sv[n - i - 1] &lt;&lt; shift);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toInt</span><span class="params">(string_view sv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, shift = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i, shift += <span class="number">4</span>, sv.remove_suffix(<span class="number">1</span>)) &#123;</span><br><span class="line">            res |= (sv.back() &lt;&lt; shift);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build BST</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">insert</span><span class="params">(string_view &amp;sv, <span class="keyword">int</span> mn, <span class="keyword">int</span> mx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sv.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> v = toInt(sv);</span><br><span class="line">        <span class="keyword">if</span> (v &lt; mn || v &gt; mx) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        sv.remove_suffix(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">        root-&gt;right = insert(sv, root-&gt;val, mx);</span><br><span class="line">        root-&gt;left = insert(sv, mn, root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>
<p>preorder DFS O(n) serialize O(nlogn) deserialize<br>前序遍历可以唯一确定bst的结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root ? to_string(root-&gt;val) + <span class="string">&quot; &quot;</span> + serialize(root-&gt;left) + serialize(root-&gt;right) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> token;</span><br><span class="line">        <span class="function">TreeNode <span class="title">dummy_root</span><span class="params">(INT_MIN)</span></span>; <span class="comment">// 为了能让结果在右子树要选择INT_MIN</span></span><br><span class="line">        <span class="keyword">while</span> (input &gt;&gt; token) &#123;</span><br><span class="line">            insert(&amp;dummy_root, stoi(token));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_root.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build BST</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">insert</span><span class="params">(TreeNode *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">            root-&gt;left = root-&gt;left ? insert(root-&gt;left, val) : <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root-&gt;right = root-&gt;right ? insert(root-&gt;right, val) : <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root ? to_string(root-&gt;val) + <span class="string">&quot; &quot;</span> + serialize(root-&gt;left) + serialize(root-&gt;right) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> token;</span><br><span class="line">        <span class="function">TreeNode <span class="title">dummy_root</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (input &gt;&gt; token) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dummy_root.left) &#123;</span><br><span class="line">                insert(dummy_root.left, stoi(token));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dummy_root.left = <span class="keyword">new</span> TreeNode(stoi(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_root.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build BST</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TreeNode *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">                insert(root-&gt;left, val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root-&gt;left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                insert(root-&gt;right, val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root-&gt;right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Depth first search</tag>
        <tag>Postorder traversal</tag>
        <tag>Preorder traversal</tag>
        <tag>Serialization</tag>
      </tags>
  </entry>
  <entry>
    <title>692. Top K Frequent Words</title>
    <url>/2021/01/16/692-Top-K-Frequent-Words/</url>
    <content><![CDATA[<p>hashmap+bucket sort O(n+k) worst case O(nlogn)<br>跟<a href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a>思路基本一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : words) &#123;</span><br><span class="line">            ++m[w];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = words.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; buckets(n + <span class="number">1</span>); <span class="comment">// 因为要求按字典序排序所以复杂度会略高</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [w, freq] : m) &#123;</span><br><span class="line">            buckets[freq].insert(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : buckets[i]) &#123;</span><br><span class="line">                res.push_back(w);</span><br><span class="line">                <span class="keyword">if</span> (size(res) == k) <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>hashmap+trie+bucket sort O(n+k*w) time O(n) space w是平均字符长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : words) &#123;</span><br><span class="line">            ++m[w];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = words.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;TrieNode *&gt; <span class="title">buckets</span><span class="params">(n + <span class="number">1</span>, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; b : buckets) &#123;</span><br><span class="line">            b = <span class="keyword">new</span> TrieNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : m) &#123;</span><br><span class="line">            insert(buckets[p.second], p.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>; --i) &#123; <span class="comment">// 题目要求高频到低频</span></span><br><span class="line">            getWords(buckets[i], k, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        TrieNode *children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="keyword">bool</span> isEnd = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">string</span> w;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TrieNode *p, <span class="keyword">const</span> <span class="built_in">string</span> &amp;w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : w) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">        p-&gt;w = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getWords</span><span class="params">(TrieNode *p, <span class="keyword">int</span> &amp;k, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p || k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;isEnd) &#123;</span><br><span class="line">            res.push_back(p-&gt;w);</span><br><span class="line">            --k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123; <span class="comment">// trie天然形成字典序</span></span><br><span class="line">            getWords(p-&gt;children[i], k, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>quickselect O(n+klogk) time worst case O(nlogn) O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : words) &#123;</span><br><span class="line">            ++m[w];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; v(begin(m), end(m));</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;a, <span class="keyword">const</span> <span class="keyword">auto</span> &amp;b)&#123; <span class="keyword">return</span> a.second == b.second ? a.first &lt; b.first : a.second &gt; b.second; &#125;;</span><br><span class="line">        nth_element(begin(v), begin(v) + k, end(v), cmp);</span><br><span class="line">        sort(begin(v), begin(v) + k, cmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[w, f] : v) &#123;</span><br><span class="line">            res.push_back(w);</span><br><span class="line">            <span class="keyword">if</span> (size(res) == k) <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Trie</tag>
        <tag>Quickselect</tag>
        <tag>Bucket sort</tag>
      </tags>
  </entry>
  <entry>
    <title>969. Pancake Sorting</title>
    <url>/2021/01/16/969-Pancake-Sorting/</url>
    <content><![CDATA[<p>O(n<sup>2</sup>) time O(1) space<br>因为题目要求任何解法都可以，所以用最直白的思路，先从大到小找到每一个数，然后把这个数翻转到最开始，再翻转到对应的位置即可<br>类似bubble sort</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pancakeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = distance(begin(A), find(begin(A), begin(A) + i + <span class="number">1</span>, i + <span class="number">1</span>));</span><br><span class="line">            res.push_back(k + <span class="number">1</span>);</span><br><span class="line">            reverse(begin(A), begin(A) + k + <span class="number">1</span>);</span><br><span class="line">            res.push_back(i + <span class="number">1</span>);</span><br><span class="line">            reverse(begin(A), begin(A) + i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>148. Sort List</title>
    <url>/2021/01/16/148-Sort-List/</url>
    <content><![CDATA[<p>merge sort O(nlogn) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummy_head(0), *slow = &amp;dummy_head, *fast = slow;</span><br><span class="line">        dummy_head.next = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> l1 = head, l2 = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        l1 = sortList(l1);</span><br><span class="line">        l2 = sortList(l2);</span><br><span class="line">        <span class="keyword">auto</span> tail = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>219. Contains Duplicate II</title>
    <url>/2021/01/16/219-Contains-Duplicate-II/</url>
    <content><![CDATA[<p>hashmap O(n) time<br>维护一个hashmap边扫边查边存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = nums.size(); i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.count(nums[i]) &amp;&amp; i - m[nums[i]] &lt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
      </tags>
  </entry>
  <entry>
    <title>228. Summary Ranges</title>
    <url>/2021/01/16/228-Summary-Ranges/</url>
    <content><![CDATA[<p>O(n) time O(n) space<br>这道题纯考实现<br>因为字符串形式的数不方便pop_back所以最好用int来表示数，确认没问题了再把数转成字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">summaryRanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v.empty() || v.back().second + <span class="number">1</span> &lt; x) &#123;</span><br><span class="line">                v.emplace_back(x, x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v.back().second = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[b, e] : v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b == e) &#123;</span><br><span class="line">                res.push_back(to_string(b));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(to_string(b) + <span class="string">&quot;-&gt;&quot;</span> + to_string(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n) time O(1) space<br>[res.back(), prev, x]</p>
<ol>
<li>res.back() &lt; prev ===&gt; “res.back() -&gt; prev”</li>
<li>res.back() == prev ===&gt; “res.back()”即一个孤立的数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">summaryRanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> prev = LONG_MIN; <span class="comment">// 初始化prev表示前一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123; <span class="comment">// 因为需要处理最后一个数，所以延长到n</span></span><br><span class="line">            <span class="keyword">long</span> x = i == n ? LONG_MAX : nums[i]; <span class="comment">// 取当前数</span></span><br><span class="line">            <span class="keyword">if</span> (prev + <span class="number">1</span> &lt; x) &#123; <span class="comment">// 如果不是连续的数</span></span><br><span class="line">                <span class="keyword">if</span> (!res.empty() &amp;&amp; stoi(res.back()) &lt; prev) &#123; <span class="comment">// append</span></span><br><span class="line">                    res.back() += <span class="string">&quot;-&gt;&quot;</span> + to_string(prev);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n) &#123; <span class="comment">// 把当前新起头的数存起来</span></span><br><span class="line">                    res.push_back(to_string(x));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Ranges</tag>
      </tags>
  </entry>
  <entry>
    <title>388. Longest Absolute File Path</title>
    <url>/2021/01/16/388-Longest-Absolute-File-Path/</url>
    <content><![CDATA[<p>hashmap O(n) time O(lvl) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthLongestPath</span><span class="params">(<span class="built_in">string</span> input)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;; <span class="comment">// 加一个-1方便运算</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(input)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">while</span> (getline(iss, s)) &#123; <span class="comment">// 直接读一行</span></span><br><span class="line">            <span class="keyword">int</span> lvl = s.find_first_not_of(<span class="string">&#x27;\t&#x27;</span>); <span class="comment">// 数tab个数即为层数</span></span><br><span class="line">            m[lvl] = s.length() - lvl + m[lvl - <span class="number">1</span>]; <span class="comment">// 当前层的长度-tab个数+上一层的累加和 即为 当前层的累加和</span></span><br><span class="line">            <span class="keyword">if</span> (s.find(<span class="string">&#x27;.&#x27;</span>) != <span class="built_in">string</span>::npos) &#123; <span class="comment">// 如果是一个文件的话</span></span><br><span class="line">                res = max(res, m[lvl] + lvl); <span class="comment">// 切记需要加上slash个数才是真的长度！！！</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>stack O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthLongestPath</span><span class="params">(<span class="built_in">string</span> input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">        input += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>, e = input.find(<span class="string">&#x27;\n&#x27;</span>), lvl = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; e != <span class="built_in">string</span>::npos; e = input.find(<span class="string">&#x27;\n&#x27;</span>, b)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (s.size() &gt; lvl) &#123;</span><br><span class="line">                len -= s.top().length();</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(input.substr(b, e - b + <span class="number">1</span>));</span><br><span class="line">            len += s.top().length();</span><br><span class="line">            <span class="keyword">if</span> (s.top().find(<span class="string">&#x27;.&#x27;</span>) != <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">                res = max(res, len - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (b = e + <span class="number">1</span>, lvl = <span class="number">0</span>; b &lt; input.length() &amp;&amp; input[b] == <span class="string">&#x27;\t&#x27;</span>; ++b, ++lvl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>395. Longest Substring with At Least K Repeating Characters</title>
    <url>/2021/01/17/395-Longest-Substring-with-At-Least-K-Repeating-Characters/</url>
    <content><![CDATA[<p>分治 O(n) time O(1) space<br>这道题首先要统计字母频，突破口是字母频小于k的字母一定不在任何符合要求的子串里，即把整个字符串分割成若干『有可能符合要求』的子串，这样分而治之，对每个『有可能符合要求』的子串进行分析统计出最长的子串，因为每次分割都会至少去掉一个字母（如果有不符合要求的字母的话），所以最多需要26层，每层总计算步的和是O(n)，这样总的时间复杂度是O(26n)，即O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, <span class="number">0</span>, size(s), k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> b, <span class="keyword">int</span> e, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == e || k &gt; e - b) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果是空子串或者k过大</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> e - b; <span class="comment">// 如果k为0说明整个子串都是有效的</span></span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; e; ++i) &#123;</span><br><span class="line">            ++f[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, p = b; <span class="comment">// p表示可能的有效子串的开始下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt;= e; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == b &amp;&amp; i == e) <span class="keyword">return</span> e - b; <span class="comment">// 如果整个子串都是有效的</span></span><br><span class="line">            <span class="keyword">if</span> (i == e || f[s[i] - <span class="string">&#x27;a&#x27;</span>] &lt; k) &#123; <span class="comment">// 检查每一个可能的有效子串（包括最后一段，两个condition顺序不能颠倒，否则会越界）</span></span><br><span class="line">                res = max(res, dfs(s, p, i, k));</span><br><span class="line">                p = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || k &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">27</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            ++f[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        s += <span class="keyword">char</span>(<span class="string">&#x27;z&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> allValid = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[s[i] - <span class="string">&#x27;a&#x27;</span>] &gt;= k) &#123;</span><br><span class="line">                str += s[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == n &amp;&amp; allValid) <span class="keyword">return</span> n;</span><br><span class="line">                allValid = <span class="literal">false</span>;</span><br><span class="line">                res = max(res, longestSubstring(move(str), k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || k &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            ++f[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[s[i] - <span class="string">&#x27;a&#x27;</span>] &lt; k) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (; j &lt; n &amp;&amp; f[s[j] - <span class="string">&#x27;a&#x27;</span>] &gt;= k; ++j);</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == n) <span class="keyword">return</span> j - i;</span><br><span class="line">                res = max(res, longestSubstring(s.substr(i, j - i), k));</span><br><span class="line">                i = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>sliding window O(n) time O(1) space<br>先数一下有多少种不同字符，从1开始枚举不同字符的个数，即相当于window中不同字符的种类数，跑一下类似<a href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/">340. Longest Substring with At Most K Distinct Characters</a>但需要维护一个cntK来保证当前window内所有字符的个数都至少为k个，否则不对res进行更新，最多26种字符，对每一个可能的种类数跑一下sliding window，复杂度为O(26n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> uniqueChars = countUniqueChars(s), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = size(s), uniqueChar = <span class="number">1</span>; uniqueChar &lt;= uniqueChars; ++uniqueChar) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, cntK = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++m[s[r]] == k) &#123;</span><br><span class="line">                    ++cntK;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (size(m) &gt; uniqueChar) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (m[s[l]] == k) &#123;</span><br><span class="line">                        --cntK;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (--m[s[l]] == <span class="number">0</span>) &#123;</span><br><span class="line">                        m.erase(s[l]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cntK == uniqueChar) &#123;</span><br><span class="line">                    res = max(res, r - l + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countUniqueChars</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> visited[<span class="number">26</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[c - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                visited[c - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>分治 worst case O(n<sup>2</sup>) time<br>和O(n)的方法相比，这个方法在每一层分割的时候只去掉一个不符合要求的字母，这样，总层数最坏情况有可能是O(n)，因为每一层的计算步是O(n)，所以总的时间复杂度是O(n^2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n &lt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            ++f[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n &amp;&amp; f[s[i] - <span class="string">&#x27;a&#x27;</span>] &gt;= k; ++i);</span><br><span class="line">        <span class="keyword">if</span> (i == n) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> max(longestSubstring(s.substr(<span class="number">0</span>, i), k), longestSubstring(s.substr(i + <span class="number">1</span>), k));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>iterative O(n<sup>2</sup>) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + k &lt;= n;) &#123;</span><br><span class="line">            <span class="keyword">int</span> mx = i;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> f[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = s[j] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                ++f[c];</span><br><span class="line">                <span class="keyword">if</span> (f[c] &lt; k) &#123;</span><br><span class="line">                    x |= (<span class="number">1</span> &lt;&lt; c);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    x &amp;= ~(<span class="number">1</span> &lt;&lt; c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">                    res = max(res, j - i + <span class="number">1</span>);</span><br><span class="line">                    mx = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i = mx + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
        <tag>Divide and conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>73. Set Matrix Zeroes</title>
    <url>/2021/01/16/73-Set-Matrix-Zeroes/</url>
    <content><![CDATA[<p>O(mn) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">bool</span> row0 = <span class="literal">false</span>, col0 = <span class="literal">false</span>; <span class="comment">// row0和col0来标记第一行和第一列是否应该被设成0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; m; ++c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][c] == <span class="number">0</span>) &#123;</span><br><span class="line">                row0 = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[r][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                col0 = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; m; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[r][<span class="number">0</span>] = matrix[<span class="number">0</span>][c] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; m; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[r][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][c] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[r][c] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (row0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; m; ++c) &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][c] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (col0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">                matrix[r][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">bool</span> col0 = <span class="literal">false</span>; <span class="comment">// col0来标记第一列是否应该被设成0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[r][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                col0 = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; m; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[r][<span class="number">0</span>] = matrix[<span class="number">0</span>][c] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; m; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[r][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][c] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[r][c] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (matrix[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; m; ++c) &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][c] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (col0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">                matrix[r][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>98. Validate Binary Search Tree</title>
    <url>/2021/01/16/98-Validate-Binary-Search-Tree/</url>
    <content><![CDATA[<p>O(n) inorder traversal<br>维护一个中序遍历的当前最后一个节点lastNode，遍历完左子树，如果是valid，lastNode应该是左子树最后一个（最大的）节点，将其和root比较，如果比root小，则将lastNode更新为root然后遍历右子树，一个valid的BST必须始终保持lastNode是最大的节点且小于当前root</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    TreeNode *lastNode = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isValidBST(root-&gt;left)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (lastNode &amp;&amp; lastNode-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        lastNode = root;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>O(n) dfs判断条件，左子树最大值 &lt; 根节点值 &lt; 右子树最小值，所以递归时需要返回三个值，树的最小值，树的最大值，该树是否是valid</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = helper(root);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>] &lt;= res[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> mn = root-&gt;val, mx = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">auto</span> l = helper(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (l[<span class="number">0</span>] &gt; l[<span class="number">1</span>] || l[<span class="number">1</span>] &gt;= root-&gt;val) <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">            mn = l[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">auto</span> r = helper(root-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (r[<span class="number">0</span>] &gt; r[<span class="number">1</span>] || root-&gt;val &gt;= r[<span class="number">0</span>]) <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">            mx = r[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;mn, mx&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pair&lt;int, int&gt; helper(TreeNode *root, bool &amp;res) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;INT_MAX, INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">int</span> max = root-&gt;val, min = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">auto</span> l = helper(root-&gt;left, res);</span><br><span class="line">            min = <span class="built_in">std</span>::min(min, l.first);</span><br><span class="line">            max = <span class="built_in">std</span>::max(max, l.second);</span><br><span class="line">            res &amp;= (l.second &lt; root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">auto</span> r = helper(root-&gt;right, res);</span><br><span class="line">            min = <span class="built_in">std</span>::min(min, r.first);</span><br><span class="line">            max = <span class="built_in">std</span>::max(max, r.second);</span><br><span class="line">            res &amp;= (root-&gt;val &lt; r.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;min, max&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Binary search tree</tag>
        <tag>Binary tree</tag>
        <tag>Inorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>1038. Binary Search Tree to Greater Sum Tree</title>
    <url>/2021/01/17/1038-Binary-Search-Tree-to-Greater-Sum-Tree/</url>
    <content><![CDATA[<p>右中左序遍历，维护一个全局的sum</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstToGst</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        bstToGst(root-&gt;right);</span><br><span class="line">        root-&gt;val = sum += root-&gt;val;</span><br><span class="line">        bstToGst(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Binary search tree</tag>
        <tag>Binary tree</tag>
        <tag>Inorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>1143. Longest Common Subsequence</title>
    <url>/2021/01/17/1143-Longest-Common-Subsequence/</url>
    <content><![CDATA[<p>dp O(mn) time O(mn) space<br>LCS</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length(), n = text2.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = max(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(mn) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length(), n = text2.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i &amp; <span class="number">1</span>, j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    f[k][j] = f[k ^ <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[k][j] = max(f[k ^ <span class="number">1</span>][j], f[k][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m &amp; <span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>1162. As Far from Land as Possible</title>
    <url>/2021/01/17/1162-As-Far-from-Land-as-Possible/</url>
    <content><![CDATA[<p>O(mn) time O(1) space<br>↘扫描一遍再↖扫描一遍，第一次扫可以得到到左上方land的最近距离，第二次扫可以得到到剩余land的最近距离，取最小值来更新全局最大值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = grid.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != <span class="number">1</span>) &#123; <span class="comment">// 注意是不为1，只有1是land</span></span><br><span class="line">                    grid[i][j] = <span class="number">200</span>; <span class="comment">// 所有water初始化为inf，这里用200防止后面overflow</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        grid[i][j] = min(grid[i][j], grid[i - <span class="number">1</span>][j] + <span class="number">1</span>); <span class="comment">// 向下propagate，要不是根据inf要不就是根据land</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        grid[i][j] = min(grid[i][j], grid[i][j - <span class="number">1</span>] + <span class="number">1</span>); <span class="comment">// 向右propagate</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = N - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; N) &#123;</span><br><span class="line">                        grid[i][j] = min(grid[i][j], grid[i + <span class="number">1</span>][j] + <span class="number">1</span>); <span class="comment">// 向上propagate</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j + <span class="number">1</span> &lt; N) &#123;</span><br><span class="line">                        grid[i][j] = min(grid[i][j], grid[i][j + <span class="number">1</span>] + <span class="number">1</span>); <span class="comment">// 向左propagate</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    res = max(res, grid[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res % <span class="number">200</span> - <span class="number">1</span>; <span class="comment">// 最后结果要不是inf即200要不就是距离，最后要减1是因为从land开始propagate，land的值是1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>bfs O(mn) time O(min(m, n)) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        N = grid.size();</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123; <span class="comment">// 横向扫每行找到边缘的land</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    q.emplace(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; N &amp;&amp; grid[i][j] == <span class="number">1</span> &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.emplace(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123; <span class="comment">// 纵向扫每列找到边缘的land</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp; grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    q.emplace(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; N &amp;&amp; grid[i][j] == <span class="number">1</span> &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.emplace(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123; <span class="comment">// bfs逐层扫描</span></span><br><span class="line">                <span class="keyword">auto</span> [r, c] = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> rr = r + dr[j], cc = c + dc[j];</span><br><span class="line">                    <span class="keyword">if</span> (isInBound(rr, cc) &amp;&amp; grid[rr][cc] == <span class="number">0</span>) &#123;</span><br><span class="line">                        grid[rr][cc] = <span class="number">2</span>;</span><br><span class="line">                        q.emplace(rr, cc);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInBound</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; N &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> N, dr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>Breadth first search</tag>
        <tag>Island</tag>
      </tags>
  </entry>
  <entry>
    <title>1254. Number of Closed Islands</title>
    <url>/2021/01/17/1254-Number-of-Closed-Islands/</url>
    <content><![CDATA[<p>bfs O(mn) time O(min(m, n)) space<br>先顺四个边给open island灌水 然后遍历grid给每个closed island灌水并统计个数即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closedIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span> &amp;&amp; (i == <span class="number">0</span> || i == m - <span class="number">1</span> || j == <span class="number">0</span> || j == n - <span class="number">1</span>)) &#123;</span><br><span class="line">                    bfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    bfs(grid, i, j);</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        grid[r][c] = <span class="number">1</span>;</span><br><span class="line">        q.emplace(r, c);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> rr = r + dr[i], cc = c + dc[i];</span><br><span class="line">                <span class="keyword">if</span> (rr &lt; <span class="number">0</span> || rr &gt;= m || cc &lt; <span class="number">0</span> || cc &gt;= n || grid[rr][cc]) <span class="keyword">continue</span>;</span><br><span class="line">                grid[rr][cc] = <span class="number">1</span>;</span><br><span class="line">                q.emplace(rr, cc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n, dr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closedIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                bfs(grid, i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][n - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                bfs(grid, i, n - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                bfs(grid, <span class="number">0</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (grid[m - <span class="number">1</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                bfs(grid, m - <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    bfs(grid, i, j);</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        grid[r][c] = <span class="number">1</span>;</span><br><span class="line">        q.emplace(r, c);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> rr = r + dr[i], cc = c + dc[i];</span><br><span class="line">                <span class="keyword">if</span> (rr &lt; <span class="number">0</span> || rr &gt;= m || cc &lt; <span class="number">0</span> || cc &gt;= n || grid[rr][cc]) <span class="keyword">continue</span>;</span><br><span class="line">                grid[rr][cc] = <span class="number">1</span>;</span><br><span class="line">                q.emplace(rr, cc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n, dr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Island</tag>
      </tags>
  </entry>
  <entry>
    <title>206. Reverse Linked List</title>
    <url>/2021/01/17/206-Reverse-Linked-List/</url>
    <content><![CDATA[<p>iterative O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="keyword">auto</span> succ = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = succ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>recursive O(n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> res = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>239. Sliding Window Maximum</title>
    <url>/2021/01/17/239-Sliding-Window-Maximum/</url>
    <content><![CDATA[<p>decreasing deque O(n) time O(k) space<br>维护一个递减deque，因为每次新数都是从尾入队列，所以能保证deque内所有数在原数组的位置都是递增的，这样就构造了一个数值递减下标递增的数据结构，每次只要检查最前面的数的位置是否已经超过了k个即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty() &amp;&amp; nums[q.back()] &lt; nums[i]) &#123;</span><br><span class="line">                q.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            q.push_back(i);</span><br><span class="line">            <span class="keyword">if</span> (i - q.front() &gt;= k) &#123;</span><br><span class="line">                q.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                res.push_back(nums[q.front()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        nums.push_back(INT_MIN);</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            enqueue(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            res.push_back(q.front());</span><br><span class="line">            dequeue(nums[i - k]);</span><br><span class="line">            enqueue(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty() &amp;&amp; num &gt; q.back()) &#123;</span><br><span class="line">            q.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        q.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dequeue</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.front() == num) &#123;</span><br><span class="line">            q.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Deque</tag>
      </tags>
  </entry>
  <entry>
    <title>310. Minimum Height Trees</title>
    <url>/2021/01/17/310-Minimum-Height-Trees/</url>
    <content><![CDATA[<p>bfs+topological sort O(n) time O(n) space<br>从外往里『剥洋葱』直到还剩1到2个节点为止，如果设置一个超级源点连接每个1度的点，则相当于单源最短路径</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; g(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;e : edges) &#123;</span><br><span class="line">            g[e[<span class="number">0</span>]].insert(e[<span class="number">1</span>]);</span><br><span class="line">            g[e[<span class="number">1</span>]].insert(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i].size() == <span class="number">1</span>) &#123; <span class="comment">// 叶节点『入度为0』</span></span><br><span class="line">                q.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">2</span>) &#123; <span class="comment">// 还剩最多2个『入度为0』的节点时跳出循环，不能直接看队列大小，队列里放的只是当前『入度为0』的节点</span></span><br><span class="line">            n -= size(q);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size(q); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = q.front(); q.pop_front();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) &#123;</span><br><span class="line">                    g[v].erase(u); <span class="comment">// 从邻居那删除『我』</span></span><br><span class="line">                    <span class="keyword">if</span> (g[v].size() == <span class="number">1</span>) &#123; <span class="comment">// 为了避免重复入队列，只有还连着最后一条边的时候再入</span></span><br><span class="line">                        q.push_back(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(begin(q), end(q));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>纯topological sort O(n<sup>2</sup>) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;e : edges) &#123;</span><br><span class="line">            g[e[<span class="number">0</span>]].insert(e[<span class="number">1</span>]);</span><br><span class="line">            g[e[<span class="number">1</span>]].insert(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!g.empty()) &#123;</span><br><span class="line">            res.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[i, _] : g) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g.count(i) &amp;&amp; g[i].size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                    res.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u : res) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) &#123;</span><br><span class="line">                    g[v].erase(u);</span><br><span class="line">                &#125;</span><br><span class="line">                g.erase(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Topological sort</tag>
      </tags>
  </entry>
  <entry>
    <title>387. First Unique Character in a String</title>
    <url>/2021/01/17/387-First-Unique-Character-in-a-String/</url>
    <content><![CDATA[<p>hashmap O(n)<br>这个方法比简单统计字母频要快</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : s) &#123;</span><br><span class="line">            ++f[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>把重复的字母的下标全部记成n，不重复的则记成i，然后遍历找出最小的i</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">m</span><span class="params">(<span class="number">26</span>, INT_MAX)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (m[k] == INT_MAX) &#123;</span><br><span class="line">                m[k] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m[k] &lt; n) &#123;</span><br><span class="line">                m[k] = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = *min_element(m.begin(), m.end());</span><br><span class="line">        <span class="keyword">return</span> res &lt; n ? res : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
      </tags>
  </entry>
  <entry>
    <title>445. Add Two Numbers II</title>
    <url>/2021/01/17/445-Add-Two-Numbers-II/</url>
    <content><![CDATA[<p>翻转链表 O(m+n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        l1 = reverse(l1);</span><br><span class="line">        l2 = reverse(l2);</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        ListNode *res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> b = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">            <span class="keyword">int</span> s = a + b + c;</span><br><span class="line">            <span class="keyword">auto</span> x = <span class="keyword">new</span> ListNode(s % <span class="number">10</span>);</span><br><span class="line">            x-&gt;next = res;</span><br><span class="line">            res = x;</span><br><span class="line">            c = s / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">reverse</span><span class="params">(ListNode *l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l) <span class="keyword">return</span> l;</span><br><span class="line">        ListNode *p = <span class="literal">nullptr</span>, *c = l;</span><br><span class="line">        <span class="keyword">while</span> (c) &#123;</span><br><span class="line">            <span class="keyword">auto</span> s = c-&gt;next;</span><br><span class="line">            c-&gt;next = p;</span><br><span class="line">            p = c;</span><br><span class="line">            c = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>两个栈 O(m+n) time O(m+n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1, s2; <span class="comment">// 两个栈逆序放入两个链表里的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node = l1; node; node = node-&gt;next) &#123;</span><br><span class="line">            s1.push(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node = l2; node; node = node-&gt;next) &#123;</span><br><span class="line">            s2.push(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>; <span class="comment">// 统一处理 加数 被加数 进位</span></span><br><span class="line">        ListNode *l = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s1.empty() || !s2.empty() || c &gt; <span class="number">0</span>) &#123; <span class="comment">// 不要忘记最后进位有可能不为0！！！</span></span><br><span class="line">            a = s1.empty() ? <span class="number">0</span> : s1.top();</span><br><span class="line">            b = s2.empty() ? <span class="number">0</span> : s2.top();</span><br><span class="line">            <span class="keyword">if</span> (!s1.empty()) s1.pop();</span><br><span class="line">            <span class="keyword">if</span> (!s2.empty()) s2.pop();</span><br><span class="line">            <span class="keyword">int</span> s = a + b + c;</span><br><span class="line">            <span class="keyword">auto</span> n = <span class="keyword">new</span> ListNode(s % <span class="number">10</span>);</span><br><span class="line">            n-&gt;next = l;</span><br><span class="line">            l = n;</span><br><span class="line">            c = s / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
        <tag>Addition</tag>
      </tags>
  </entry>
  <entry>
    <title>498. Diagonal Traverse</title>
    <url>/2021/01/17/498-Diagonal-Traverse/</url>
    <content><![CDATA[<p>O(mn)<br>0 &lt;= sum &lt; m + n - 1<br>0 &lt;= r &lt; n<br>0 &lt;= c &lt; m<br>sum = r + c<br>0 &lt;= r = sum - c &lt; n即sum - n &lt; c &lt;= sum<br>0 &lt;= c = sum - r &lt; m即sum - m &lt; r &lt;= sum<br>所以<br>max(0, sum - m + 1) &lt;= r &lt;= min(n - 1, sum)<br>// max(0, sum - n + 1) &lt;= c &lt;= min(m - 1, sum)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> R = matrix.size(), C = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> size = R + C - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sum = <span class="number">0</span>; sum &lt; size; ++sum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> r = max(<span class="number">0</span>, sum - (C - <span class="number">1</span>)); r &lt;= min(R - <span class="number">1</span>, sum); ++r) &#123;</span><br><span class="line">                    res.push_back(matrix[r][sum - r]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> r = min(R - <span class="number">1</span>, sum); r &gt;= max(<span class="number">0</span>, sum - (C - <span class="number">1</span>)); --r) &#123;</span><br><span class="line">                    res.push_back(matrix[r][sum - r]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> size = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sum = <span class="number">0</span>; sum &lt; size; ++sum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> r = max(<span class="number">0</span>, sum - m + <span class="number">1</span>); r &lt;= min(n - <span class="number">1</span>, sum); ++r) &#123;</span><br><span class="line">                    res.push_back(matrix[r][sum - r]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = max(<span class="number">0</span>, sum - n + <span class="number">1</span>); c &lt;= min(m - <span class="number">1</span>, sum); ++c) &#123;</span><br><span class="line">                    res.push_back(matrix[sum - c][c]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n<sup>2</sup>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row_size = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> col_size = row_size &gt; <span class="number">0</span> ? matrix.front().size() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_size = row_size + col_size - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_size; ++i) &#123; <span class="comment">// i is the sum of row + col</span></span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">						<span class="comment">// 0 &lt;= i - row &lt; col_size &amp;&amp; 0 &lt;= row &lt; row_size</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> row = max(i - col_size + <span class="number">1</span>, <span class="number">0</span>); row &lt; min(i + <span class="number">1</span>, row_size); ++row) &#123;</span><br><span class="line">                    ret.push_back(matrix[row][i - row]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 0 &lt;= i - col &lt; row_size &amp;&amp; 0 &lt;= col &lt; col_size</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> col = max(i - row_size + <span class="number">1</span>, <span class="number">0</span>); col &lt; min(i + <span class="number">1</span>, col_size); ++col) &#123;</span><br><span class="line">                    ret.push_back(matrix[i - col][col]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>538. Convert BST to Greater Tree</title>
    <url>/2021/01/17/538-Convert-BST-to-Greater-Tree/</url>
    <content><![CDATA[<p>right-middle-left reverse order traversal O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        convertBST(root-&gt;right);</span><br><span class="line">        sum = (root-&gt;val += sum);</span><br><span class="line">        convertBST(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        helper(root, sum);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode *root, <span class="keyword">int</span> &amp;sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        helper(root-&gt;right, sum);</span><br><span class="line">        root-&gt;val += sum;</span><br><span class="line">        sum = root-&gt;val;</span><br><span class="line">        helper(root-&gt;left, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Binary search tree</tag>
        <tag>Binary tree</tag>
        <tag>Inorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>605. Can Place Flowers</title>
    <url>/2021/01/17/605-Can-Place-Flowers/</url>
    <content><![CDATA[<p>greedy O(n) time O(1) space<br>纯粹考心细<br>从前往后扫，只要找到合适的位置就放，不需要考虑是否最佳，greedy是对的</p>
<ol>
<li>如果f[i] == 1跳过</li>
<li>如果f[i] == 0 &amp;&amp; f[i - 1] == 1跳过</li>
<li>如果f[i] == 0 &amp;&amp; f[i + 1] == 1跳过</li>
<li>–n同时一定要将f[i]改成1！！！！！！</li>
<li>最后一定要判断n等于0！！！！</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = flowerbed.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; flowerbed[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; sz &amp;&amp; flowerbed[i + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                --n;</span><br><span class="line">                flowerbed[i] = <span class="number">1</span>; <span class="comment">// 放</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = flowerbed.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; flowerbed[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; sz &amp;&amp; flowerbed[i + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                --n;</span><br><span class="line">                flowerbed[i] = <span class="number">1</span>; <span class="comment">// 放</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这里必须是小于等于0因为可能n会多减</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>66. Plus One</title>
    <url>/2021/01/17/66-Plus-One/</url>
    <content><![CDATA[<p>O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = size(digits), i = n - <span class="number">1</span>, c = <span class="number">0</span>; i &gt;= <span class="number">0</span> || c &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = i &gt;= <span class="number">0</span> ? digits[i] : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> b = i == n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> s = a + b + c;</span><br><span class="line">            res.push_back(s % <span class="number">10</span>);</span><br><span class="line">            c = s / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(rbegin(res), rend(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Addition</tag>
      </tags>
  </entry>
  <entry>
    <title>739. Daily Temperatures</title>
    <url>/2021/01/17/739-Daily-Temperatures/</url>
    <content><![CDATA[<p>decreasing stack O(n) time O(n) space<br>维护一个单调递减栈，栈里存下标，每次遇到更高的温度，对栈里的下标对应的结果进行更新后弹出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = temperatures.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; temperatures[s.top()] &lt; temperatures[i]) &#123;</span><br><span class="line">                res[s.top()] = i - s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从后往前维护一个单调递减栈，栈里存下标，每次判断当前下标和栈里第一个符合要求的下标的间距即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = temperatures.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; temperatures[s.top()] &lt;= temperatures[i]) &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = s.empty() ? <span class="number">0</span> : (s.top() - i);</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>91. Decode Ways</title>
    <url>/2021/01/17/91-Decode-Ways/</url>
    <content><![CDATA[<p>dp O(n) time O(n) space<br>跟爬楼梯那道题类似，每次只能爬一层或两层，问总共多少种爬法<br>最后一步：两个字符或者一个字符可以对应一个英文字母（但是要合法，两个字符要在10到26中间，一个字符不能为0）<br>子问题：f[i] = f[i - 1] + f[i - 2]<br>边界条件：f[0] = 1，即空串就只有一种decoding（这道题OJ有问题）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> f[n + <span class="number">1</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> ret = stoi(s.substr(i - <span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">10</span> &lt;= ret &amp;&amp; ret &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                    f[i] += f[i - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> f0 = <span class="number">1</span>, f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> f2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                f2 += f1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = stoi(s.substr(i - <span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">10</span> &lt;= x &amp;&amp; x &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                    f2 += f0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = f2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> f0 = <span class="number">1</span>, f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> f2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                f2 += f1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = stoi(s.substr(i - <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">10</span> &lt;= x &amp;&amp; x &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                    f2 += f0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = f2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>934. Shortest Bridge</title>
    <url>/2021/01/17/934-Shortest-Bridge/</url>
    <content><![CDATA[<p>bfs O(mn) time<br>先找到一个岛变成3同时找到岛的边缘海变成2<br>沿着边缘海扩张直到找到1为止<br>两个bfs即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestBridge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        m = A.size(), n = A[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">auto</span> [r, c] = getRC(A);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> &amp;&amp;q = update(A, r, c);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [r, c] = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> rr = r + dr[j], cc = c + dc[j];</span><br><span class="line">                    <span class="keyword">if</span> (!isValid(rr, cc)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (A[rr][cc] == <span class="number">0</span>) &#123;</span><br><span class="line">                        q.emplace(rr, cc);</span><br><span class="line">                        A[rr][cc] = <span class="number">2</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[rr][cc] == <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pair&lt;int, int&gt; getRC(vector&lt;vector&lt;int&gt;&gt; &amp;A) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;r, c&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; update(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;A, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q&#123;&#123;&#123;r, c&#125;&#125;&#125;, res;</span><br><span class="line">        A[r][c] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> rr = r + dr[i], cc = c + dc[i];</span><br><span class="line">                <span class="keyword">if</span> (isValid(rr, cc)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (A[rr][cc] == <span class="number">1</span>) &#123;</span><br><span class="line">                        q.emplace(rr, cc);</span><br><span class="line">                        A[rr][cc] = <span class="number">3</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[rr][cc] == <span class="number">0</span>) &#123;</span><br><span class="line">                        res.emplace(rr, cc);</span><br><span class="line">                        A[rr][cc] = <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; m &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n, dr[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dc[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Island</tag>
      </tags>
  </entry>
  <entry>
    <title>1027. Longest Arithmetic Subsequence</title>
    <url>/2021/01/18/1027-Longest-Arithmetic-Subsequence/</url>
    <content><![CDATA[<p>上来先clarify数的取值范围，然后再决定用哪个</p>
<p>O(n<sup>2</sup>) time O(n<sup>2</sup>) space<br>对于每个A[i]，从前往后枚举之前的每个A[j]，得到一个等差d，利用以A[j]结尾的等差数列长度来更新以A[i]结尾的等差数列的长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; f(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123; <span class="comment">// 一定要从前往后，因为是要找最长的，后边的可能更长</span></span><br><span class="line">                <span class="keyword">int</span> d = A[i] - A[j];</span><br><span class="line">                f[i][d] = max(<span class="number">2</span>, f[j][d] + <span class="number">1</span>);</span><br><span class="line">                res = max(res, f[i][d]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n<sup>2</sup>) time O(1001n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1001</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123; <span class="comment">// 一定要从前往后，因为是要找最长的，后边的可能更长</span></span><br><span class="line">                <span class="keyword">int</span> d = A[i] - A[j] + <span class="number">500</span>;</span><br><span class="line">                f[i][d] = max(<span class="number">2</span>, f[j][d] + <span class="number">1</span>);</span><br><span class="line">                res = max(res, f[i][d]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(500n) time O(500) space<br>因为题目里每个数都是在0到500之间，所以等差的绝对值肯定是在0到500之间，维护正数等差和负数等差两个数组来记录以x为最后一个数的等差数列的长度，从0到500枚举所有可能的等差，对于每个可能的等差d再枚举数组里的每个数x，看x之前数组里有没有x - d和x + d，用他们的等差数列的长度来更新x的长度，然后再更新全局res</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos_step[<span class="number">501</span>], neg_step[<span class="number">501</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;= <span class="number">500</span>; ++d) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(pos_step, <span class="number">0</span>, <span class="keyword">sizeof</span>(pos_step));</span><br><span class="line">            <span class="built_in">memset</span>(neg_step, <span class="number">0</span>, <span class="keyword">sizeof</span>(neg_step));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x : A) &#123;</span><br><span class="line">                pos_step[x] = x &lt; d ? <span class="number">1</span> : pos_step[x - d] + <span class="number">1</span>;</span><br><span class="line">                neg_step[x] = x + d &gt; <span class="number">500</span> ? <span class="number">1</span> : neg_step[x + d] + <span class="number">1</span>;</span><br><span class="line">                res = max(res, pos_step[x]);</span><br><span class="line">                res = max(res, neg_step[x]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (d &gt; <span class="number">0</span> &amp;&amp; <span class="number">501</span> / d &lt; res) <span class="keyword">break</span>; <span class="comment">// 优化：因为等差d从小到大枚举并更新res，如果当前的等差所能产生的最大长度不足以超过之前的res则没必要继续枚举了，直接返回即可</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>O(n<sup>2</sup>) time O(n<sup>2</sup>) space<br>对于等差数列A[i], A[k], A[j]来说，A[i] + A[j] = 2 * A[k]，即对于每个A[j]来说，只要能找到A[i]，即2 * A[k] - A[j]，就找到了一个等差数列<br>f[i][j]表示以A[i]开始以A[j]结束的等差数列的长度<br>f[i][j] = f[2 * A[i] - A[j]][i] + 1，即以2 * A[i] - A[j]开始以A[i]结束的等差数列的长度+1，前提是能找到这样的2 * A[i] - A[j]<br>因为三个数顺序是 2 * A[i] - A[j], A[i], A[j]，所以这道题的计算顺序必须是正向！遍历中间的i，再从i + 1开始遍历j，这样可以保证pos[2 * A[i] - A[j]], i, j的顺序，下面WA的那个遍历j再从j - 1开始遍历i的解法无法确保pos[2 * A[i] - A[j]]和i的顺序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pos;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">2</span>, n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> prev = <span class="number">2</span> * A[i] - A[j];</span><br><span class="line">                <span class="keyword">if</span> (pos.count(prev)) &#123;</span><br><span class="line">                    f[i][j] = f[pos[prev]][i] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res, f[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            pos[A[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>WA 反例[0,0,0]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pos;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">2</span>, n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            f[j][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">int</span> prev = <span class="number">2</span> * A[i] - A[j];</span><br><span class="line">                <span class="keyword">if</span> (pos.count(prev) &amp;&amp; pos[prev] &lt; i) &#123;</span><br><span class="line">                    f[i][j] = f[pos[prev]][i] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res, f[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            pos[A[j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n<sup>2</sup>) time O(n<sup>2</sup>) space<br>传统思路<br>对于每个A[i]，遍历其之前的每个A[j]，计算差值d = A[i] - A[j]保存起来<br>f[i][d]表示以A[i]结尾的差值为d的等差数列的长度<br>f[i][d] = max{2, f[j][d] + 1} where 0 &lt;= j &lt; i<br>TLE</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; f(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">int</span> d = A[i] - A[j];</span><br><span class="line">                f[i][d] = f[i].count(d) ? f[i][d] : max(<span class="number">2</span>, f[j][d] + <span class="number">1</span>); <span class="comment">// 因为是从后往前，后边的可能更长，所以需要判断是否已经用较长的更新过了，否则直接跳过即可</span></span><br><span class="line">                res = max(res, f[i][d]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>TLE</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; f(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">int</span> d = A[i] - A[j];</span><br><span class="line">                <span class="keyword">if</span> (f[i].count(d) == <span class="number">0</span>) &#123; <span class="comment">// 只更新第一次遇到的d再前边的没有更新的意义</span></span><br><span class="line">                    f[i][d] = max(<span class="number">1</span>, f[j][d]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res, f[i][d]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>枚举每个A[i]，再枚举A[i]之后的每个A[j]，得到等差d，用以A[i]结尾以d为等差的等差数列的长度来更新以A[j]结尾以d为等差的等差数列的长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">2</span>, n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1001</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)  &#123;</span><br><span class="line">                <span class="keyword">int</span> d = A[j] - A[i] + <span class="number">500</span>; <span class="comment">// 因为每个数都在0到500之间，加一个偏移500把负数等差变成正数</span></span><br><span class="line">                f[j][d] = max(<span class="number">2</span>, f[i][d] + <span class="number">1</span>);</span><br><span class="line">                res = max(res, f[j][d]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>TLE</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; f(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> d = A[j] - A[i];</span><br><span class="line">                f[j][d] = f[i].count(d) ? f[i][d] + <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">                res = max(res, f[j][d]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>1123. Lowest Common Ancestor of Deepest Leaves</title>
    <url>/2021/01/18/1123-Lowest-Common-Ancestor-of-Deepest-Leaves/</url>
    <content><![CDATA[<p>postorder O(n) time O(h) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lcaDeepestLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> depth)</span> </span>&#123; <span class="comment">// depth是从根到当前结点的深度，返回当前这棵树的深度</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = dfs(root-&gt;left, depth + <span class="number">1</span>); <span class="comment">// 子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> r = dfs(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (l == r &amp;&amp; depth + l &gt;= mx) &#123; <span class="comment">// find the lowest root that covers all the deepest leaves</span></span><br><span class="line">            mx = depth + l;</span><br><span class="line">            res = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *res = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于当前的这棵树，分别获取左子树和右子树的最深叶节点的lca以及最大深度，如果左右两边最大深度相等，则root是当前这棵树的最深叶节点的lca，返回root以及当前这棵树的最大深度；如果左右两边的最大深度不等，则返回深度较大的那个子树的结果以及当前这棵树的最大深度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lcaDeepestLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root).first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pair&lt;TreeNode *, int&gt; dfs(TreeNode *root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;root, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> l = dfs(root-&gt;left), r = dfs(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (l.second == r.second) <span class="keyword">return</span> &#123;root, l.second + <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (l.second &gt; r.second) <span class="keyword">return</span> &#123;l.first, l.second + <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;r.first, r.second + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>bfs O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lcaDeepestLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;TreeNode *, TreeNode *&gt; parent;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;TreeNode *&gt; s;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            s.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> n = q.front(); q.pop();</span><br><span class="line">                s.insert(n);</span><br><span class="line">                <span class="keyword">if</span> (n-&gt;left) &#123;</span><br><span class="line">                    q.push(n-&gt;left);</span><br><span class="line">                    parent[n-&gt;left] = n;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n-&gt;right) &#123;</span><br><span class="line">                    q.push(n-&gt;right);</span><br><span class="line">                    parent[n-&gt;right] = n;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (s.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;TreeNode *&gt; t;</span><br><span class="line">            t.swap(s);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> n : t) &#123;</span><br><span class="line">                s.insert(parent[n]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *begin(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Depth first search</tag>
        <tag>Postorder traversal</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>113. Path Sum II</title>
    <url>/2021/01/18/113-Path-Sum-II/</url>
    <content><![CDATA[<p>backtracking + dfs O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        dfs(root, sum, v, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        v.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == root-&gt;val) &#123;</span><br><span class="line">                res.push_back(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(root-&gt;left, sum - root-&gt;val, v, res);</span><br><span class="line">            dfs(root-&gt;right, sum - root-&gt;val, v, res);</span><br><span class="line">        &#125;</span><br><span class="line">        v.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Backtracking</tag>
        <tag>Binary tree</tag>
        <tag>Preorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>136. Single Number</title>
    <url>/2021/01/18/136-Single-Number/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            res ^= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>1460. Make Two Arrays Equal by Reversing Sub-arrays</title>
    <url>/2021/01/18/1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays/</url>
    <content><![CDATA[<p>O(n) time O(n) space<br>只要两个数组能对的上就行，需要知道怎么reverse可以参考<a href="https://leetcode.com/problems/pancake-sorting/">969. Pancake Sorting</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canBeEqual</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">unordered_multiset</span>&lt;<span class="keyword">int</span>&gt;(A.begin(), A.end()) == <span class="built_in">unordered_multiset</span>&lt;<span class="keyword">int</span>&gt;(target.begin(),target.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canBeEqual</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : target) &#123;</span><br><span class="line">            ++m[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--m[x] == <span class="number">0</span>) &#123;</span><br><span class="line">                m.erase(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canBeEqual</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m[<span class="number">1001</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.size(); ++i) &#123;</span><br><span class="line">            ++m[target[i]];</span><br><span class="line">            --m[arr[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> all_of(begin(m), end(m), [](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x == <span class="number">0</span>; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
      </tags>
  </entry>
  <entry>
    <title>1528. Shuffle String</title>
    <url>/2021/01/18/1528-Shuffle-String/</url>
    <content><![CDATA[<p>类似快慢指针找cycle O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">restoreString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indices.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i != indices[i]) &#123; <span class="comment">// 只要当前位置不是正确的index就一直swap</span></span><br><span class="line">                swap(s[i], s[indices[i]]); <span class="comment">// 保持字符串跟indices数组同步即可</span></span><br><span class="line">                swap(indices[i], indices[indices[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>159. Longest Substring with At Most Two Distinct Characters</title>
    <url>/2021/01/18/159-Longest-Substring-with-At-Most-Two-Distinct-Characters/</url>
    <content><![CDATA[<p>O(n) time O(26) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            ++m[s[r]];</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; m.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--m[s[l]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    m.erase(s[l]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, r + <span class="number">1</span> - l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>lee的做法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; n; ++r) &#123;</span><br><span class="line">            ++m[s[r]];</span><br><span class="line">            <span class="keyword">if</span> (m.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--m[s[l]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    m.erase(s[l]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title>209. Minimum Size Subarray Sum</title>
    <url>/2021/01/18/209-Minimum-Size-Subarray-Sum/</url>
    <content><![CDATA[<p>sliding window O(n) 另外有个O(nlogn)的维护presum和map</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>, l = r; r &lt; n; ++r) &#123;</span><br><span class="line">            sum += nums[r];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s &amp;&amp; l &lt;= r) &#123; <span class="comment">// 这里必须是&lt;=因为单个数就有可能大于s</span></span><br><span class="line">                res = min(res, r + <span class="number">1</span> - l); <span class="comment">// 因为是求最短所以可以实时更新res</span></span><br><span class="line">                sum -= nums[l++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (res == INT_MAX ? <span class="number">0</span> : res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = l; l &lt; n; ++l) &#123;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; n &amp;&amp; sum &lt; s) &#123;</span><br><span class="line">                sum += nums[r++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= s) &#123;</span><br><span class="line">                res = min(res, r - l);</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (res == INT_MAX ? <span class="number">0</span> : res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
        <tag>Prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>188. Best Time to Buy and Sell Stock IV</title>
    <url>/2021/01/18/188-Best-Time-to-Buy-and-Sell-Stock-IV/</url>
    <content><![CDATA[<p>dp II跟III的结合版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; n / <span class="number">2</span>) &#123; <span class="comment">// 当k超过天数一半则不存在k个交易such that所有交易都不相邻，所以任意多个不相邻的交易的总数都不会超过k个</span></span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                res += max(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> diff = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    f[i][j] = max(f[i - <span class="number">1</span>][j] + diff, f[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = max(f[i - <span class="number">1</span>][j], j &gt; <span class="number">0</span> ? f[i - <span class="number">1</span>][j - <span class="number">1</span>] + diff : <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *max_element(f[n - <span class="number">1</span>].begin(), f[n - <span class="number">1</span>].end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; n / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                res += max(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">int</span> diff = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    f[j] = max(f[j] + diff, f[j - <span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[j] = max(f[j], j &gt; <span class="number">0</span> ? f[j - <span class="number">1</span>] + diff : <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *max_element(begin(f), end(f));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>Greedy</tag>
        <tag>Stock</tag>
      </tags>
  </entry>
  <entry>
    <title>235. Lowest Common Ancestor of a Binary Search Tree</title>
    <url>/2021/01/18/235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/</url>
    <content><![CDATA[<p>O(h)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">auto</span> [s, l] = minmax(p-&gt;val, q-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= root-&gt;val &amp;&amp; root-&gt;val &lt;= l) <span class="keyword">return</span> root; <span class="comment">// 注意等于的case，说明p和q一个是另一个的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; s) <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (l &lt; root-&gt;val) <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> [lo, hi] = minmax(p-&gt;val, q-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (lo &lt;= root-&gt;val &amp;&amp; root-&gt;val &lt;= hi) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> hi &lt; root-&gt;val ? lowestCommonAncestor(root-&gt;left, p, q) : lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Binary search tree</tag>
        <tag>Binary tree</tag>
        <tag>Preorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>285. Inorder Successor in BST</title>
    <url>/2021/01/18/285-Inorder-Successor-in-BST/</url>
    <content><![CDATA[<p>O(h) time O(h) space<br>递归版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt;= p-&gt;val) <span class="keyword">return</span> inorderSuccessor(root-&gt;right, p);</span><br><span class="line">        <span class="keyword">auto</span> l = inorderSuccessor(root-&gt;left, p);</span><br><span class="line">        <span class="keyword">return</span> l ? l : root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>循环版 O(h) time O(1) space<br>比p大的第一个节点要不是p的父节点（p是其父节点的左子）要不在p的右子树上，从root开始往下找，如果当前的root比p大，说明这个点有可能是p的父节点，即有可能是最终解，先存下来继续往下找，如果当前的root不比p大，说明这个点肯定不是最终解，最终解要不已经被存下来（之前的最近的父节点）要不就还在右子树上，则继续沿着右子树往下找，如果在右子树上找到了符合要求的（比p大的）节点，则存下来更新res，直到找到叶节点为止，复杂度就是树高</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        TreeNode *res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &lt;= p-&gt;val) &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = root;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>binary tree版本<br>O(n) time O(h) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        dfs(root, p-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root-&gt;left, v);</span><br><span class="line">        <span class="keyword">if</span> (res) <span class="keyword">return</span>; <span class="comment">// 找到就立即返回</span></span><br><span class="line">        <span class="keyword">if</span> (pre &amp;&amp; pre-&gt;val == v) &#123;</span><br><span class="line">            res = root;</span><br><span class="line">			<span class="keyword">return</span>; <span class="comment">// 找到就立即返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        dfs(root-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *pre = <span class="literal">nullptr</span>, *res = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">auto</span> l = inorderSuccessor(root-&gt;left, p);</span><br><span class="line">        <span class="keyword">if</span> (found_p &amp;&amp; !found_res) &#123;</span><br><span class="line">            found_res = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (found_p &amp;&amp; found_res) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == p-&gt;val) &#123;</span><br><span class="line">            found_p = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inorderSuccessor(root-&gt;right, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> found_p = <span class="literal">false</span>, found_res = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
        <tag>Depth first search</tag>
        <tag>Postorder traversal</tag>
        <tag>Binary search tree</tag>
        <tag>Binary tree</tag>
        <tag>Inorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>328. Odd Even Linked List</title>
    <url>/2021/01/18/328-Odd-Even-Linked-List/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>思路就是维护odd和even两个指针，扫一遍链表把odd跟even拆出来，最后odd跟even的head连起来即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> odd = head, even = odd-&gt;next, even_head = even;</span><br><span class="line">        <span class="keyword">while</span> (even &amp;&amp; even-&gt;next) &#123;</span><br><span class="line">            odd-&gt;next = even-&gt;next;</span><br><span class="line">            odd = odd-&gt;next;</span><br><span class="line">            even-&gt;next = odd-&gt;next;</span><br><span class="line">            even = even-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd-&gt;next = even_head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>346. Moving Average from Data Stream</title>
    <url>/2021/01/18/346-Moving-Average-from-Data-Stream/</url>
    <content><![CDATA[<p>O(1) time O(size) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MovingAverage(<span class="keyword">int</span> size) : n(size), sum(<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        q.push(val);</span><br><span class="line">        sum += val;</span><br><span class="line">        <span class="keyword">if</span> (q.size() &gt; n) &#123;</span><br><span class="line">            sum -= q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum / q.size(); <span class="comment">// 切记不能除n！！！因为queue里不一定有n个数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> sum;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MovingAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MovingAverage* obj = new MovingAverage(size);</span></span><br><span class="line"><span class="comment"> * double param_1 = obj-&gt;next(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>367. Valid Perfect Square</title>
    <url>/2021/01/18/367-Valid-Perfect-Square/</url>
    <content><![CDATA[<p>O(sqrt(n))<br>n<sup>2</sup> - (n - 1)<sup>2</sup> = (n + (n - 1)) * (n - (n - 1)) = 2n-1<br>e.g., 16 = 1 + 3 + 5 + 7</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; num &gt; <span class="number">0</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            num -= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用这个<br>O(logn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = num;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123; <span class="comment">// 小于等于可行，因为只需要找</span></span><br><span class="line">            <span class="keyword">long</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> p = m * m;</span><br><span class="line">            <span class="keyword">if</span> (p == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p &lt; num) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Newton method</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> x = num;</span><br><span class="line">        <span class="keyword">while</span> (x * x &gt; num) &#123;</span><br><span class="line">            x = (x + num / x) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x * x == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>392. Is Subsequence</title>
    <url>/2021/01/18/392-Is-Subsequence/</url>
    <content><![CDATA[<p>O(t.length)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = t.length(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; m &amp;&amp; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">i_t</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; c : s) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">i_t</span> &lt; t.length() &amp;&amp; t[<span class="keyword">i_t</span>] != c) ++<span class="keyword">i_t</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">i_t</span>++ &gt;= t.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>384. Shuffle an Array</title>
    <url>/2021/01/18/384-Shuffle-an-Array/</url>
    <content><![CDATA[<p>O(n) time O(n) space<br>证明：<br>任何一个元素a[i]出现在任何一个位置j的概率是1/n<br>三种情况讨论（直接用情况1足以）：</p>
<ol>
<li>i &lt; j P(i) = ((n - 1) / n) * ((n - 2) / (n - 1)) * … * (j / (j + 1)) * (1 / j) = (j / n) * (1 / j) = P(a[i]之前没放在位置j) * P(a[i]这次放在位置j) = 1 / n</li>
<li>i = j P(i) = (j / n) * (1 / j) = 1 / n</li>
<li>i &gt; j P(i) = (j / n) * (1 / j) = 1 / n</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums) : nums(nums) &#123;</span><br><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Resets the array to its original configuration and return it. */</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns a random shuffling of the array. */</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = nums;</span><br><span class="line">        <span class="keyword">int</span> n = res.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            swap(res[rand() % (i + <span class="number">1</span>)], res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj.reset();</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj.shuffle();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Random</tag>
      </tags>
  </entry>
  <entry>
    <title>430. Flatten a Multilevel Doubly Linked List</title>
    <url>/2021/01/18/430-Flatten-a-Multilevel-Doubly-Linked-List/</url>
    <content><![CDATA[<p>recursive O(n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _prev, Node* _next, Node* _child) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        prev = _prev;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        child = _child;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        Node dummy_head;</span><br><span class="line">        dummy_head.next = head;</span><br><span class="line">        helper(head);</span><br><span class="line">        <span class="keyword">return</span> dummy_head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">helper</span><span class="params">(Node *head)</span> </span>&#123; <span class="comment">// 返回处理以后的最后一个非空node</span></span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;child) &#123;</span><br><span class="line">            <span class="keyword">auto</span> succ = head-&gt;next;</span><br><span class="line">            head-&gt;next = head-&gt;child;</span><br><span class="line">            head-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">            head-&gt;next-&gt;prev = head;</span><br><span class="line">            <span class="keyword">auto</span> prev = helper(head-&gt;next);</span><br><span class="line">            prev-&gt;next = succ;</span><br><span class="line">            <span class="keyword">if</span> (succ) &#123;</span><br><span class="line">                succ-&gt;prev = prev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next ? helper(head-&gt;next) : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>iterative O(n) time<br>每个node访问两次</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _prev, Node* _next, Node* _child) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        prev = _prev;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        child = _child;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;child) &#123;</span><br><span class="line">                <span class="keyword">auto</span> succ = p-&gt;next;</span><br><span class="line">                p-&gt;next = p-&gt;child;</span><br><span class="line">                p-&gt;next-&gt;prev = p;</span><br><span class="line">                p-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">auto</span> tail = p-&gt;next;</span><br><span class="line">                <span class="keyword">while</span> (tail-&gt;next) &#123; <span class="comment">// 找到最后一个节点跟上一层断点连上</span></span><br><span class="line">                    tail = tail-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                tail-&gt;next = succ;</span><br><span class="line">                <span class="keyword">if</span> (succ) &#123;</span><br><span class="line">                    succ-&gt;prev = tail;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>69. Sqrt(x)</title>
    <url>/2021/01/18/69-Sqrt-x/</url>
    <content><![CDATA[<p>binary search O(logx)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> lo = <span class="number">0</span>, hi = x; <span class="comment">// 一定要从0开始</span></span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123; <span class="comment">// 这道题用小于比较好（&lt;=也行）因为不一定取到精确值</span></span><br><span class="line">            <span class="keyword">long</span> m = (lo + hi + <span class="number">1</span>) / <span class="number">2</span>, s = m * m; <span class="comment">// 注意必须是long防止溢出，并且要+1来取m</span></span><br><span class="line">            <span class="keyword">if</span> (s &lt;= x) &#123;</span><br><span class="line">                lo = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> min = <span class="number">0</span>, max = x;</span><br><span class="line">        <span class="keyword">while</span> (min &lt;= max) &#123; <span class="comment">// 一定是min &lt;= max而不是min &lt; max是因为最后一定要是min &gt; max来跳出循环，min == max是合法的</span></span><br><span class="line">            <span class="keyword">long</span> mid = (min + max) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> p = mid * mid;</span><br><span class="line">            <span class="keyword">if</span> (p == x) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p &lt; x) &#123;</span><br><span class="line">                min = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                max = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max; <span class="comment">// 是max而不是min是因为最后二分查找一定结束在一个较小的数上，比如5是2而不是3，10是3而不是4，而min一定要比max大才能跳出while循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>newton’s method O(logx)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> r = x;</span><br><span class="line">        <span class="keyword">while</span> (r * r &gt; x) &#123;</span><br><span class="line">            r = (r + x / r) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>double版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">s</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> lo = <span class="number">0</span>, hi = max(x, <span class="number">1.0</span>);</span><br><span class="line">	<span class="keyword">while</span> ((hi - lo) &gt; <span class="number">1e-8</span>) &#123;</span><br><span class="line">		<span class="keyword">auto</span> m = (lo + hi) / <span class="number">2</span>, p = m * m;</span><br><span class="line">		<span class="keyword">if</span> (p &lt;= x) &#123;</span><br><span class="line">			lo = m;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			hi = m;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
        <tag>Integer</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>53. Maximum Subarray</title>
    <url>/2021/01/18/53-Maximum-Subarray/</url>
    <content><![CDATA[<p>dp O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>, res = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            f = max(f, <span class="number">0</span>) + x;</span><br><span class="line">            res = max(res, f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>74. Search a 2D Matrix</title>
    <url>/2021/01/18/74-Search-a-2D-Matrix/</url>
    <content><![CDATA[<p>O(log(mn)) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size(), l = <span class="number">0</span>, r = m * n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> x = matrix[m / n][m % n];</span><br><span class="line">            <span class="keyword">if</span> (x == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; target) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>75. Sort Colors</title>
    <url>/2021/01/18/75-Sort-Colors/</url>
    <content><![CDATA[<p>双指针 O(n) time O(1) space<br>题目要求one-pass，所以从头开始往后扫，遇到0往前放，遇到2往后放<br>i0的左边都是0，i2的右边都是2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i0 = <span class="number">0</span>, i2 = n - <span class="number">1</span>; <span class="comment">// i0和i2分别表示下一个0和2要放的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= i2; ++i) &#123; <span class="comment">// 这里必须是&lt;=因为i2最后i和i2相遇时i2也要检查</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums[i], nums[i0++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                swap(nums[i--], nums[i2--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>865. Smallest Subtree with all the Deepest Nodes</title>
    <url>/2021/01/18/865-Smallest-Subtree-with-all-the-Deepest-Nodes/</url>
    <content><![CDATA[<p>O(n) time O(h) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">subtreeWithAllDeepest</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> depth)</span> </span>&#123; <span class="comment">// depth是从根到当前结点的深度，返回当前这棵树的深度</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = dfs(root-&gt;left, depth + <span class="number">1</span>); <span class="comment">// 子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> r = dfs(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (l == r &amp;&amp; depth + l &gt;= mx) &#123; <span class="comment">// find the lowest root that covers all the deepest leaves</span></span><br><span class="line">            mx = depth + l;</span><br><span class="line">            res = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *res = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">subtreeWithAllDeepest</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root).first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pair&lt;TreeNode *, int&gt; dfs(TreeNode *root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;root, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> l = dfs(root-&gt;left), r = dfs(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (l.second == r.second) <span class="keyword">return</span> &#123;root, l.second + <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (l.second &gt; r.second) <span class="keyword">return</span> &#123;l.first, l.second + <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;r.first, r.second + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Depth first search</tag>
        <tag>Postorder traversal</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>989. Add to Array-Form of Integer</title>
    <url>/2021/01/18/989-Add-to-Array-Form-of-Integer/</url>
    <content><![CDATA[<p>O(m+n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">addToArrayForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || c &gt; <span class="number">0</span> || K &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = i &gt;= <span class="number">0</span> ? A[i] : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> b = K % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> s = a + b + c;</span><br><span class="line">            c = s / <span class="number">10</span>;</span><br><span class="line">            res.push_back(s % <span class="number">10</span>);</span><br><span class="line">            --i;</span><br><span class="line">            K /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(rbegin(res), rend(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Addition</tag>
      </tags>
  </entry>
  <entry>
    <title>86. Partition List</title>
    <url>/2021/01/18/86-Partition-List/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode smaller, larger, *s = &amp;smaller, *l = &amp;larger;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt; x) &#123;</span><br><span class="line">                s-&gt;next = p;</span><br><span class="line">                s = s-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l-&gt;next = p;</span><br><span class="line">                l = l-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;next = larger.next;</span><br><span class="line">        l-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> smaller.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>993. Cousins in Binary Tree</title>
    <url>/2021/01/18/993-Cousins-in-Binary-Tree/</url>
    <content><![CDATA[<p>bfs O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCousins</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left &amp;&amp; t-&gt;right) &#123;</span><br><span class="line">                    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; temp&#123;t-&gt;left-&gt;val, t-&gt;right-&gt;val&#125;;</span><br><span class="line">                    <span class="keyword">if</span> (temp.count(x) &amp;&amp; temp.count(y)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果x和y共父，则非法</span></span><br><span class="line">                &#125;</span><br><span class="line">                s.insert(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left) &#123;</span><br><span class="line">                    q.push(t-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right) &#123;</span><br><span class="line">                    q.push(t-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.count(x) &amp;&amp; s.count(y)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 搜集当前层所有点，看x和y是不是都存在</span></span><br><span class="line">            <span class="keyword">if</span> (s.count(x) || s.count(y)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>105. Construct Binary Tree from Preorder and Inorder Traversal</title>
    <url>/2021/01/18/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</url>
    <content><![CDATA[<p>闭区间递归版 O(n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.size(); ++i) &#123;</span><br><span class="line">            m[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder, <span class="number">0</span>, preorder.size() - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;preorder, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inorder, <span class="keyword">int</span> il, <span class="keyword">int</span> ir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pl &gt; pr) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="keyword">new</span> TreeNode(preorder[pl]);</span><br><span class="line">        <span class="keyword">int</span> lpl = pl + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lir = m[preorder[pl]] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lil = il;</span><br><span class="line">        <span class="keyword">int</span> lpr = lpl + lir - lil;</span><br><span class="line">        res-&gt;left = helper(preorder, lpl, lpr, inorder, lil, lir);</span><br><span class="line">        <span class="keyword">int</span> rpl = lpr + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rpr = pr;</span><br><span class="line">        <span class="keyword">int</span> ril = lir + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> rir = ir;</span><br><span class="line">        res-&gt;right = helper(preorder, rpl, rpr, inorder, ril, rir);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>开区间递归memo版O(n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = begin(inorder); it != end(inorder); ++it) &#123;</span><br><span class="line">            m[*it] = it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(begin(preorder), end(preorder), begin(inorder), end(inorder));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> It = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">helper</span><span class="params">(It pb, It pe, It ib, It ie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pb == pe) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="keyword">new</span> TreeNode(*pb);</span><br><span class="line">        <span class="keyword">auto</span> it = m[*pb];</span><br><span class="line">        <span class="keyword">int</span> d = distance(ib, it);</span><br><span class="line">        res-&gt;left = helper(pb + <span class="number">1</span>, pb + d + <span class="number">1</span>, ib, it);</span><br><span class="line">        res-&gt;right = helper(pb + d + <span class="number">1</span>, pe, it + <span class="number">1</span>, ie);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, It&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>开区间递归版O(n<sup>2</sup>) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder.begin(), preorder.end(), inorder.begin(), inorder.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> Iter = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">helper</span><span class="params">(Iter pb, Iter pe, Iter ib, Iter ie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pb &gt;= pe || ib &gt;= ie) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> v = *pb;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">        <span class="keyword">auto</span> it = find(ib, ie, v);</span><br><span class="line">        <span class="keyword">int</span> dist = distance(ib, it);</span><br><span class="line">        root-&gt;left = helper(pb + <span class="number">1</span>, pb + dist + <span class="number">1</span>, ib, it);</span><br><span class="line">        root-&gt;right = helper(pb + dist + <span class="number">1</span>, pe, it + <span class="number">1</span>, ie);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>闭区间递归版O(n<sup>2</sup>) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pn = preorder.size(), in = inorder.size();</span><br><span class="line">        <span class="keyword">return</span> helper(preorder, <span class="number">0</span>, pn - <span class="number">1</span>, inorder, <span class="number">0</span>, in - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;p, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;i, <span class="keyword">int</span> il, <span class="keyword">int</span> ir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pl &gt; pr || il &gt; ir) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> v = p[pl];</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">        <span class="keyword">int</span> ri = il;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = il; j &lt;= ir; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i[j] == v) &#123;</span><br><span class="line">                ri = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = helper(p, pl + <span class="number">1</span>, pl + ri - il, i, il, ri - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = helper(p, pr + ri - ir + <span class="number">1</span>, pr, i, ri + <span class="number">1</span>, ir);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>112. Path Sum</title>
    <url>/2021/01/18/112-Path-Sum/</url>
    <content><![CDATA[<p>recursive dfs O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == sum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> root-&gt;val == sum;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>134. Gas Station</title>
    <url>/2021/01/18/134-Gas-Station/</url>
    <content><![CDATA[<p>greedy O(n)<br>能走完整个环的前提是gas的总量要大于cost的总量，这样才会有起点的存在。假设开始设置起点start = 0, 并从这里出发，如果当前的gas值大于cost值，就可以继续前进，此时到下一个站点，剩余的gas加上当前的gas再减去cost，看是否大于0，若大于0，则继续前进。当到达某一站点时，若这个值小于0了，则说明从0到这个点中间的任何一个点都不能作为起点，则把起点设为下一个点，继续遍历。当遍历完整个环时，当前保存的起点即为所求<br>证明用反证法，找total的反例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>, n = gas.size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            total += gas[i] - cost[i];</span><br><span class="line">            sum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                res = i + <span class="number">1</span>;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total &lt; <span class="number">0</span> ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;cost)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = gas.size();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        sum += (gas[i] - cost[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123; <span class="comment">// sum &lt; 0 means total gas &lt; total cost, cannot complete</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; n; ++j) &#123; <span class="comment">// start from i</span></span><br><span class="line">            sum += (gas[j] - cost[j]);</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>230. Kth Smallest Element in a BST</title>
    <url>/2021/01/18/230-Kth-Smallest-Element-in-a-BST/</url>
    <content><![CDATA[<p>dfs O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        dfs(root, k, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> &amp;k, <span class="keyword">int</span> &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root-&gt;left, k, res);</span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) &#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;right, k, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>follow up 给每个节点加一个count来记录当前节点这棵树的所有节点的个数，初始化为1，即只有根节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        TreeNodeWithCount *node = buildTree(root);</span><br><span class="line">        <span class="keyword">return</span> kthSmallest(node, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNodeWithCount</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        TreeNodeWithCount *left;</span><br><span class="line">        TreeNodeWithCount *right;</span><br><span class="line">        TreeNodeWithCount(<span class="keyword">int</span> x) : val(x), count(<span class="number">1</span>), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNodeWithCount * <span class="title">buildTree</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNodeWithCount *node = <span class="keyword">new</span> TreeNodeWithCount(root-&gt;val);</span><br><span class="line">        node-&gt;left = buildTree(root-&gt;left);</span><br><span class="line">        node-&gt;right = buildTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            node-&gt;count += node-&gt;left-&gt;count;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            node-&gt;count += node-&gt;right-&gt;count;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNodeWithCount *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left-&gt;count &gt;= k)</span><br><span class="line">                <span class="keyword">return</span> kthSmallest(root-&gt;left, k);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left-&gt;count == k - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root-&gt;right, k - <span class="number">1</span> - root-&gt;left-&gt;count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root-&gt;right, k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Binary search tree</tag>
        <tag>Binary tree</tag>
        <tag>Inorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>240. Search a 2D Matrix II</title>
    <url>/2021/01/18/240-Search-a-2D-Matrix-II/</url>
    <content><![CDATA[<p>左下到右上二分 O(m+n) time O(1) space<br>这道题跟<a href="https://leetcode.com/problems/search-a-2d-matrix/">74. Search a 2D Matrix</a>的区别是从左上到右下并非严格递增，所以不能直接用全矩阵二分（复杂度更低）不过这个方法是可以用到那道题上的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> r = m - <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[r][c] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[r][c] &gt; target) &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>303. Range Sum Query - Immutable</title>
    <url>/2021/01/18/303-Range-Sum-Query-Immutable/</url>
    <content><![CDATA[<p>O(1) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        presum.resize(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            presum[i + <span class="number">1</span>] = presum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> presum[j + <span class="number">1</span>] - presum[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; presum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>443. String Compression</title>
    <url>/2021/01/18/443-String-Compression/</url>
    <content><![CDATA[<p>考实现能力 O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = chars.size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i = j) &#123; <span class="comment">// 一次循环过后chars[j]已经跟chars[i]不一样，把i设成新的j</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; chars[j] == chars[i]) &#123; <span class="comment">// j从i开始往后找第一个跟chars[i]不一样的chars[j]</span></span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            chars[res++] = chars[i]; <span class="comment">// 写chars[i]</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> == j) <span class="keyword">continue</span>; <span class="comment">// 如果chars[i]只有一个字母，则不需要写个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : to_string(j - i)) &#123; <span class="comment">// 写字母个数</span></span><br><span class="line">                chars[res++] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>用write read anchor来控制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = chars.size();</span><br><span class="line">        <span class="keyword">int</span> w = <span class="number">0</span>, a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; ++r) &#123; <span class="comment">// 每次读一个字母</span></span><br><span class="line">            <span class="keyword">if</span> (r + <span class="number">1</span> == n || chars[r + <span class="number">1</span>] != chars[r]) &#123; <span class="comment">// 如果当前字母跟下一个字母不一样或者到头了</span></span><br><span class="line">                chars[w++] = chars[a]; <span class="comment">// 向指定位置写入锚点指向的字符</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt; a) &#123; <span class="comment">// 如果需要写入字符个数的话（&quot;a&quot;这种就不需要）</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> c : to_string(r + <span class="number">1</span> - a)) &#123; <span class="comment">// 统计字符个数并依次写入数字</span></span><br><span class="line">                        chars[w++] = c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                a = r + <span class="number">1</span>; <span class="comment">// 调整锚点到下一个不同的字符</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = chars.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n &amp;&amp; chars[j] == chars[i]; ++j, ++cnt);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c : to_string(cnt)) &#123;</span><br><span class="line">                    chars[++i] = c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">            chars[i] = chars[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>516. Longest Palindromic Subsequence</title>
    <url>/2021/01/18/516-Longest-Palindromic-Subsequence/</url>
    <content><![CDATA[<p>区间型dp O(n<sup>2</sup>) time O(n<sup>2</sup>) space<br>f[i][j]表示s[i:j]最长回文子序列的长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            f[i][i + <span class="number">1</span>] = (s[i] == s[i + <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = i + len; i &lt; n &amp;&amp; j &lt; n; ++i, ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    f[i][j] = <span class="number">2</span> + f[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = max(f[i][j - <span class="number">1</span>], f[i + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[j][i] = dp[j + <span class="number">1</span>][i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j][i] = max(dp[j + <span class="number">1</span>][i], dp[j][i - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>; <span class="comment">// dp[i]表示以s[i]为止的最长回文子序列的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">// len是s[i:j]两边exclusive（即s[i + 1 : j - 1]）之内的最长回文子序列的长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = dp[j]; <span class="comment">// 保存s[i + 1 : j]两边inclusive的最长回文子序列的长度</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[j] = len + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                len = max(len, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : dp) res = max(res, num);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>; <span class="comment">// 如果j = i + 1则j - 1 &lt; i + 1则dp[i + 1][j - 1]为0</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n<sup>2</sup>) time O(n) space<br>roll array</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> t = s;</span><br><span class="line">        reverse(t.begin(), t.end());</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[i - <span class="number">1</span>] == s[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i % <span class="number">2</span>][j] = dp[(i - <span class="number">1</span>) % <span class="number">2</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i % <span class="number">2</span>][j] = max(dp[i % <span class="number">2</span>][j - <span class="number">1</span>], dp[(i - <span class="number">1</span>) % <span class="number">2</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n % <span class="number">2</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n<sup>2</sup>) time O(n<sup>2</sup>) space<br>最长公共子序列的变种<br>s是正序，t是倒序，求s和t的最长公共子序列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> t = s;</span><br><span class="line">        reverse(t.begin(), t.end());</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[i - <span class="number">1</span>] == s[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>547. Number of Provinces</title>
    <url>/2021/01/18/547-Number-of-Provinces/</url>
    <content><![CDATA[<p>DFS O(n<sup>2</sup>)<br>n次标记，每次标记需要扫描n个city，递归深度最多为n<br>用这个版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        n = M.size();</span><br><span class="line">        visited.resize(n);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                visit(M, i);</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;M, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; ++v) &#123; <span class="comment">// 这里必须从0开始，因为访问u的时候，小于u的并不一定已经被访问过，为了dfs把所有相关的都访问到，必须从0开始</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; M[u][v]) &#123;</span><br><span class="line">                visit(M, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = M.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(M, i, visited);</span><br><span class="line">                ++count; <span class="comment">// 每run一次dfs就能找到一个cycle，此时update count</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;M, <span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M.size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[i][j] &amp;&amp; !visited[j]) &#123;</span><br><span class="line">                visited[j] = <span class="literal">true</span>;</span><br><span class="line">                dfs(M, j, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>union-find amortized O(n<sup>2</sup>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = M.size();</span><br><span class="line">        <span class="function">UF <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (M[i][j]) &#123;</span><br><span class="line">                    uf.merge(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UF</span> &#123;</span></span><br><span class="line">        UF(<span class="keyword">int</span> n) : count(n) &#123;</span><br><span class="line">            parent.resize(n);</span><br><span class="line">            iota(parent.begin(), parent.end(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getParent</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (parent[parent[x]] != parent[x]) &#123;</span><br><span class="line">                x = parent[x] = parent[parent[x]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> px = getParent(x);</span><br><span class="line">            <span class="keyword">int</span> py = getParent(y);</span><br><span class="line">            <span class="keyword">if</span> (px != py) &#123;</span><br><span class="line">                parent[px] = py;</span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title>572. Subtree of Another Tree</title>
    <url>/2021/01/18/572-Subtree-of-Another-Tree/</url>
    <content><![CDATA[<p>O(m+n) time O(m+n) space<br>前序遍历拼唯一可能的字符串再跑rolling hash版的字符串查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        dfs(s, ss);</span><br><span class="line">        dfs(t, st);</span><br><span class="line">        <span class="keyword">return</span> find(ss, st) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *p, <span class="built_in">string</span> &amp;s)</span> </span>&#123; <span class="comment">// 前序遍历拼字符串</span></span><br><span class="line">        <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">            s += <span class="string">&quot; #&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s += <span class="string">&quot; &quot;</span> + to_string(p-&gt;val);</span><br><span class="line">        dfs(p-&gt;left, s);</span><br><span class="line">        dfs(p-&gt;right, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> ss, st;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;haystack, <span class="keyword">const</span> <span class="built_in">string</span> &amp;needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = haystack.length(), n = needle.length();</span><br><span class="line">        <span class="keyword">long</span> M = INT_MAX, B = <span class="number">256</span>; <span class="comment">// INT_MAX是质数！</span></span><br><span class="line">        <span class="keyword">if</span> (h &lt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> highest_power = <span class="number">1</span>, hh = <span class="number">0</span>, nh = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            highest_power = (highest_power * B) % M;</span><br><span class="line">            nh = (nh * B + needle[i]) % M;</span><br><span class="line">            hh = (hh * B + haystack[i]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h - n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                hh = (hh * B + M - haystack[i - <span class="number">1</span>] * highest_power % M + haystack[i + n - <span class="number">1</span>]) % M; <span class="comment">// 这里highest_power是B的n次方，因为先整体左移再减高位，如果先减高位再整体左移就是n-1次方了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hh == nh &amp;&amp; haystack.substr(i, n) == needle) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(m<sup>2</sup>+n<sup>2</sup>+mn) time考虑到字符串拼接也要花时间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preorder(s).find(preorder(t)) != <span class="built_in">string</span>::npos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">preorder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span> + (root ? to_string(root-&gt;val) + preorder(root-&gt;left) + preorder(root-&gt;right) : <span class="string">&quot;#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(mn)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s &amp;&amp; t) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 防止s为空导致segv</span></span><br><span class="line">        <span class="keyword">return</span> isSame(s, t) || isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode *s, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s &amp;&amp; !t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s || !t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;val == t-&gt;val &amp;&amp; isSame(s-&gt;left, t-&gt;left) &amp;&amp; isSame(s-&gt;right, t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Binary tree</tag>
        <tag>Rolling hash</tag>
        <tag>Preorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>706. Design HashMap</title>
    <url>/2021/01/18/706-Design-HashMap/</url>
    <content><![CDATA[<p>O(n) time O(n) space<br>当数据量变大可以把链表改成红黑树提高性能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyHashMap() &#123;</span><br><span class="line">        m.resize(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** value will always be non-negative. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = find(key);</span><br><span class="line">        <span class="keyword">if</span> (it != end(m[key % n])) &#123;</span><br><span class="line">            it-&gt;second = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m[key % n].emplace_back(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = find(key);</span><br><span class="line">        <span class="keyword">return</span> it != end(m[key % n]) ? it-&gt;second : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = find(key);</span><br><span class="line">        <span class="keyword">if</span> (it != end(m[key % n])) &#123;</span><br><span class="line">            m[key % n].erase(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::<span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; lst = m[key % n];</span><br><span class="line">        <span class="keyword">auto</span> pred = [key](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p) &#123; <span class="keyword">return</span> key == p.first; &#125;;</span><br><span class="line">        <span class="keyword">return</span> find_if(begin(lst), end(lst), pred);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1001</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashMap* obj = new MyHashMap();</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;remove(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Data structure design</tag>
      </tags>
  </entry>
  <entry>
    <title>77. Combinations</title>
    <url>/2021/01/18/77-Combinations/</url>
    <content><![CDATA[<p>backtracking O(k*C(n, k)) time O(C(n, k)) space<br>这里时间要乘k是因为最后写到res里需要k步</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, k, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.size() == k) &#123;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt;= n &amp;&amp; v.size() + n - i + <span class="number">1</span> &gt;= k; ++i) &#123; <span class="comment">// 第二个终止条件是一个优化 表示剩余的数加到v里也不够k个则不再往下做了 可有可无 （当前是i之前已经查看了i -1个数放了v.size()个数 所以是v.size() + n - (i - 1)要至少为k）</span></span><br><span class="line">            v.push_back(i);</span><br><span class="line">            dfs(i + <span class="number">1</span>, k, n);</span><br><span class="line">            v.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>iterative</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            res.push_back(&#123;i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;v : res) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v.back() &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">                    t.push_back(v);</span><br><span class="line">                    t.back().push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            t.swap(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
        <tag>Combination</tag>
      </tags>
  </entry>
  <entry>
    <title>111. Minimum Depth of Binary Tree</title>
    <url>/2021/01/19/111-Minimum-Depth-of-Binary-Tree/</url>
    <content><![CDATA[<p>跟<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a>对比<br>这道题要特别注意一个corner case<br>[1,2]的mindepth是2不是1<br>所以不能简单的一行递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = minDepth(root-&gt;left), r = minDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left) <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;right ? min(l, r) + <span class="number">1</span> : l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            res = min(res, minDepth(root-&gt;left));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            res = min(res, minDepth(root-&gt;right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Postorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>116. Populating Next Right Pointers in Each Node</title>
    <url>/2021/01/19/116-Populating-Next-Right-Pointers-in-Each-Node/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        Node dummy, *p = &amp;dummy, *res = root;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">                p-&gt;next = root-&gt;left;</span><br><span class="line">                root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">                p = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">                root = dummy.next;</span><br><span class="line">                dummy.next = <span class="literal">nullptr</span>;</span><br><span class="line">                p = &amp;dummy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>直接用<a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">117. Populating Next Right Pointers in Each Node II</a>的方法也行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        Node dummy, *p = &amp;dummy, *res = root;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">                p-&gt;next = root-&gt;left;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                p-&gt;next = root-&gt;right;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">                root = dummy.next;</span><br><span class="line">                dummy.next = <span class="literal">nullptr</span>;</span><br><span class="line">                p = &amp;dummy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n) time O(h) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        Node dummy_head, *tail = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = root; p; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                tail-&gt;next = p-&gt;left;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tail-&gt;next) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                tail-&gt;next = p-&gt;right;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tail-&gt;next) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line">        connect(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Binary tree</tag>
        <tag>Preorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>117. Populating Next Right Pointers in Each Node II</title>
    <url>/2021/01/19/117-Populating-Next-Right-Pointers-in-Each-Node-II/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        Node dummy, *p = &amp;dummy, *res = root;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">                p-&gt;next = root-&gt;left;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                p-&gt;next = root-&gt;right;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;next; <span class="comment">// 假设上一层已经连完了</span></span><br><span class="line">            <span class="keyword">if</span> (!root) &#123; <span class="comment">// 到头了</span></span><br><span class="line">                root = dummy.next; <span class="comment">// 设成下一层起始</span></span><br><span class="line">                dummy.next = <span class="literal">nullptr</span>; <span class="comment">// 重置dummy和p</span></span><br><span class="line">                p = &amp;dummy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dfs O(n) time O(h) space<br>从上往下连，从右往左连，因为上边的连好了下边的才能利用上边的连，右边的连好了左边的才不会连错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        Node dummy_head(0, nullptr, nullptr, nullptr), *tail = &amp;dummy_head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = root; p; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                tail-&gt;next = p-&gt;left;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tail-&gt;next) <span class="keyword">break</span>; <span class="comment">// 已经连上的没必要再连一遍</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                tail-&gt;next = p-&gt;right;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tail-&gt;next) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line">        connect(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        TreeLinkNode dummy_head(0), *curr = &amp;dummy_head; // 利用dummy_head实现『盲连』，即避免不必要的节点判断</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = root; p; p = p-&gt;next) &#123; <span class="comment">// suppose当前层已经连好了，只需要把子一层的都连起来</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                curr-&gt;next = p-&gt;left;</span><br><span class="line">                curr = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                curr-&gt;next = p-&gt;right;</span><br><span class="line">                curr = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line">        connect(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root-&gt;left-&gt;next = next(root-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            root-&gt;right-&gt;next = next(root-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        connect(root-&gt;right); <span class="comment">// 一定要先右后左！！！！！先左后右有一些会没连上</span></span><br><span class="line">        connect(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeLinkNode *<span class="title">next</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            root = root-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Binary tree</tag>
        <tag>Preorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>122. Best Time to Buy and Sell Stock II</title>
    <url>/2021/01/19/122-Best-Time-to-Buy-and-Sell-Stock-II/</url>
    <content><![CDATA[<p>greedy O(n) time O(1) space<br>只要挣钱（后一天比前一天价格高）就买进卖出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res += max(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>141. Linked List Cycle</title>
    <url>/2021/01/19/141-Linked-List-Cycle/</url>
    <content><![CDATA[<p>快慢指针O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 因为slow和fast都是从head开始，所以不能把这个判断条件放在最开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">auto</span> slow = head, fast = head;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next &amp;&amp; slow != fast);</span><br><span class="line">        <span class="keyword">return</span> slow == fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">auto</span> slow = head, fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next &amp;&amp; slow != fast) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow == fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
        <tag>Hare and tortoise</tag>
      </tags>
  </entry>
  <entry>
    <title>145. Binary Tree Postorder Traversal</title>
    <url>/2021/01/19/145-Binary-Tree-Postorder-Traversal/</url>
    <content><![CDATA[<p>O(n) time O(h) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">pair</span>&lt;TreeNode *, <span class="keyword">bool</span>&gt;&gt; s;</span><br><span class="line">        s.emplace(root, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, v] = s.top(); s.pop();</span><br><span class="line">            <span class="keyword">if</span> (!x) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (v) &#123;</span><br><span class="line">                res.push_back(x-&gt;val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.emplace(x, <span class="literal">true</span>);</span><br><span class="line">                s.emplace(x-&gt;right, <span class="literal">false</span>);</span><br><span class="line">                s.emplace(x-&gt;left, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Postorder traversal</tag>
        <tag>Stack</tag>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>160. Intersection of Two Linked Lists</title>
    <url>/2021/01/19/160-Intersection-of-Two-Linked-Lists/</url>
    <content><![CDATA[<p>O(m+n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> n1 = headA, n2 = headB;</span><br><span class="line">        <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">            n1 = n1 ? n1-&gt;next : headB; <span class="comment">// 注意要判断n1是不是为空，最后有可能根本没有交点，则两个指针都落在nullptr上</span></span><br><span class="line">            n2 = n2 ? n2-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果有cycle又不能用hashmap</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Node(<span class="keyword">int</span> x) : val(x) &#123;&#125;</span><br><span class="line">    Node *next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getCycle</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fast = head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!fast || !fast-&gt;next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(Node *headA, Node *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = getCycle(headA), b = getCycle(headB);</span><br><span class="line">    <span class="keyword">if</span> (a &amp;&amp; b) <span class="keyword">return</span> a == b;</span><br><span class="line">    <span class="keyword">if</span> (!a &amp;&amp; !b) &#123;</span><br><span class="line">        <span class="keyword">while</span> (headA != headB) &#123;</span><br><span class="line">            headA = headA ? headA-&gt;next : headB;</span><br><span class="line">            headB = headB ? headB-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>191. Number of 1 Bits</title>
    <url>/2021/01/19/191-Number-of-1-Bits/</url>
    <content><![CDATA[<p>常规数1法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res += (n &amp; <span class="number">1</span>);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>翻转最后一个1法<br>这个比较通用，不受n正负的影响</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            n &amp;= (n - <span class="number">1</span>); <span class="comment">// 把最低位的1变成0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>205. Isomorphic Strings</title>
    <url>/2021/01/19/205-Isomorphic-Strings/</url>
    <content><![CDATA[<p>O(n) time O(128) space<br>normalize</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ms[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;, mt[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ms[s[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                ms[s[i]] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mt[t[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                mt[t[i]] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ms[s[i]] != mt[t[i]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
      </tags>
  </entry>
  <entry>
    <title>208. Implement Trie (Prefix Tree)</title>
    <url>/2021/01/19/208-Implement-Trie-Prefix-Tree/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        TrieNode() : children(&#123;<span class="literal">nullptr</span>&#125;), isEnd(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        TrieNode *children[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">bool</span> isEnd;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TrieNode *root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : word) &#123;</span><br><span class="line">            p = p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : prefix) &#123;</span><br><span class="line">            p = p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>210. Course Schedule II</title>
    <url>/2021/01/19/210-Course-Schedule-II/</url>
    <content><![CDATA[<p>topological sort<br>bfs O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span> <span class="keyword">int</span> indeg = <span class="number">0</span>; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; children; &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numCourses;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;P&gt; <span class="title">courses</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; zero_indeg;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) zero_indeg.insert(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : prerequisites) &#123;</span><br><span class="line">            courses[p.second].children.push_back(p.first);</span><br><span class="line">            ++courses[p.first].indeg;</span><br><span class="line">            zero_indeg.erase(p.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!zero_indeg.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = *zero_indeg.begin();</span><br><span class="line">            res.push_back(c);</span><br><span class="line">            zero_indeg.erase(c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> child : courses[c].children) &#123;</span><br><span class="line">                --courses[child].indeg;</span><br><span class="line">                <span class="keyword">if</span> (courses[child].indeg == <span class="number">0</span>) &#123;</span><br><span class="line">                    zero_indeg.insert(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.size() &lt; n) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dfs O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        n = numCourses;</span><br><span class="line">        visited.resize(n);</span><br><span class="line">        g.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : prerequisites) &#123;</span><br><span class="line">            g[p[<span class="number">1</span>]].push_back(p[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(i)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(rbegin(s), rend(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[c] != <span class="number">0</span>) <span class="keyword">return</span> visited[c] == <span class="number">-1</span>;</span><br><span class="line">        visited[c] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> child : g[c]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(child)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[c] = <span class="number">1</span>;</span><br><span class="line">        s.push_back(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        n = numCourses;</span><br><span class="line">        visited.resize(n);</span><br><span class="line">        g.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : prerequisites) &#123;</span><br><span class="line">            g[p.second].push_back(p.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(i)) <span class="keyword">return</span> &#123;&#125;; <span class="comment">// true意味着有圈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            res.push_back(s.top());</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[c] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 1表示无圈已访问过，0表示未访问，-1表示不知道有没有圈但是已访问过</span></span><br><span class="line">        <span class="keyword">if</span> (visited[c] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// -1说明有圈</span></span><br><span class="line">        visited[c] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> child : g[c]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(child)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[c] = <span class="number">1</span>;</span><br><span class="line">        s.push(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Depth first search</tag>
        <tag>Topological sort</tag>
      </tags>
  </entry>
  <entry>
    <title>221. Maximal Square</title>
    <url>/2021/01/19/221-Maximal-Square/</url>
    <content><![CDATA[<p>dp O(mn) time O(m) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = dp[j];</span><br><span class="line">                <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dp[j] = min(dp[j - <span class="number">1</span>], min(dp[j], pre)) + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res, dp[j]);</span><br><span class="line">                pre = t; <span class="comment">// 用pre来cache同一行之前需要计算的值，即f[i][j - 1]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp + rolling array O(mn) time O(m) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dp[i % <span class="number">2</span>][j] = min(dp[i % <span class="number">2</span>][j - <span class="number">1</span>], min(dp[(i - <span class="number">1</span>) % <span class="number">2</span>][j], dp[(i - <span class="number">1</span>) % <span class="number">2</span>][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i % <span class="number">2</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res, dp[i % <span class="number">2</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp O(mn) time O(mn) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = min(&#123;dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]&#125;) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>242. Valid Anagram</title>
    <url>/2021/01/19/242-Valid-Anagram/</url>
    <content><![CDATA[<p>hashmap O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            ++f[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--f[c] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size(s) != size(t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> f[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size(s); ++i) &#123;</span><br><span class="line">            ++f[s[i]];</span><br><span class="line">            --f[t[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> all_of(f, f + <span class="number">256</span>, [](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x == <span class="number">0</span>; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Follow up</strong></p>
<p>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>
<p><strong>Answer</strong></p>
<p>Use a hash table instead of a fixed size counter. Imagine allocating a large size array to fit the entire range of unicode characters, which could go up to more than 1 million. A hash table is a more generic solution and could adapt to any range of characters.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
      </tags>
  </entry>
  <entry>
    <title>350. Intersection of Two Arrays II</title>
    <url>/2021/01/19/350-Intersection-of-Two-Arrays-II/</url>
    <content><![CDATA[<p>O(m + n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums1) &#123;</span><br><span class="line">            ++m[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[n] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                --m[n];</span><br><span class="line">                res.push_back(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>follow up #1<br>双指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="comment">//sort(begin(nums1), end(nums1));</span></span><br><span class="line">        <span class="comment">//sort(begin(nums2), end(nums2));</span></span><br><span class="line">        <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m &amp;&amp; j &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                res.push_back(nums1[i]);</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用这个，用iterator会清楚很多也好写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        sort(begin(nums1), end(nums1));</span><br><span class="line">        sort(begin(nums2), end(nums2));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, m = size(nums1), n = size(nums2); i &lt; m &amp;&amp; j &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                res.push_back(nums1[i]);</span><br><span class="line">                ++i, ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                i = lower_bound(begin(nums1) + i + <span class="number">1</span>, end(nums1), nums2[j]) - begin(nums1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = lower_bound(begin(nums2) + j + <span class="number">1</span>, end(nums2), nums1[i]) - begin(nums2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>follow up #2<br>O(min(m,n)log(max(m,n)))</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        sort(nums1.begin(), nums1.end());</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">        <span class="keyword">auto</span> &amp;&amp;s = m &lt; n ? nums1 : nums2;</span><br><span class="line">        <span class="keyword">auto</span> &amp;&amp;l = m &lt; n ? nums2 : nums1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">auto</span> it = l.begin();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : s) &#123;</span><br><span class="line">            it = lower_bound(it, l.end(), x);</span><br><span class="line">            <span class="keyword">if</span> (it == l.end()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*it == x) &#123;</span><br><span class="line">                res.push_back(x);</span><br><span class="line">                ++it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>if m &lt;&lt; n, O(min(m,n)log(max(m,n))) is close to O(logn) while O(m+n) is close to O(n)</p>
<p>follow up #3</p>
<ul>
<li>If only nums2 cannot fit in memory, put all elements of nums1 into a HashMap, read chunks of array that fit into the memory, and record the intersections.</li>
<li>If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually (external sort), then read 2 elements from each array at a time in memory, record intersections. (similar to merge)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        sort(nums1.begin(), nums1.end());</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m &amp;&amp; j &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                res.push_back(nums1[i]);</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>another approach is to build index for sorted nums2, if nums2 is [1,2,3,4,5,6,7,8,9,10], we can build index [1:address, 3:address, 5:address, 7:address, 9:address], and put the indices in memory, each time we search the indices first and locate the chunk address in disk, then load the chunk in memory and do another round binary search of the chunk. the size of chunk must fit in the memory (indices are built based on this). because there might be some dup numbers, we can maintain a hashmap (or bloomfilter) in memory to tell how many dup numbers has already been searched (i.e., nums2 has only 4 number 5s but nums1 has 6 number 5s then the last 2 searches for number 5 will be aborted).</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two pointers</tag>
        <tag>Hash table</tag>
      </tags>
  </entry>
  <entry>
    <title>414. Third Maximum Number</title>
    <url>/2021/01/19/414-Third-Maximum-Number/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>要确认第三大指的是第三大不同的数还是相同也行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> x : nums) &#123;</span><br><span class="line">            s.insert(x);</span><br><span class="line">            <span class="keyword">if</span> (size(s) &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                s.erase(begin(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size(s) &lt; <span class="number">3</span> ? *rbegin(s) : *begin(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> mx1 = LONG_MIN, mx2 = LONG_MIN, mx3 = LONG_MIN; <span class="comment">// 必须是long否则最后无法区分，反例[1, 2, INT_MIN]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; mx1) &#123;</span><br><span class="line">                mx3 = mx2;</span><br><span class="line">                mx2 = mx1;</span><br><span class="line">                mx1 = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == mx1) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; mx2) &#123;</span><br><span class="line">                mx3 = mx2;</span><br><span class="line">                mx2 = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == mx2) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; mx3) &#123; <span class="comment">// 注意不是else，是else if</span></span><br><span class="line">                mx3 = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mx3 == LONG_MIN ? mx1 : mx3; <span class="comment">// 这一行很重要 因为有可能不同的数不足3个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>509. Fibonacci Number</title>
    <url>/2021/01/19/509-Fibonacci-Number/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>57. Insert Interval</title>
    <url>/2021/01/19/57-Insert-Interval/</url>
    <content><![CDATA[<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; insert(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, n = intervals.size();</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n &amp;&amp; intervals[i][<span class="number">0</span>] &lt; newInterval[<span class="number">0</span>]; ++i) &#123;</span><br><span class="line">            res.push_back(intervals[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!res.empty() &amp;&amp; newInterval[<span class="number">0</span>] &lt;= res.back()[<span class="number">1</span>]) &#123;</span><br><span class="line">            res.back()[<span class="number">1</span>] = max(res.back()[<span class="number">1</span>], newInterval[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push_back(newInterval);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= res.back()[<span class="number">1</span>]) &#123;</span><br><span class="line">                res.back()[<span class="number">1</span>] = max(res.back()[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Interval&gt; <span class="title">insert</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals, Interval newInterval)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n &amp;&amp; intervals[i].start &lt; newInterval.start; ++i) &#123;</span><br><span class="line">            res.push_back(intervals[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!res.empty() &amp;&amp; newInterval.start &lt;= res.back().end) &#123;</span><br><span class="line">            res.back().end = max(res.back().end, newInterval.end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push_back(newInterval);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[j].start &lt;= res.back().end) &#123;</span><br><span class="line">                res.back().end = max(res.back().end, intervals[j].end);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(intervals[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>617. Merge Two Binary Trees</title>
    <url>/2021/01/19/617-Merge-Two-Binary-Trees/</url>
    <content><![CDATA[<p>O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t1 &amp;&amp; !t2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (!t1) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (!t2) <span class="keyword">return</span> t1;</span><br><span class="line">        t1-&gt;val += t2-&gt;val;</span><br><span class="line">        t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">        t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Binary tree</tag>
        <tag>Preorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>62. Unique Paths</title>
    <url>/2021/01/19/62-Unique-Paths/</url>
    <content><![CDATA[<p>dp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row(<span class="number">1</span>); row &lt; m; ++row)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col(<span class="number">1</span>); col &lt; n; ++col)</span><br><span class="line">                ret[row][col] = ret[row - <span class="number">1</span>][col] + ret[row][col - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> ret[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>64. Minimum Path Sum</title>
    <url>/2021/01/19/64-Minimum-Path-Sum/</url>
    <content><![CDATA[<p>dp O(mn) time O(mn) space<br>需要注意边界条件<br>f[0][0] = grid[0][0]<br>f[0][j] = f[0][j - 1] + grid[0][j]<br>f[i][0] = f[i - 1][0] + grid[i][0]<br>f[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i][j]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty() || grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, INT_MAX));</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 这行必须有</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                f[i][j] = min(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(mn) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty() || grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                f[j] = min(f[j], f[j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            f[<span class="number">0</span>] = INT_MAX; <span class="comment">// 只有最开始f[0] = 0后边都是INT_MAX</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>665. Non-decreasing Array</title>
    <url>/2021/01/19/665-Non-decreasing-Array/</url>
    <content><![CDATA[<p>O(n)<br>这道题给了我们一个数组，说我们最多有1次修改某个数字的机会，问能不能将数组变为非递减数组。题目中给的例子太少，不能覆盖所有情况，我们再来看下面三个例子：</p>
<p>4，2，3</p>
<p>-1，4，2，3</p>
<p>2，3，3，2，4</p>
<p>我们通过分析上面三个例子可以发现，当我们发现后面的数字小于前面的数字产生冲突后，有时候需要修改前面较大的数字(比如前两个例子需要修改4)，有时候却要修改后面较小的那个数字(比如前第三个例子需要修改2)，那么有什么内在规律吗？是有的，判断修改那个数字其实跟再前面一个数的大小有关系，首先如果再前面的数不存在，比如例子1，4前面没有数字了，我们直接修改前面的数字为当前的数字2即可。而当再前面的数字存在，并且小于当前数时，比如例子2，-1小于2，我们还是需要修改前面的数字4为当前数字2；如果再前面的数大于当前数，比如例子3，3大于2，我们需要修改当前数2为前面的数3。这是修改的情况，由于我们只有一次修改的机会，所以用一个变量cnt，初始化为0，修改数字后cnt自增1，当下次再需要修改时，如果cnt已经为1了，直接返回false。遍历结束后返回true</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span> &amp;&amp; cnt &lt;= <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] &gt; nums[i + <span class="number">1</span>]) &#123; <span class="comment">// 如果前两个数都比nums[i + 1]大，说明nums[i + 1]是一个valley，调整至跟nums[i]一样再继续扫描</span></span><br><span class="line">                    nums[i + <span class="number">1</span>] = nums[i];</span><br><span class="line">                &#125; <span class="comment">// 否则nums[i]是一个peak</span></span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>72. Edit Distance</title>
    <url>/2021/01/19/72-Edit-Distance/</url>
    <content><![CDATA[<p>dp O(n<sup>2</sup>) time O(n) space rolling array</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word1.length(), m = word2.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i; <span class="comment">// 添加字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = i &amp; <span class="number">1</span>;</span><br><span class="line">            dp[k][<span class="number">0</span>] = i; <span class="comment">// 删除字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[k][j] = dp[k ^ <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[k][j] = min(&#123;dp[k ^ <span class="number">1</span>][j - <span class="number">1</span>], dp[k][j - <span class="number">1</span>], dp[k ^ <span class="number">1</span>][j]&#125;) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n &amp; <span class="number">1</span>][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp O(n<sup>2</sup>) time O(n<sup>2</sup>) space<br>dp[i][j]表示word1[0:i]变成word2[0:j]最少需要多少步</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word1.length(), m = word2.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123; <span class="comment">// 当两个字符相同时什么都不用做，dp[i - 1][j - 1] &lt; dp[i][j - 1] + 1和dp[i - 1][j] + 1所以一定是dp[i - 1][j - 1]</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = min(&#123;dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]&#125;) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>104. Maximum Depth of Binary Tree</title>
    <url>/2021/01/20/104-Maximum-Depth-of-Binary-Tree/</url>
    <content><![CDATA[<p>dfs O(n) time O(h) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root ? max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Postorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>101. Symmetric Tree</title>
    <url>/2021/01/20/101-Symmetric-Tree/</url>
    <content><![CDATA[<p>recursive dfs O(n)<br>判断对应子树一样即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !root || isMirror(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode *l, TreeNode *r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!l || !r || l-&gt;val != r-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isMirror(l-&gt;left, r-&gt;right) &amp;&amp; isMirror(l-&gt;right, r-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>iterative bfs O(n)<br>trick是用一个queue放两个root，然后对于一对left和right分别push left的left，right的right，left的right，right的left</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> l = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">auto</span> r = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (!l &amp;&amp; !r) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!l || !r || l-&gt;val != r-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q.push(l-&gt;left);</span><br><span class="line">            q.push(r-&gt;right);</span><br><span class="line">            q.push(l-&gt;right);</span><br><span class="line">            q.push(r-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>follow up 如果left or right pointer can point to any node in tree<br>必须要一一对应，要不就是自己</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;TreeNode *, TreeNode *&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode *l, TreeNode *r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!l) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (m.count(l)) <span class="keyword">return</span> m[l] == l;</span><br><span class="line">        m[l] = l;</span><br><span class="line">        <span class="keyword">return</span> isMirror(l-&gt;left, l-&gt;right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!l || !r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!m.count(l) &amp;&amp; !m.count(r)) &#123;</span><br><span class="line">            m[l] = r;</span><br><span class="line">            m[r] = l;</span><br><span class="line">            <span class="keyword">return</span> isMirror(l-&gt;left, r-&gt;right) &amp;&amp; isMirror(l-&gt;right, r-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m.count(l) &amp;&amp; m.count(r) &amp;&amp; m[l] == r &amp;&amp; m[r] == l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
        <tag>Depth first search</tag>
        <tag>Binary tree</tag>
        <tag>Preorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>108. Convert Sorted Array to Binary Search Tree</title>
    <url>/2021/01/20/108-Convert-Sorted-Array-to-Binary-Search-Tree/</url>
    <content><![CDATA[<p>preorder O(n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(begin(nums), end(nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator Iter;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">sortedArrayToBST</span><span class="params">(Iter b, Iter e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == e) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> m = b + (e - b) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="keyword">new</span> TreeNode(*m);</span><br><span class="line">        res-&gt;left = sortedArrayToBST(b, m);</span><br><span class="line">        res-&gt;right = sortedArrayToBST(m + <span class="number">1</span>, e);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
        <tag>Binary search tree</tag>
        <tag>Binary tree</tag>
        <tag>Preorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>268. Missing Number</title>
    <url>/2021/01/20/268-Missing-Number/</url>
    <content><![CDATA[<p>O(n) time O(1) space<br>利用下标从0到n，把所有数异或最后剩下的就是差的数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> res = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res ^= (i ^ nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>334. Increasing Triplet Subsequence</title>
    <url>/2021/01/20/334-Increasing-Triplet-Subsequence/</url>
    <content><![CDATA[<p>O(n)<br>把这道题转换成类似找第一小第二小第三小的数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">increasingTriplet</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a1 = INT_MAX, a2 = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= a1) &#123;</span><br><span class="line">                a1 = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt;= a2) &#123;</span><br><span class="line">                a2 = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>94. Binary Tree Inorder Traversal</title>
    <url>/2021/01/20/94-Binary-Tree-Inorder-Traversal/</url>
    <content><![CDATA[<p>iterative stack O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">pair</span>&lt;TreeNode *, <span class="keyword">bool</span>&gt;&gt; s;</span><br><span class="line">        s.emplace(root, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [n, v] = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span> (!n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (v) &#123;</span><br><span class="line">                res.push_back(n-&gt;val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.emplace(n-&gt;right, <span class="literal">false</span>);</span><br><span class="line">                s.emplace(n, <span class="literal">true</span>);</span><br><span class="line">                s.emplace(n-&gt;left, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>recursive O(n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        dfs(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root-&gt;left, res);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : inorderTraversal(root-&gt;left)) &#123;</span><br><span class="line">            res.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : inorderTraversal(root-&gt;right)) &#123;</span><br><span class="line">            res.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
        <tag>Inorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>55. Jump Game</title>
    <url>/2021/01/20/55-Jump-Game/</url>
    <content><![CDATA[<p>greedy O(n) time - best!<br>计算每个位置所能到达的最远的位置（选择最远的，即贪心），并维护一个全局当前可以到达的最远位置，如果当前的位置比当前的全局可以到达的最远位置还要远，证明当前位置无法达到，那么最后一个位置也不可能从第一个位置到达</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, curr_max = <span class="number">0</span>; i &lt; n &amp;&amp; curr_max &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; curr_max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            curr_max = max(curr_max, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>dp O(n<sup>2</sup>) time O(n) space TLE<br>问题：n是否可以跳到<br>最后一步：从i跳到n-1，需要满足i + A[i] &gt;= n - 1并且i可以跳到<br>子问题：i是否可以跳到<br>状态转移方程：f[i] = f[j] &amp;&amp; j + A[j] &gt;= i where 0 &lt;= j &lt; i<br>初始条件：f[0] = true</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[j] &amp;&amp; j + nums[j] &gt;= i) &#123;</span><br><span class="line">                    f[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>322. Coin Change</title>
    <url>/2021/01/20/322-Coin-Change/</url>
    <content><![CDATA[<p>knapsack O(mn) time O(m) space<br>问题是累加到amount最少需要多少个coin<br>假设最终是a0 + a1 + a2 + … + ak = amount<br>最后一步：ak是最后一个coin（可能是任何一种币值coins[j]）<br>之前一步：a0 + a1 + a2 + … + ak-1 = amount - ak<br>问题变成：求累加到amount - ak最少需要多少个coin<br>从f[amount]变成f[amount - ak]，f[i]表示累加到i最少需要多少个coin<br>状态转移方程：f[i] = min(f[i-coins[j]] + 1) where 0 &lt;= j &lt; n &amp;&amp; i &gt;= coins[j]<br>初始条件：f[0] = 0<br>最终要求的：f[amount]<br>边界条件：如果某个f[x]不能由任何coin组合，则其值为INT_MAX（也可以用amount + 1来代替避免overflow）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coins.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= coins[j] &amp;&amp; f[i - coins[j]] != INT_MAX) &#123;</span><br><span class="line">                    f[i] = min(f[i], f[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[amount] == INT_MAX ? <span class="number">-1</span> : f[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coins.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= coins[j]) &#123;</span><br><span class="line">                    f[i] = min(f[i], f[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[amount] &gt;= amount + <span class="number">1</span> ? <span class="number">-1</span> : f[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>knapsack</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c : coins) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= c) &#123;</span><br><span class="line">                    f[i] = min(f[i], f[i - c] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[amount] &gt; amount ? <span class="number">-1</span> : f[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c : coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = c; i &lt;= amount; ++i) &#123;</span><br><span class="line">                f[i] = min(f[i], f[i - c] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[amount] &gt; amount ? <span class="number">-1</span> : f[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>Knapsack</tag>
      </tags>
  </entry>
  <entry>
    <title>131. Palindrome Partitioning</title>
    <url>/2021/01/20/131-Palindrome-Partitioning/</url>
    <content><![CDATA[<p>backtracking O(n*2<sup>n</sup>) time 即worst case “aaa”<br>预处理isPalin剪枝提速</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        n = s.length();</span><br><span class="line">        isPalin.resize(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">        computeIsPalin(s);</span><br><span class="line">        dfs(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">computeIsPalin</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            isPalin[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            isPalin[i][i + <span class="number">1</span>] = (s[i] == s[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = i + len; i &lt; n &amp;&amp; j &lt; n; ++i, ++j) &#123;</span><br><span class="line">                isPalin[i][j] = isPalin[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i] == s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string_view s, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == n) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">vs</span><span class="params">(begin(v), end(v))</span></span>;</span><br><span class="line">            res.push_back(move(vs));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalin[b][i]) &#123;</span><br><span class="line">                v.push_back(s.substr(b, i + <span class="number">1</span> - b));</span><br><span class="line">                dfs(s, i + <span class="number">1</span>);</span><br><span class="line">                v.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;string_view&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; isPalin;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        isPalin.resize(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">        computeIsPalin(s);</span><br><span class="line">        dfs(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">computeIsPalin</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            isPalin[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            isPalin[i][i + <span class="number">1</span>] = (s[i] == s[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = i + len; i &lt; n &amp;&amp; j &lt; n; ++i, ++j) &#123;</span><br><span class="line">                isPalin[i][j] = isPalin[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i] == s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == s.length()) &#123;</span><br><span class="line">            res.push_back(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalin[b][i]) &#123;</span><br><span class="line">                v.push_back(s.substr(b, i + <span class="number">1</span> - b));</span><br><span class="line">                dfs(s, i + <span class="number">1</span>);</span><br><span class="line">                v.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; isPalin;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        isPalin = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">        computeIsPalin(s);</span><br><span class="line">        <span class="keyword">return</span> helper(s, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">computeIsPalin</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            isPalin[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            isPalin[i][i + <span class="number">1</span>] = (s[i] == s[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = i + len; i &lt; n &amp;&amp; j &lt; n; ++i, ++j) &#123;</span><br><span class="line">                isPalin[i][j] = isPalin[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i] == s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; helper(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalin[l][i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == r) &#123;</span><br><span class="line">                    res.push_back(&#123;s.substr(l, i + <span class="number">1</span> - l)&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;v : helper(s, i + <span class="number">1</span>, r)) &#123;</span><br><span class="line">                        res.push_back(&#123;s.substr(l, i + <span class="number">1</span> - l)&#125;);</span><br><span class="line">                        res.back().insert(res.back().end(), v.begin(), v.end());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; isPalin;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>Palindrome</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>1331. Rank Transform of an Array</title>
    <url>/2021/01/20/1331-Rank-Transform-of-an-Array/</url>
    <content><![CDATA[<p>O(nlogn) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">arrayRankTransform</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> A = arr;</span><br><span class="line">        sort(begin(A), end(A));</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : A) &#123;</span><br><span class="line">            m.emplace(x, size(m) + <span class="number">1</span>); <span class="comment">// insert重复key会失败，只有第一个会keep</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size(arr); ++i) &#123;</span><br><span class="line">            A[i] = m[arr[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">arrayRankTransform</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A = arr;</span><br><span class="line">        sort(begin(A), end(A));</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : A) &#123;</span><br><span class="line">            m[x] = m.count(x) ? m[x] : ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : arr) &#123;</span><br><span class="line">            res.push_back(m[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>1297. Maximum Number of Occurrences of a Substring</title>
    <url>/2021/01/20/1297-Maximum-Number-of-Occurrences-of-a-Substring/</url>
    <content><![CDATA[<p>sliding window O(minSize * n) time O(n) space<br>这道题的trick是如果maxSize的子串多次出现则minSize的子串只会出现更多次因为短子串一定包含在长子串里，所以只需要检查minSize子串即可！！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxFreq</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> maxLetters, <span class="keyword">int</span> minSize, <span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; size(s); ++r) &#123;</span><br><span class="line">            ++m[s[r]];</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= minSize) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--m[s[l]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    m.erase(s[l]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= minSize - <span class="number">1</span> &amp;&amp; size(m) &lt;= maxLetters) &#123;</span><br><span class="line">                res = max(res, ++f[s.substr(l, minSize)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>sliding window O((maxSize - minSize) * n * len) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxFreq</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> maxLetters, <span class="keyword">int</span> minSize, <span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = size(s), len = minSize; len &lt;= maxSize; ++len) &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">                ++m[s[r]];</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= len) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (--m[s[l]] == <span class="number">0</span>) &#123;</span><br><span class="line">                        m.erase(s[l]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= len - <span class="number">1</span> &amp;&amp; size(m) &lt;= maxLetters) &#123;</span><br><span class="line">                    res = max(res, ++f[s.substr(l, len)]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>166. Fraction to Recurring Decimal</title>
    <url>/2021/01/20/166-Fraction-to-Recurring-Decimal/</url>
    <content><![CDATA[<p>O(n) time<br>这道题的hashmap的key必须是余数（被除数）不能用商（数字）因为商可能相同但被除数不同，比如1/333小数部分开始都是0但是被除数是不一样的所以并不是循环节，真正的循环节首尾的被除数必须是一样的！</p>
<ol>
<li>判断被除数是否为0，是0直接返回0</li>
<li>判断结果是否为负</li>
<li>先处理整数部分，如果余数为0，直接返回结果</li>
<li>处理小数部分，用一个hashmap维护小数部分每个数字的下标，方便后边插入左括号</li>
<li>如果找到重复的数字，看该数字是否为0，如果是0则没有循环节不需要插入括号</li>
<li>用hashmap找到需要插入左括号的位置</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numerator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> integer, decimal;</span><br><span class="line">        <span class="keyword">if</span> ((numerator ^ denominator) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            integer += <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> n = <span class="built_in">labs</span>(numerator), d = <span class="built_in">labs</span>(denominator);</span><br><span class="line">        integer += to_string(n / d);</span><br><span class="line">        n %= d;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == n) <span class="keyword">return</span> integer;</span><br><span class="line">        integer += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// key是余数，value是在小数部分插入左括号的可能位置的下标</span></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; m.count(n) == <span class="number">0</span>) &#123;</span><br><span class="line">            m[n] = decimal.length();</span><br><span class="line">            n *= <span class="number">10</span>;</span><br><span class="line">            decimal += to_string(n / d);</span><br><span class="line">            n %= d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> integer + decimal;</span><br><span class="line">        decimal.insert(m[n], <span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> integer + decimal + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numerator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> integer, decimal;</span><br><span class="line">        <span class="keyword">if</span> ((numerator ^ denominator) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            integer += <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> n = <span class="built_in">labs</span>(numerator), d = <span class="built_in">labs</span>(denominator);</span><br><span class="line">        integer += to_string(n / d);</span><br><span class="line">        n %= d;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == n) <span class="keyword">return</span> integer;</span><br><span class="line">        integer += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        n *= <span class="number">10</span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">auto</span> it = m.find(n);</span><br><span class="line">        <span class="keyword">while</span> (it == m.end()) &#123;</span><br><span class="line">            m.emplace(n, ++i);</span><br><span class="line">            decimal += to_string(n / d);</span><br><span class="line">            n %= d;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == n) <span class="keyword">return</span> integer + decimal;</span><br><span class="line">            n *= <span class="number">10</span>;</span><br><span class="line">            it = m.find(n);</span><br><span class="line">        &#125;</span><br><span class="line">        decimal.insert(it-&gt;second, <span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> integer + decimal + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>212. Word Search II</title>
    <url>/2021/01/20/212-Word-Search-II/</url>
    <content><![CDATA[<p>Trie+backtracking<br>把字典先转成trie树，然后利用trie树来dfs遍历board</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board.empty() || board[<span class="number">0</span>].empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        TrieNode *root = <span class="keyword">new</span> TrieNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : words) &#123;</span><br><span class="line">            insert(root, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].size(); ++j) &#123;</span><br><span class="line">                dfs(root, board, i, j, dy, dx, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        TrieNode *children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> w; <span class="comment">// 这里存单词，空间换时间</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TrieNode *p, <span class="keyword">const</span> <span class="built_in">string</span> &amp;word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;w = word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p是当前TrieNode，board[i][j]是下一个字符，要检查的就是p的children里有没有board[i][j]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TrieNode *p, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> dy[], <span class="keyword">int</span> dx[], <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i == board.size() || j == board[<span class="number">0</span>].size() || board[i][j] == <span class="string">&#x27;#&#x27;</span> || !p-&gt;children[board[i][j] - <span class="string">&#x27;a&#x27;</span>]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">        p = p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;w.empty()) &#123;</span><br><span class="line">            res.push_back(p-&gt;w);</span><br><span class="line">            p-&gt;w.clear(); <span class="comment">// 这里一定要清空，因为board里面一个单词可能会有多个occurrence，为了防止反复找到该单词后添加到答案里，找到以后就改成false，这样下次即便再找到了也不会再往答案里添加了，另外这里不能返回，要继续找，有可能前缀会被复用</span></span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            dfs(p, board, i + dy[k], j + dx[k], dy, dx, res);</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        TrieNode *children[<span class="number">26</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> w;</span><br><span class="line">    &#125;;</span><br><span class="line">    TrieNode *root = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board.empty() || board[<span class="number">0</span>].empty() || words.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;w : words) &#123;</span><br><span class="line">            insert(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c) &#123;</span><br><span class="line">                dfs(board, r, c, root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> r, <span class="keyword">int</span> c, TrieNode *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || board[r][c] == <span class="string">&#x27;#&#x27;</span> || !p-&gt;children[board[r][c] - <span class="string">&#x27;a&#x27;</span>]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = board[r][c];</span><br><span class="line">        p = p-&gt;children[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;w.empty()) &#123;</span><br><span class="line">            res.push_back(p-&gt;w);</span><br><span class="line">            p-&gt;w.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        board[r][c] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        dfs(board, r + <span class="number">1</span>, c, p);</span><br><span class="line">        dfs(board, r - <span class="number">1</span>, c, p);</span><br><span class="line">        dfs(board, r, c + <span class="number">1</span>, p);</span><br><span class="line">        dfs(board, r, c - <span class="number">1</span>, p);</span><br><span class="line">        board[r][c] = ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;w = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Trie</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>1718. Construct the Lexicographically Largest Valid Sequence</title>
    <url>/2021/01/20/1718-Construct-the-Lexicographically-Largest-Valid-Sequence/</url>
    <content><![CDATA[<p>greedy+backtracking O(n!) time O(n) space<br>这道题的关键点是要发现贪心去放有可能一次性放不进去，所以必须要回溯反复试数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">constructDistancedSequence</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        res.resize(n + n - <span class="number">1</span>);</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == size(res)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (res[i] != <span class="number">0</span>) <span class="keyword">return</span> dfs(i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = n; x &gt; <span class="number">0</span>; --x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used &amp; (<span class="number">1</span> &lt;&lt; x)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> offset = x == <span class="number">1</span> ? <span class="number">0</span> : x;</span><br><span class="line">            <span class="keyword">if</span> (i + offset &lt; size(res) &amp;&amp; res[i + offset] == <span class="number">0</span>) &#123;</span><br><span class="line">                res[i] = res[i + offset] = x;</span><br><span class="line">                used ^= <span class="number">1</span> &lt;&lt; x;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                used ^= <span class="number">1</span> &lt;&lt; x;</span><br><span class="line">                res[i] = res[i + offset] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, used = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">constructDistancedSequence</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        res.resize(n + n - <span class="number">1</span>);</span><br><span class="line">        used.resize(n + <span class="number">1</span>);</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == size(res)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (res[i] != <span class="number">0</span>) <span class="keyword">return</span> dfs(i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = n; x &gt; <span class="number">0</span>; --x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[x]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> offset = x == <span class="number">1</span> ? <span class="number">0</span> : x;</span><br><span class="line">            <span class="keyword">if</span> (i + offset &lt; size(res) &amp;&amp; res[i + offset] == <span class="number">0</span>) &#123;</span><br><span class="line">                res[i] = res[i + offset] = x;</span><br><span class="line">                used[x] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                used[x] = <span class="literal">false</span>;</span><br><span class="line">                res[i] = res[i + offset] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; used;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">constructDistancedSequence</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        res.resize(n + n - <span class="number">1</span>);</span><br><span class="line">        used.resize(n + <span class="number">1</span>);</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == size(res)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (res[i] != <span class="number">0</span>) <span class="keyword">return</span> dfs(i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = n; x &gt; <span class="number">0</span>; --x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[x]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">                res[i] = x;</span><br><span class="line">                used[x] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                used[x] = <span class="literal">false</span>;</span><br><span class="line">                res[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + x &lt; size(res) &amp;&amp; res[i + x] == <span class="number">0</span>) &#123;</span><br><span class="line">                res[i] = res[i + x] = x;</span><br><span class="line">                used[x] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                used[x] = <span class="literal">false</span>;</span><br><span class="line">                res[i] = res[i + x] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; used;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>251. Flatten 2D Vector</title>
    <url>/2021/01/20/251-Flatten-2D-Vector/</url>
    <content><![CDATA[<p>O(1) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2D</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector2D(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; v) : i(begin(v)), e(end(v)), j(<span class="number">0</span>) &#123;</span><br><span class="line">        adjust();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = i-&gt;at(j++);</span><br><span class="line">        adjust();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i != e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != e &amp;&amp; j &gt;= i-&gt;size()) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator i, e;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Vector2D object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Vector2D* obj = new Vector2D(v);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next();</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2D</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector2D(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; v) : i(begin(v)), e(end(v)), j(<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hasNext(); <span class="comment">// adjustment</span></span><br><span class="line">        <span class="keyword">return</span> i-&gt;at(j++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != e &amp;&amp; j &gt;= i-&gt;size()) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i != e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator i, e;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Vector2D object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Vector2D* obj = new Vector2D(v);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next();</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2D</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector2D(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; v) : it1(begin(v)), e(end(v)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (hasNext() &amp;&amp; it1-&gt;empty()) &#123;</span><br><span class="line">            ++it1;</span><br><span class="line">        &#125;</span><br><span class="line">        it2 = hasNext() ? it1-&gt;begin() : it2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = *it2++;</span><br><span class="line">        <span class="keyword">while</span> (it2 == it1-&gt;end() &amp;&amp; ++it1 != e) &#123;</span><br><span class="line">            it2 = it1-&gt;begin();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> it1 != e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it1, e;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Vector2D object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Vector2D* obj = new Vector2D(v);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next();</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Data structure design</tag>
      </tags>
  </entry>
  <entry>
    <title>305. Number of Islands II</title>
    <url>/2021/01/20/305-Number-of-Islands-II/</url>
    <content><![CDATA[<p>union-find O(m*n+k) time O(m*n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">numIslands2</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; positions)</span> </span>&#123;</span><br><span class="line">        parent.resize(m * n, <span class="number">-1</span>); <span class="comment">// 一定要用-1因为不是每个位置都是岛</span></span><br><span class="line">        <span class="keyword">int</span> dr[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dc[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : positions) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = p[<span class="number">0</span>] * n + p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (parent[x] == <span class="number">-1</span>) &#123; <span class="comment">// 竟然有重复的position。。。</span></span><br><span class="line">                parent[x] = x;</span><br><span class="line">                ++cnt;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isValid(p[<span class="number">0</span>] + dr[i], p[<span class="number">1</span>] + dc[i], m, n)) &#123;</span><br><span class="line">                        merge(x, (p[<span class="number">0</span>] + dr[i]) * n + p[<span class="number">1</span>] + dc[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; m &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; n &amp;&amp; parent[r * n + c] != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">            x = parent[x] = parent[parent[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> px = find(x);</span><br><span class="line">        <span class="keyword">int</span> py = find(y);</span><br><span class="line">        <span class="keyword">if</span> (px != py) &#123;</span><br><span class="line">            --cnt;</span><br><span class="line">            parent[px] = py;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Island</tag>
        <tag>Union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>218. The Skyline Problem</title>
    <url>/2021/01/20/218-The-Skyline-Problem/</url>
    <content><![CDATA[<p>sweep line O(nlogn)<br>使用map记录事件，然后遍历map进行事件处理<br>用一个multiset来从高到低维护所有楼高度的『开始』和『结束』，遇到开始则加入，遇到结束则删除（只删除一个instance），每次遇到『新高』（有可能是开始，也有可能是结束，每次都要先调整multiset之后再从multiset开头取出来『新高』），然后和之前记录的高度对比，如果一样则忽略，否则要记录下来并更新记录</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; getSkyline(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt;&gt;&gt; m; <span class="comment">// 用map记录所有『事件』用一个bool来表示楼的左边还是右边（开始还是结束）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;b : buildings) &#123;</span><br><span class="line">            m[b[<span class="number">0</span>]].emplace_back(b[<span class="number">2</span>], <span class="literal">true</span>);</span><br><span class="line">            m[b[<span class="number">1</span>]].emplace_back(b[<span class="number">2</span>], <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; s; <span class="comment">// set不支持duplicate，priority_queue不支持删除任一元素，所以只能用multiset，从高到低记录每个高度的楼的左边和右边</span></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pp : p.second) &#123; <span class="comment">// 遍历每个位置的所有可能高度（『事件』），『开始』则向multiset里添加新高度，否则从中删除一个copy</span></span><br><span class="line">                <span class="keyword">if</span> (pp.second) &#123; <span class="comment">// 遇到『新高』则加入multiset</span></span><br><span class="line">                    s.emplace(pp.first);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.erase(s.find(pp.first)); <span class="comment">// 遇到某个楼的右边『结束』则从multiset删除指定iterator，不会影响其他相同元素</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> h = s.empty() ? <span class="number">0</span> : *s.begin();</span><br><span class="line">            <span class="keyword">if</span> (h != pre) &#123; <span class="comment">// 如果当前位置有『新高』，则跟之前的高度对比并记录下来</span></span><br><span class="line">                res.emplace_back(p.first, h);</span><br><span class="line">                pre = h;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; getSkyline(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt;&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;b : buildings) &#123;</span><br><span class="line">            m[b[<span class="number">0</span>]].emplace_back(b[<span class="number">2</span>], <span class="literal">true</span>);</span><br><span class="line">            m[b[<span class="number">1</span>]].emplace_back(b[<span class="number">2</span>], <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[k, v] : m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [h, isL] : v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isL) &#123;</span><br><span class="line">                    s.insert(h);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.erase(s.find(h));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mx = s.empty() ? <span class="number">0</span> : *begin(s);</span><br><span class="line">            <span class="keyword">if</span> (mx != prev) &#123;</span><br><span class="line">                res.push_back(&#123;k, mx&#125;);</span><br><span class="line">                prev = mx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sweep line</tag>
      </tags>
  </entry>
  <entry>
    <title>490. The Maze</title>
    <url>/2021/01/20/490-The-Maze/</url>
    <content><![CDATA[<p>bfs O(mn) time O(mn) space<br>这道题的意思是球一直滚到撞墙才能停下换方向<br>bfs可以避免不必要的stackoverflow</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; maze, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = maze.size(), n = maze[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s&#123;start[<span class="number">0</span>] * n + start[<span class="number">1</span>]&#125;; <span class="comment">// 先放起点去重</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(start);</span><br><span class="line">        <span class="keyword">int</span> dr[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dc[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> v = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (v == destination) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = v[<span class="number">0</span>], c = v[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">0</span> &lt;= r &amp;&amp; r &lt; m &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; n &amp;&amp; maze[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">                    r += dr[i];</span><br><span class="line">                    c += dc[i];</span><br><span class="line">                &#125;</span><br><span class="line">                r -= dr[i];</span><br><span class="line">                c -= dc[i];</span><br><span class="line">                <span class="keyword">if</span> (!s.count(r * n + c)) &#123;</span><br><span class="line">                    s.insert(r * n + c);</span><br><span class="line">                    q.push(&#123;r, c&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title>477. Total Hamming Distance</title>
    <url>/2021/01/20/477-Total-Hamming-Distance/</url>
    <content><![CDATA[<p>O(n)<br>遍历每个数的每一位，统计每一位0和1的个数，累加乘积即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = nums.size(); i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">                cnt += (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += cnt * (n - cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> not_zero = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (not_zero) &#123;</span><br><span class="line">            not_zero = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> counter[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">                ++counter[num &amp; <span class="number">1</span>];</span><br><span class="line">                num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                not_zero += (num != <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ret += (counter[<span class="number">0</span>] * counter[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>674. Longest Continuous Increasing Subsequence</title>
    <url>/2021/01/20/674-Longest-Continuous-Increasing-Subsequence/</url>
    <content><![CDATA[<p>O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> curr : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev &lt; curr) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">            res = max(res, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>393. UTF-8 Validation</title>
    <url>/2021/01/21/393-UTF-8-Validation/</url>
    <content><![CDATA[<p>O(n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validUtf8</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123; <span class="comment">// cnt为0说明开始检查一个新的字符，先检查高8位</span></span><br><span class="line">                <span class="keyword">if</span> ((x &gt;&gt; <span class="number">5</span>) == <span class="number">0b110</span>) &#123;</span><br><span class="line">                    cnt = <span class="number">1</span>; <span class="comment">// 对『每一个新的字符』初始化cnt</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((x &gt;&gt; <span class="number">4</span>) == <span class="number">0b1110</span>) &#123;</span><br><span class="line">                    cnt = <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((x &gt;&gt; <span class="number">3</span>) == <span class="number">0b11110</span>) &#123;</span><br><span class="line">                    cnt = <span class="number">3</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;&gt; <span class="number">7</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 再检查低8位</span></span><br><span class="line">                <span class="keyword">if</span> ((x &gt;&gt; <span class="number">6</span>) != <span class="number">0b10</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                --cnt; <span class="comment">// 更新cnt</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span>; <span class="comment">// 最后cnt必须为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>O(n) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validUtf8</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = data.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isValid(data, i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="keyword">int</span> &amp;i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = data.size();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt;= data[i] &amp;&amp; data[i] &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">            j = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">192</span> &lt;= data[i] &amp;&amp; data[i] &lt;= <span class="number">223</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            j = i + <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">224</span> &lt;= data[i] &amp;&amp; data[i] &lt;= <span class="number">239</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">2</span> &gt;= n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            j = i + <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">240</span> &lt;= data[i] &amp;&amp; data[i] &lt;= <span class="number">247</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">3</span> &gt;= n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            j = i + <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; j; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] &lt; <span class="number">0x0080</span> || data[i] &gt; <span class="number">0x00BF</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>93. Restore IP Addresses</title>
    <url>/2021/01/20/93-Restore-IP-Addresses/</url>
    <content><![CDATA[<p>backtracking O(27) time 即O(3<sup>4</sup>)<br>每一段都有3种可能，总共4段，遍历所有可能即为27种</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">restoreIpAddresses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        dfs(s, <span class="string">&quot;&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string_view s, <span class="built_in">string</span> &amp;&amp;a, <span class="keyword">int</span> dots)</span> </span>&#123; <span class="comment">// 这里a用的value copy省事</span></span><br><span class="line">        <span class="keyword">if</span> (dots == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty()) &#123; <span class="comment">// 如果s不为空说明输入的字符串过长</span></span><br><span class="line">                a.pop_back();</span><br><span class="line">                res.push_back(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min((<span class="keyword">int</span>)s.length(), <span class="number">3</span>); ++i) &#123;</span><br><span class="line">            str += s[i];</span><br><span class="line">            <span class="keyword">if</span> (str.length() &gt; <span class="number">1</span> &amp;&amp; str[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">break</span>; <span class="comment">// 检查合法性</span></span><br><span class="line">            <span class="keyword">if</span> (stoi(str) &gt; <span class="number">255</span>) <span class="keyword">break</span>;</span><br><span class="line">            dfs(s.substr(i + <span class="number">1</span>), a + str + <span class="string">&#x27;.&#x27;</span>, dots - <span class="number">1</span>); <span class="comment">// 这里append str以后不好弹出来实现回溯，所以直接用value copy就不弹出了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>432. All O`one Data Structure</title>
    <url>/2021/01/21/432-All-O-one-Data-Structure/</url>
    <content><![CDATA[<p>list是bidirectional iterator支持++和–</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllOne</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    AllOne() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="built_in">string</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key2bucket.count(key) == <span class="number">0</span>) &#123;</span><br><span class="line">            key2bucket[key] = buckets.insert(buckets.end(), &#123;<span class="number">0</span>, &#123;key&#125;&#125;); <span class="comment">// 找不到『旧bucket』就先插一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> curr = key2bucket[key], prev = <span class="built_in">std</span>::prev(curr);</span><br><span class="line">        <span class="keyword">if</span> (curr == buckets.begin() || prev-&gt;value &gt; curr-&gt;value + <span class="number">1</span>) &#123;</span><br><span class="line">            prev = buckets.insert(curr, &#123;curr-&gt;value + <span class="number">1</span>, &#123;&#125;&#125;); <span class="comment">// 如果没有『新bucket』就插一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        prev-&gt;keys.insert(key); <span class="comment">// 从旧bucket挪到新bucket</span></span><br><span class="line">        curr-&gt;keys.erase(key);</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;keys.empty()) &#123;</span><br><span class="line">            buckets.erase(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        key2bucket[key] = prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Decrements an existing key by 1. If Key&#x27;s value is 1, remove it from the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="built_in">string</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key2bucket.count(key) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> curr = key2bucket[key], next = <span class="built_in">std</span>::next(curr);</span><br><span class="line">        key2bucket.erase(key); <span class="comment">// 先删key反正后边要不删了就删了要不写新key</span></span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;value != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next == buckets.end() || curr-&gt;value - <span class="number">1</span> &gt; next-&gt;value) &#123;</span><br><span class="line">                next = buckets.insert(next, &#123;curr-&gt;value - <span class="number">1</span>, &#123;&#125;&#125;); <span class="comment">// 如果没有『新bucket』加一个</span></span><br><span class="line">            &#125;</span><br><span class="line">            next-&gt;keys.insert(key); <span class="comment">// 从旧bucket挪到新bucket</span></span><br><span class="line">            key2bucket[key] = next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;keys.erase(key);</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;keys.empty()) &#123;</span><br><span class="line">            buckets.erase(curr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns one of the keys with maximal value. */</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getMaxKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buckets.empty() ? <span class="string">&quot;&quot;</span> : *begin(buckets.front().keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns one of the keys with Minimal value. */</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getMinKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buckets.empty() ? <span class="string">&quot;&quot;</span> : *begin(buckets.back().keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Bucket</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; keys;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">list</span>&lt;Bucket&gt;::iterator&gt; key2bucket;</span><br><span class="line">    <span class="built_in">list</span>&lt;Bucket&gt; buckets;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your AllOne object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * AllOne obj = new AllOne();</span></span><br><span class="line"><span class="comment"> * obj.inc(key);</span></span><br><span class="line"><span class="comment"> * obj.dec(key);</span></span><br><span class="line"><span class="comment"> * string param_3 = obj.getMaxKey();</span></span><br><span class="line"><span class="comment"> * string param_4 = obj.getMinKey();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllOne</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    AllOne() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="built_in">string</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = key2it.find(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key2it.end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq2lst.count(<span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                freq2lst[<span class="number">1</span>] = lst.insert(lst.end(), <span class="built_in">list</span>&lt;KF&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            freq2lst[<span class="number">1</span>]-&gt;emplace_front(key, <span class="number">1</span>);</span><br><span class="line">            key2it[key] = freq2lst[<span class="number">1</span>]-&gt;begin();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            KF kf = *it-&gt;second;</span><br><span class="line">            <span class="keyword">int</span> freq = kf.freq;</span><br><span class="line">            <span class="keyword">if</span> (freq2lst.count(freq + <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                freq2lst[freq + <span class="number">1</span>] = lst.insert(freq2lst[freq], <span class="built_in">list</span>&lt;KF&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            freq2lst[freq]-&gt;erase(it-&gt;second);</span><br><span class="line">            freq2lst[++kf.freq]-&gt;push_front(kf);</span><br><span class="line">            key2it[kf.key] = freq2lst[kf.freq]-&gt;begin();</span><br><span class="line">            <span class="keyword">if</span> (freq2lst[freq]-&gt;empty()) &#123;</span><br><span class="line">                lst.erase(freq2lst[freq]);</span><br><span class="line">                freq2lst.erase(freq);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Decrements an existing key by 1. If Key&#x27;s value is 1, remove it from the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="built_in">string</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = key2it.find(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key2it.end()) <span class="keyword">return</span>;</span><br><span class="line">        KF kf = *it-&gt;second;</span><br><span class="line">        <span class="keyword">int</span> freq = kf.freq;</span><br><span class="line">        freq2lst[freq]-&gt;erase(it-&gt;second);</span><br><span class="line">        <span class="keyword">if</span> (freq == <span class="number">1</span>) &#123;</span><br><span class="line">            key2it.erase(kf.key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq2lst.count(freq - <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> iter = freq2lst[freq];</span><br><span class="line">                freq2lst[freq - <span class="number">1</span>] = lst.insert(++iter, <span class="built_in">list</span>&lt;KF&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            freq2lst[--kf.freq]-&gt;push_front(kf);</span><br><span class="line">            key2it[kf.key] = freq2lst[kf.freq]-&gt;begin();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (freq2lst[freq]-&gt;empty()) &#123;</span><br><span class="line">            lst.erase(freq2lst[freq]);</span><br><span class="line">            freq2lst.erase(freq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns one of the keys with maximal value. */</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getMaxKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lst.empty() ? <span class="string">&quot;&quot;</span> : lst.front().front().key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns one of the keys with Minimal value. */</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getMinKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lst.empty() ? <span class="string">&quot;&quot;</span> : lst.back().front().key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">KF</span> &#123;</span></span><br><span class="line">        KF(<span class="keyword">const</span> <span class="built_in">string</span> &amp;key, <span class="keyword">int</span> freq) : key(key), freq(freq) &#123;&#125;</span><br><span class="line">        <span class="built_in">string</span> key;</span><br><span class="line">        <span class="keyword">int</span> freq = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">list</span>&lt;KF&gt;::iterator&gt; key2it;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="built_in">list</span>&lt;KF&gt;&gt;::iterator&gt; freq2lst;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">list</span>&lt;KF&gt;&gt; lst;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your AllOne object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * AllOne obj = new AllOne();</span></span><br><span class="line"><span class="comment"> * obj.inc(key);</span></span><br><span class="line"><span class="comment"> * obj.dec(key);</span></span><br><span class="line"><span class="comment"> * string param_3 = obj.getMaxKey();</span></span><br><span class="line"><span class="comment"> * string param_4 = obj.getMinKey();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Data structure design</tag>
      </tags>
  </entry>
  <entry>
    <title>632. Smallest Range Covering Elements from K Lists</title>
    <url>/2021/01/21/632-Smallest-Range-Covering-Elements-from-K-Lists/</url>
    <content><![CDATA[<p>multimap O(nlogk)<br>把heap换成multimap更直观，multimap里存的最小值和最大值就是当前可能的备选范围，不断减小最大值来得到新的最大值即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallestRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">int</span> k = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            m.emplace(nums[i].back(), i);</span><br><span class="line">            nums[i].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res&#123;<span class="number">-100000</span>, <span class="number">100000</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!m.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> h = begin(m);</span><br><span class="line">            <span class="keyword">auto</span> l = rbegin(m);</span><br><span class="line">            <span class="keyword">auto</span> [hi, i] = *h;</span><br><span class="line">            <span class="keyword">auto</span> [lo, _] = *l;</span><br><span class="line">            <span class="keyword">if</span> (hi - lo &lt;= res[<span class="number">1</span>] - res[<span class="number">0</span>]) &#123;</span><br><span class="line">                res = &#123;lo, hi&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m.erase(h);</span><br><span class="line">            <span class="keyword">if</span> (nums[i].empty()) <span class="keyword">break</span>;</span><br><span class="line">            m.emplace(nums[i].back(), i);</span><br><span class="line">            nums[i].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>max heap O(nlogk) n是数的个数，k是数组个数，这里用最大堆是想让每个数组从后往前剔除元素，避免维护指针麻烦<br>题目解法和merge k sorted lists类似，上来先取每个数组的最大值放入堆，并维护一个全局最小值，然后不停从堆顶元素对应的数组取数并更新堆顶、全局最小值和最大值直到某个数组为空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallestRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> pii = <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;pii, <span class="built_in">vector</span>&lt;pii&gt;&gt; q;</span><br><span class="line">        <span class="keyword">int</span> k = nums.size();</span><br><span class="line">        <span class="keyword">int</span> lo = INT_MAX, hi = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            lo = min(lo, nums[i].back());</span><br><span class="line">            hi = max(hi, nums[i].back());</span><br><span class="line">            q.emplace(nums[i].back(), i);</span><br><span class="line">            nums[i].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res&#123;lo, hi&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [hi, i] = q.top(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (hi - lo &lt;= res[<span class="number">1</span>] - res[<span class="number">0</span>]) &#123; <span class="comment">// 因为是有序的，所以不需要单独考虑差系统的情况，但是必须要用小于等于，因为是从大到小遍历的，所以后边有可能有差相同但是range开端更小的来overwrite结果</span></span><br><span class="line">                res = &#123;lo, hi&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i].empty()) <span class="keyword">break</span>;</span><br><span class="line">            lo = min(lo, nums[i].back());</span><br><span class="line">            q.emplace(nums[i].back(), i);</span><br><span class="line">            nums[i].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>greedy+sliding window O(nlogn + n) time O(n) space<br><a href="https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/discuss/624185/C%2B%2B-sliding-window-easy-solution">题解</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallestRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; ordered; <span class="comment">// (number, group)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; nums.size(); ++k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x : nums[k]) &#123;</span><br><span class="line">                ordered.emplace_back(x, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ordered.begin(), ordered.end());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, k = size(nums);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res&#123;<span class="number">-100000</span>, <span class="number">100000</span>&#125;;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; ordered.size(); ++r) &#123;</span><br><span class="line">            ++count[ordered[r].second];</span><br><span class="line">            <span class="keyword">if</span> (size(count) == k) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count[ordered[l].second] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    --count[ordered[l++].second];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ordered[r].first - ordered[l].first &lt; res[<span class="number">1</span>] - res[<span class="number">0</span>]) &#123;</span><br><span class="line">                    res = &#123;ordered[l].first, ordered[r].first&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Sliding window</tag>
        <tag>Merging</tag>
        <tag>Heap</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>403. Frog Jump</title>
    <url>/2021/01/21/403-Frog-Jump/</url>
    <content><![CDATA[<p>O(n<sup>2</sup>) time O(n<sup>2</sup>) space<br>因为stones[0]是0且初始步长是0所以步长最多为n也就是最多n种，所以对于每个stones[i]步长最多n种，复杂度O(n<sup>2</sup>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, limit = <span class="number">0</span>; i &lt; stones.size(); ++i) &#123; <span class="comment">// 可有可无，只是一个优化，假设前面每一跳都比前面一跳加1，那么到第i跳之后应该到 i * (i  + 1) / 2，假如stones[i]比这个要远，则意味着永远到不了stones[i]</span></span><br><span class="line">            limit += i;</span><br><span class="line">            <span class="keyword">if</span> (stones[i] &gt; limit) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> canCross(stones, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;stones, <span class="keyword">int</span> b, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// 上一步步长为k达到的stones[b]，从b + 1开始遍历看[k - 1, k + 1]步长之内能到哪些stones</span></span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        <span class="keyword">if</span> (b == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">auto</span> key = (k &lt;&lt; <span class="number">11</span>) | b; <span class="comment">// 如果是全部integer则要用long key = (k &lt;&lt; 32) | b;</span></span><br><span class="line">        <span class="keyword">if</span> (m.count(key)) <span class="keyword">return</span> m[key];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b + <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 这个循环实际上只需要遍历最多三个stones</span></span><br><span class="line">            <span class="keyword">int</span> jump = stones[i] - stones[b];</span><br><span class="line">            <span class="keyword">if</span> (jump &lt; k - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (jump &gt; k + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (canCross(stones, i, jump)) <span class="keyword">return</span> m[key] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[key] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; m; <span class="comment">// 每个石头的下标+尝试到达stones[i]所需要的步长 和 用这个步长是否能到达stones[i]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        n = stones.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dict[stones[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> canCross(stones, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;stones, <span class="keyword">int</span> b, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">auto</span> key = (k &lt;&lt; <span class="number">11</span>) | b;</span><br><span class="line">        <span class="keyword">if</span> (m.count(key)) <span class="keyword">return</span> m[key];</span><br><span class="line">        <span class="keyword">int</span> next = stones[b] + k;</span><br><span class="line">        <span class="keyword">if</span> (dict.count(next) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">-1</span>; d &lt;= <span class="number">1</span>; ++d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canCross(stones, dict[next], k + d)) <span class="keyword">return</span> m[key] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[key] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m, dict;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n<sup>2</sup>) time O(n<sup>2</sup>) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; m; <span class="comment">// 每个石头的位置stones[i]和到stones[i]有可能的步长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s : stones) &#123;</span><br><span class="line">            m[s] = &#123;&#125;; <span class="comment">// 这一步必须要有，否则无法判断是否存在指定位置的石头</span></span><br><span class="line">        &#125;</span><br><span class="line">        m[stones[<span class="number">0</span>]].insert(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s : stones) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k : m[s]) &#123; <span class="comment">// 每个石头最多只可能继承n种步长（否则就到最后一个了）所以内循环复杂度上限是O(n)</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">-1</span>; d &lt;= <span class="number">1</span>; ++d) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = s + k + d;</span><br><span class="line">                    <span class="keyword">if</span> (t == stones.back()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (k + d &gt; <span class="number">0</span> &amp;&amp; m.count(t)) &#123;</span><br><span class="line">                        m[t].insert(k + d);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>1146. Snapshot Array</title>
    <url>/2021/01/17/1146-Snapshot-Array/</url>
    <content><![CDATA[<p>constructor O(1) set O(1) snap O(1) get O(logSnaps)<br>用这个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SnapshotArray(<span class="keyword">int</span> length) &#123;</span><br><span class="line">        snaps.resize(length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (snaps[index].empty() || snaps[index].back().first != sid &amp;&amp; snaps[index].back().second != val) &#123; <span class="comment">// 如果没有index的snap记录或者只有旧的记录（跟新值不同的），添加下一个snap_id的记录</span></span><br><span class="line">            snaps[index].emplace_back(sid, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            snaps[index].back().second = val; <span class="comment">// 如果已经有下一个snap_id的记录则直接修改即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">snap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sid++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> snap_id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;v = snaps[index];</span><br><span class="line">        <span class="keyword">auto</span> it = upper_bound(begin(v), end(v), <span class="built_in">make_pair</span>(snap_id, INT_MAX)); <span class="comment">// 为了找到上界需要使用INT_MAX</span></span><br><span class="line">        <span class="keyword">return</span> it == begin(v) ? <span class="number">0</span> : prev(it)-&gt;second; <span class="comment">// 最开始所有元素都为0所以找不着就给0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; snaps; <span class="comment">// key是index，pair是sid和val</span></span><br><span class="line">    <span class="keyword">int</span> sid = <span class="number">0</span>; <span class="comment">// 下一个snap_id;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SnapshotArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SnapshotArray* obj = new SnapshotArray(length);</span></span><br><span class="line"><span class="comment"> * obj-&gt;set(index,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;snap();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;get(index,snap_id);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Data structure design</tag>
      </tags>
  </entry>
  <entry>
    <title>121. Best Time to Buy and Sell Stock</title>
    <url>/2021/01/17/121-Best-Time-to-Buy-and-Sell-Stock/</url>
    <content><![CDATA[<p>用当前价格减去之前的最低价格来更新全局最大差价即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mn = INT_MAX, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p : prices) &#123;</span><br><span class="line">            res = max(res, p - mn);</span><br><span class="line">            mn = min(mn, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>直接切入法<br>买卖一股，一定是第i天买，第j天卖（j &gt; i），获利是prices[j] - prices[i]<br>枚举j，即第几天卖，只需要维护当前最低的买入价格prices[i] (i &lt; j)即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curr_min = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            curr_min = min(curr_min, prices[i]);</span><br><span class="line">            res = max(res, prices[i] - curr_min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>maximum subarray法<br>dp O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            profit = max(profit, <span class="number">0</span>) + prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            res = max(res, profit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp O(n) time O(n) space<br>maximum subarray的变体<br>(b - a) + (c - b) + (d - c) + (e - d) = e - a</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diffs</span><span class="params">(n - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            diffs[i - <span class="number">1</span>] = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = diffs[i - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + diffs[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stock</tag>
      </tags>
  </entry>
  <entry>
    <title>150. Evaluate Reverse Polish Notation</title>
    <url>/2021/01/17/150-Evaluate-Reverse-Polish-Notation/</url>
    <content><![CDATA[<p>O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;t : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.length() &gt; <span class="number">1</span> || <span class="built_in">isdigit</span>(t[<span class="number">0</span>])) &#123; <span class="comment">// 这里切记要检查长度是否大于1，因为有可能是负数！！</span></span><br><span class="line">                s.push(stoi(t));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> b = s.top(); s.pop();</span><br><span class="line">                <span class="keyword">int</span> a = s.top(); s.pop();</span><br><span class="line">                <span class="keyword">switch</span> (t[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: s.push(a + b); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: s.push(a - b); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: s.push(a * b); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: s.push(a / b); <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>214. Shortest Palindrome</title>
    <url>/2021/01/17/214-Shortest-Palindrome/</url>
    <content><![CDATA[<p>rolling hash O(n) time O(n) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">r</span><span class="params">(rbegin(s), rend(s))</span></span>;</span><br><span class="line">        <span class="keyword">long</span> M = INT_MAX, B = <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">int</span> n = size(s);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; <span class="title">p</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            p[i] = (p[i - <span class="number">1</span>] * B) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> sh = <span class="number">0</span>, rh = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sh = (sh * B + s[i]) % M;</span><br><span class="line">            rh = (rh * B + r[i]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sh == rh &amp;&amp; s.compare(<span class="number">0</span>, n, r, <span class="number">0</span>, n) == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sh = (sh + M - s[n - i] * p[i - <span class="number">1</span>] % M) % M;</span><br><span class="line">            rh = (rh + M - r[i - <span class="number">1</span>] * p[n - i] % M) % M;</span><br><span class="line">            <span class="keyword">if</span> (sh == rh * p[i] % M &amp;&amp; s.compare(<span class="number">0</span>, n - i, r, i, n - i) == <span class="number">0</span>) <span class="keyword">return</span> r.substr(<span class="number">0</span>, i) + s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">r</span><span class="params">(rbegin(s), rend(s))</span></span>;</span><br><span class="line">        <span class="keyword">long</span> M = INT_MAX, B = <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">int</span> n = size(s);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; <span class="title">p</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            p[i] = (p[i - <span class="number">1</span>] * B) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> sh = <span class="number">0</span>, rh = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sh = (sh + s[i] * p[i]) % M;</span><br><span class="line">            rh = (rh + r[i] * p[i]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sh == rh &amp;&amp; s.compare(<span class="number">0</span>, n, r, <span class="number">0</span>, n) == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sh = (sh + M - s[n - i] * p[n - i] % M) % M;</span><br><span class="line">            rh = (rh + M - r[i - <span class="number">1</span>] * p[i - <span class="number">1</span>] % M) % M;</span><br><span class="line">            <span class="keyword">if</span> ((sh * p[i]) % M == rh &amp;&amp; s.compare(<span class="number">0</span>, n - i, r, i, n - i) == <span class="number">0</span>) <span class="keyword">return</span> r.substr(<span class="number">0</span>, i) + s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">r</span><span class="params">(rbegin(s), rend(s))</span></span>;</span><br><span class="line">        <span class="keyword">long</span> M = INT_MAX, B = <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">int</span> n = size(s);</span><br><span class="line">        vector&lt;long&gt; p(n, 1), sh(n), rh(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            p[i] = (p[i - <span class="number">1</span>] * B) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        sh[<span class="number">0</span>] = s[<span class="number">0</span>];</span><br><span class="line">        rh[<span class="number">0</span>] = r[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sh[i] = (sh[i - <span class="number">1</span>] + s[i] * p[i]) % M;</span><br><span class="line">            rh[i] = (rh[i - <span class="number">1</span>] + r[i] * p[i]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sh[n - <span class="number">1</span>] == rh[n - <span class="number">1</span>] &amp;&amp; s.compare(<span class="number">0</span>, n, r, <span class="number">0</span>, n) == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> a = (sh[n - i - <span class="number">1</span>] * p[i]) % M;</span><br><span class="line">            <span class="keyword">auto</span> b = (rh[n - <span class="number">1</span>] + M - rh[i - <span class="number">1</span>]) % M;</span><br><span class="line">            <span class="keyword">if</span> (a == b &amp;&amp; s.compare(<span class="number">0</span>, n - i, r, i, n - i) == <span class="number">0</span>) <span class="keyword">return</span> r.substr(<span class="number">0</span>, i) + s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n<sup>2</sup>)递归版<br>KMP可以实现O(n)<br>我们使用双指针来找出字符串s的最长回文前缀的大概范围，指针i和j分别指向s串的开头和末尾，若 s[i] 和 s[j] 相等，则i自增1，j自减1，否则只有j自减1。这样遍历一遍后，最长回文前缀就在范围 [0, i) 中，但不保证这个本身就是最大回文前缀，我们只能确定后面剩余的部分肯定不属于，此时我们提取出剩下的字符，翻转一下加到最前面，而对范围 [0, i) 内的子串再次递归调用本函数，这样，在子函数最终会组成最短的回文串，从而使得整个的回文串就是最短的<br>Each iteration of shortestPalindrome is linear in size of substring and the maximum number of recursive calls can be n/2 times as shown in the Intuition section.<br>Let the time complexity of the algorithm be T(n). Since, at the each step for the worst case, the string can be divide into 2 parts and we require only one part for further computation. Hence, the time complexity for the worst case can be represented as : T(n)=T(n-2)+O(n)T(n)=T(n−2)+O(n). So, T(n) = O(n) + O(n-2) + O(n-4) + … + O(1)T(n)=O(n)+O(n−2)+O(n−4)+…+O(1) which is O(n<sup>2</sup>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>;--j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == n) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> prefix = s.substr(i);</span><br><span class="line">        reverse(prefix.begin(), prefix.end());</span><br><span class="line">        <span class="built_in">string</span> mid = shortestPalindrome(s.substr(<span class="number">0</span>, i));</span><br><span class="line">        <span class="keyword">return</span> prefix + mid + s.substr(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>iterative O(n<sup>2</sup>) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(s);</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">r</span><span class="params">(rbegin(s), rend(s))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.compare(<span class="number">0</span>, n - i, r, i, n - i) == <span class="number">0</span>) <span class="keyword">return</span> r.substr(<span class="number">0</span>, i) + s; <span class="comment">// 避免copy</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>TLE O(n<sup>2</sup>) time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(s);</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">r</span><span class="params">(rbegin(s), rend(s))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.substr(<span class="number">0</span>, n - i) == r.substr(i)) <span class="keyword">return</span> r.substr(<span class="number">0</span>, i) + s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>错误dp版本O(n<sup>2</sup>) time O(n<sup>2</sup>) space<br>题目要求只能在前面加，这个版本是可以在任何位置加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> t = s;</span><br><span class="line">        reverse(t.begin(), t.end());</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = max(f[i][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n, j = n; i &gt; <span class="number">0</span> || j &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                res += t[j - <span class="number">1</span>];</span><br><span class="line">                --j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                res += s[i - <span class="number">1</span>];</span><br><span class="line">                --i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                res += s[i - <span class="number">1</span>];</span><br><span class="line">                --i;</span><br><span class="line">                --j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i][j] == f[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    res += t[j - <span class="number">1</span>];</span><br><span class="line">                    --j;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += s[i - <span class="number">1</span>];</span><br><span class="line">                    --i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
        <tag>Palindrome</tag>
        <tag>Rolling hash</tag>
      </tags>
  </entry>
  <entry>
    <title>349. Intersection of Two Arrays</title>
    <url>/2021/01/17/349-Intersection-of-Two-Arrays/</url>
    <content><![CDATA[<p>O(m + n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.find(n) != s.end()) &#123;</span><br><span class="line">                res.push_back(n);</span><br><span class="line">                s.erase(n); <span class="comment">// if nums2 has multiple copy of n, then the following instances cannot be found any more, in order to avoid duplicate push back</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums1) &#123;</span><br><span class="line">            m[x] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[x]) &#123;</span><br><span class="line">                res.push_back(x);</span><br><span class="line">                m[x] = <span class="literal">false</span>; <span class="comment">// if nums2 has multiple copy of x, then the following instances cannot be found any more, in order to avoid duplicate push back</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hash table</tag>
      </tags>
  </entry>
  <entry>
    <title>1314. Matrix Block Sum</title>
    <url>/2021/01/17/1314-Matrix-Block-Sum/</url>
    <content><![CDATA[<p>O(mn) time O(mn) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrixBlockSum(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.size(), n = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res = mat, presum(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt;= m; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= n; ++c) &#123;</span><br><span class="line">                presum[r][c] = presum[r - <span class="number">1</span>][c] + presum[r][c - <span class="number">1</span>] - presum[r - <span class="number">1</span>][c - <span class="number">1</span>] + mat[r - <span class="number">1</span>][c - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c) &#123;</span><br><span class="line">                <span class="keyword">int</span> ulr = max(<span class="number">0</span>, r - K), ulc = max(<span class="number">0</span>, c - K), brr = min(m - <span class="number">1</span>, r + K), brc = min(n - <span class="number">1</span>, c + K);</span><br><span class="line">                res[r][c] = presum[brr + <span class="number">1</span>][brc + <span class="number">1</span>] + presum[ulr][ulc] - presum[ulr][brc + <span class="number">1</span>] - presum[brr + <span class="number">1</span>][ulc];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>545. Boundary of Binary Tree</title>
    <url>/2021/01/17/545-Boundary-of-Binary-Tree/</url>
    <content><![CDATA[<p>dfs O(n) time O(logn) space<br>遍历左半边的时候，相当于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (lb) &#123;</span><br><span class="line">    res.push_back(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line">dfs(root-&gt;left, lb, false);</span><br><span class="line">dfs(root-&gt;right, lb &amp;&amp; !root-&gt;left, false); &#x2F;&#x2F; 只有左子不存在才考虑右子</span><br></pre></td></tr></table></figure>
<p>遍历右半边的时候，相当于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dfs(root-&gt;left, false, rb &amp;&amp; !root-&gt;right); &#x2F;&#x2F; 只有右子不存在才考虑左子</span><br><span class="line">dfs(root-&gt;right, false, rb);</span><br><span class="line">if (rb) &#123;</span><br><span class="line">    res.push_back(root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">boundaryOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left, <span class="literal">true</span>, <span class="literal">false</span>); <span class="comment">// 左右分两半递归遍历，遍历左半边时，右flag永远是false</span></span><br><span class="line">        dfs(root-&gt;right, <span class="literal">false</span>, <span class="literal">true</span>); <span class="comment">// 遍历右半边时，左flag永远是false</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">bool</span> lb, <span class="keyword">bool</span> rb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 所有的叶节点放完即返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lb) &#123; <span class="comment">// 左半边的遍历顺序是中左右</span></span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, lb, rb &amp;&amp; !root-&gt;right); <span class="comment">// 右半边的内部节点不加，当右子树不为空，左边除叶节点以外所有节点都认为是内部节点</span></span><br><span class="line">        dfs(root-&gt;right, lb &amp;&amp; !root-&gt;left, rb); <span class="comment">// 左半边的内部节点不加，当左子树不为空，右边除叶节点完所有节点都认为是内部节点</span></span><br><span class="line">        <span class="keyword">if</span> (rb) &#123; <span class="comment">// 右半边的遍历顺序是左右中</span></span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">boundaryOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        l.push_back(root-&gt;val);</span><br><span class="line">        helperL(root-&gt;left, <span class="literal">true</span>);</span><br><span class="line">        helperR(root-&gt;right, <span class="literal">true</span>);</span><br><span class="line">        l.insert(end(l), rbegin(r), rend(r));</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helperL</span><span class="params">(TreeNode *root, <span class="keyword">bool</span> border)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (border) &#123;</span><br><span class="line">            l.push_back(root-&gt;val);</span><br><span class="line">            helperL(root-&gt;left, <span class="literal">true</span>);</span><br><span class="line">            helperL(root-&gt;right, !root-&gt;left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            l.push_back(root-&gt;val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            helperL(root-&gt;left, border);</span><br><span class="line">            helperL(root-&gt;right, border);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helperR</span><span class="params">(TreeNode *root, <span class="keyword">bool</span> border)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (border) &#123;</span><br><span class="line">            r.push_back(root-&gt;val);</span><br><span class="line">            helperR(root-&gt;right, <span class="literal">true</span>);</span><br><span class="line">            helperR(root-&gt;left, !root-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            r.push_back(root-&gt;val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            helperR(root-&gt;right, border);</span><br><span class="line">            helperR(root-&gt;left, border);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l, r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Postorder traversal</tag>
        <tag>Binary tree</tag>
        <tag>Preorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>234. Palindrome Linked List</title>
    <url>/2021/01/17/234-Palindrome-Linked-List/</url>
    <content><![CDATA[<p>找到中点reverse后半部，跟前半部比对即可，比如[1,2,1]拆成[1]和[2,1]，比较[1]跟[1,2]即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode dummy_head(0), *slow = &amp;dummy_head, *fast = head; // fast从head或者dummy_head开始都行</span><br><span class="line">        dummy_head.next = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        fast = reverse(fast);</span><br><span class="line">        <span class="keyword">while</span> (head &amp;&amp; head-&gt;val == fast-&gt;val) &#123; <span class="comment">// head短fast长因为找中点时fast从head开始</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">reverse</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="keyword">auto</span> succ = curr-&gt;next; curr-&gt;next = prev; prev = curr;</span><br><span class="line">            curr = succ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast ? slow-&gt;next : slow;</span><br><span class="line">        <span class="keyword">auto</span> l2 = reverse(fast);</span><br><span class="line">        prev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (head &amp;&amp; l2 &amp;&amp; head-&gt;val == l2-&gt;val) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">reverse</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="keyword">auto</span> succ = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = succ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>, *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast ? slow-&gt;next : slow;</span><br><span class="line">        <span class="keyword">auto</span> l2 = reverse(fast);</span><br><span class="line">        prev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (head &amp;&amp; l2 &amp;&amp; head-&gt;val == l2-&gt;val) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">reverse</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> res = reverse(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">auto</span> slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">        <span class="keyword">auto</span> l2 = reverse(fast);</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (!fast-&gt;next) &#123;</span><br><span class="line">            fast-&gt;next = slow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head &amp;&amp; l2 &amp;&amp; head-&gt;val == l2-&gt;val) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">reverse</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> res = reverse(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Palindrome</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>468. Validate IP Address</title>
    <url>/2021/01/17/468-Validate-IP-Address/</url>
    <content><![CDATA[<p>O(n) time<br>这道题<strong>2001:0db8:85a3:00:000:8A2E:0370:7334</strong>是合法的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">validIPAddress</span><span class="params">(<span class="built_in">string</span> IP)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isIPv4(IP)) <span class="keyword">return</span> <span class="string">&quot;IPv4&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isIPv6(IP)) <span class="keyword">return</span> <span class="string">&quot;IPv6&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIPv4</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;IP)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count(begin(IP), end(IP), <span class="string">&#x27;.&#x27;</span>) != <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(IP)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (getline(input, s, <span class="string">&#x27;.&#x27;</span>)) &#123; <span class="comment">// 分段检查</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> x = stoi(s);</span><br><span class="line">                <span class="keyword">if</span> (to_string(x) != s || x &lt; <span class="number">0</span> || x &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 开头不能有0，必须在0到255之间，不能有非数字</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (exception &amp;e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIPv6</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;IP)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count(begin(IP), end(IP), <span class="string">&#x27;:&#x27;</span>) != <span class="number">7</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(IP)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (getline(input, s, <span class="string">&#x27;:&#x27;</span>)) &#123; <span class="comment">// 分段检查</span></span><br><span class="line">            <span class="keyword">if</span> (empty(s) || size(s) &gt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">                c = <span class="built_in">tolower</span>(c);</span><br><span class="line">                <span class="keyword">if</span> (!(<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &amp;&amp; !(<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不能有非16进制字符</span></span><br><span class="line">            &#125;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">validIPAddress</span><span class="params">(<span class="built_in">string</span> IP)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (IP.empty() || IP.back() == <span class="string">&#x27;.&#x27;</span> || IP.back() == <span class="string">&#x27;:&#x27;</span>) <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>; <span class="comment">// 不能结尾出现delimiter</span></span><br><span class="line">        <span class="keyword">bool</span> isv4 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : IP) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isv4 = c == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">break</span>; <span class="comment">// 初步判断是v4还是v6</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> delimiter = isv4 ? <span class="string">&#x27;.&#x27;</span> : <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">input</span><span class="params">(IP)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">while</span> (getline(input, s, delimiter)) &#123; <span class="comment">// 分段检查</span></span><br><span class="line">            <span class="keyword">if</span> (!isValid(s, isv4)) <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">            ++cnt; <span class="comment">// 数一共有几段</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isv4) &#123; <span class="comment">// 判断段数是否合法</span></span><br><span class="line">            <span class="keyword">return</span> cnt == <span class="number">4</span> ? <span class="string">&quot;IPv4&quot;</span> : <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cnt == <span class="number">8</span> ? <span class="string">&quot;IPv6&quot;</span> : <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">bool</span> isv4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isv4) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty() || s.length() &gt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 判断长度</span></span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 判断是否有非法字符比如abcd</span></span><br><span class="line">                x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (s == <span class="string">&quot;0&quot;</span>) || (<span class="number">0</span> &lt; x &amp;&amp; x &lt; <span class="number">256</span> &amp;&amp; s[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 不能出现leading zeros</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty() || s.length() &gt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">                c = <span class="built_in">tolower</span>(c);</span><br><span class="line">                <span class="keyword">if</span> (!(<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &amp;&amp; !(<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>1287. Element Appearing More Than 25&amp;#37; In Sorted Array</title>
    <url>/2021/01/17/1287-Element-Appearing-More-Than-25-In-Sorted-Array/</url>
    <content><![CDATA[<p>O(logn) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSpecialInteger</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : &#123;<span class="number">.25</span>, <span class="number">.5</span>, <span class="number">.75</span>&#125;) &#123; <span class="comment">// 分别测试每个quartile位置的数，超过25%的数一定能被capture</span></span><br><span class="line">            <span class="keyword">int</span> i = n * p;</span><br><span class="line">            <span class="keyword">auto</span> [b, e] = equal_range(begin(arr), end(arr), arr[i]);</span><br><span class="line">            <span class="keyword">if</span> (e - b &gt; n / <span class="number">4</span>) <span class="keyword">return</span> arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>O(n) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSpecialInteger</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size(), mx = n * <span class="number">.25</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (arr[j] == arr[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++j - i &gt; mx) <span class="keyword">return</span> arr[i]; <span class="comment">// 一旦找到则提前返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo title中有特殊字符报错（转）</title>
    <url>/2021/01/21/hexo-title%E4%B8%AD%E6%9C%89%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>问题：<br>在使用hexo写文章时，如果文章的title中包含双引号”abc”、&dollar;符号时会编译出错，文章无法渲染。<br>由于这里的写法是yml语法，”、&dollar;这些都是特殊符号，执行hexo -s时到编译title这里就会出现错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Shell中<span class="variable">$i</span> $() <span class="variable">$&#123;&#125;</span>的区别</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>解决办法<br>这里我们需要对特殊符号进行转义，用对应的THML字符实体进行替换，例如&dollar;对应$，如此等等。<br>转移之后的标题就变成了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Shell中\&amp;<span class="comment">#36;i \&amp;#36;&amp;#40;&amp;#41; \&amp;#36;&amp;#123;&amp;#125;的区别</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>附录：各种常用特殊字符对应的HTML字符实体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">! &amp;<span class="comment">#33; — 惊叹号 Exclamation mark</span></span><br><span class="line"><span class="string">&quot; &amp;#34; &amp;quot; — 双引号 Quotation mark</span></span><br><span class="line"><span class="string"># &amp;#35; — 数字标志 Number sign</span></span><br><span class="line"><span class="string">$ &amp;#36; — 美元标志 Dollar sign</span></span><br><span class="line"><span class="string">% &amp;#37; — 百分号 Percent sign</span></span><br><span class="line"><span class="string">&amp; &amp;#38; &amp;amp; — 与符号(&amp;) Ampersand</span></span><br><span class="line"><span class="string">&#x27; &amp;#39; — 单引号 Apostrophe</span></span><br><span class="line"><span class="string">( &amp;#40; — 小括号左边部分 Left parenthesis</span></span><br><span class="line"><span class="string">) &amp;#41; — 小括号右边部分 Right parenthesis</span></span><br><span class="line"><span class="string">* &amp;#42; — 星号 Asterisk</span></span><br><span class="line"><span class="string">+ &amp;#43; — 加号 Plus sign</span></span><br><span class="line"><span class="string">&lt; &amp;#60; &amp;lt; 小于号 Less than</span></span><br><span class="line"><span class="string">= &amp;#61; — 等于符号 Equals sign</span></span><br><span class="line"><span class="string">- &amp;#45; &amp;minus; — 减号</span></span><br><span class="line"><span class="string">&gt; &amp;#62; &amp;gt; — 大于号 Greater than</span></span><br><span class="line"><span class="string">? &amp;#63; — 问号 Question mark</span></span><br><span class="line"><span class="string">@ &amp;#64; — Commercial at</span></span><br><span class="line"><span class="string">[ &amp;#91; — 中括号左边部分 Left square bracket</span></span><br><span class="line"><span class="string">\ &amp;#92; — 反斜杠 Reverse solidus (backslash)</span></span><br><span class="line"><span class="string">] &amp;#93; — 中括号右边部分 Right square bracket</span></span><br><span class="line"><span class="string">&#123; &amp;#123; — 大括号左边部分 Left curly brace</span></span><br><span class="line"><span class="string">| &amp;#124; — 竖线Vertical bar</span></span><br><span class="line"><span class="string">&#125; &amp;#125; — 大括号右边部分 Right curly brace</span></span><br><span class="line"><span class="string">空格 &amp;nbsp;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>666. Path Sum IV</title>
    <url>/2021/01/25/666-Path-Sum-IV/</url>
    <content><![CDATA[<p>dfs O(32) time O(16) space<br>generic</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            t[x / <span class="number">10</span>] = x % <span class="number">10</span>; <span class="comment">// 利用现有父子关系</span></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(t, <span class="number">11</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;t, <span class="keyword">int</span> i, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t.count(i)) <span class="keyword">return</span>;</span><br><span class="line">        s += t[i];</span><br><span class="line">        <span class="keyword">int</span> r = i + <span class="number">10</span> + i % <span class="number">10</span>, l = r - <span class="number">1</span>; <span class="comment">// 33-&gt;45和46即33-&gt;43然后43+3得到46再-1得到45</span></span><br><span class="line">        <span class="keyword">if</span> (!t.count(l) &amp;&amp; !t.count(r)) &#123;</span><br><span class="line">            res += s;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(t, l, s);</span><br><span class="line">        dfs(t, r, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            t[(<span class="number">1</span> &lt;&lt; (x / <span class="number">100</span> - <span class="number">1</span>)) + x % <span class="number">100</span> / <span class="number">10</span> - <span class="number">1</span>] = x % <span class="number">10</span>; <span class="comment">// 转成tree-like array</span></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;t, <span class="keyword">int</span> i, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t.count(i)) <span class="keyword">return</span>;</span><br><span class="line">        s += t[i];</span><br><span class="line">        <span class="keyword">int</span> l = i &lt;&lt; <span class="number">1</span>, r = l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!t.count(l) &amp;&amp; !t.count(r)) &#123;</span><br><span class="line">            res += s;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(t, l, s);</span><br><span class="line">        dfs(t, r, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dfs O(32) time O(32) space<br>array</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">32</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            t[(<span class="number">1</span> &lt;&lt; (x / <span class="number">100</span> - <span class="number">1</span>)) + x % <span class="number">100</span> / <span class="number">10</span> - <span class="number">1</span>] = x % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;t, <span class="keyword">int</span> i, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i] == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        s += t[i];</span><br><span class="line">        <span class="keyword">int</span> l = i &lt;&lt; <span class="number">1</span>, r = l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (t[l] == <span class="number">-1</span> &amp;&amp; t[r] == <span class="number">-1</span>) &#123;</span><br><span class="line">            res += s;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(t, l, s);</span><br><span class="line">        dfs(t, r, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 32&gt; t;</span><br><span class="line">        t.fill(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            t[(<span class="number">1</span> &lt;&lt; (x / <span class="number">100</span> - <span class="number">1</span>)) + x % <span class="number">100</span> / <span class="number">10</span> - <span class="number">1</span>] = x % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">32</span>&gt; &amp;t, <span class="keyword">int</span> i, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i] == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        s += t[i];</span><br><span class="line">        <span class="keyword">int</span> l = i &lt;&lt; <span class="number">1</span>, r = l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (t[l] == <span class="number">-1</span> &amp;&amp; t[r] == <span class="number">-1</span>) &#123;</span><br><span class="line">            res += s;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(t, l, s);</span><br><span class="line">        dfs(t, r, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            t[(<span class="number">1</span> &lt;&lt; (x / <span class="number">100</span> - <span class="number">1</span>)) + x % <span class="number">100</span> / <span class="number">10</span> - <span class="number">1</span>] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t[], <span class="keyword">int</span> i, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        s += t[i] % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> l = i &lt;&lt; <span class="number">1</span>, r = l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (t[l] == <span class="number">-1</span> &amp;&amp; t[r] == <span class="number">-1</span>) &#123;</span><br><span class="line">            res += s;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(t, l, s);</span><br><span class="line">        dfs(t, r, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Depth first search</tag>
        <tag>Binary tree</tag>
        <tag>Preorder traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>1041. Robot Bounded In Circle</title>
    <url>/2021/01/27/1041-Robot-Bounded-In-Circle/</url>
    <content><![CDATA[<p>O(n) time<br>判断是否能在一个circle里：</p>
<ol>
<li>跑一遍所有instructions之后能回到原点</li>
<li>即使不能回到原点，但是最后的方向跟初始不一样（只要方向不一样，跑两遍或者四遍还是回到原点）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRobotBounded</span><span class="params">(<span class="built_in">string</span> instructions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, i = <span class="number">0</span>, dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;; <span class="comment">// 方向顺序NESW</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : instructions) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: i = (i + <span class="number">3</span>) % <span class="number">4</span>; <span class="keyword">break</span>; <span class="comment">// 左拐等于右拐三次</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>: i = (i + <span class="number">1</span>) % <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: x += dx[i]; y += dy[i]; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span> || i &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRobotBounded</span><span class="params">(<span class="built_in">string</span> instructions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">0</span>, dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isBounded(x, y, d, dx, dy, instructions)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBounded</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y, <span class="keyword">int</span> &amp;d, <span class="keyword">int</span> dx[], <span class="keyword">int</span> dy[], <span class="keyword">const</span> <span class="built_in">string</span> &amp;ins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : ins) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: d = (d + <span class="number">3</span>) % <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>: d = (d + <span class="number">1</span>) % <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: x += dx[d]; y += dy[d]; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>1335. Minimum Difficulty of a Job Schedule</title>
    <url>/2021/01/29/1335-Minimum-Difficulty-of-a-Job-Schedule/</url>
    <content><![CDATA[<p>decreasing stack + dp O(nd) time O(n) space<br>f[i]表示经过day天后截至jobDifficulty[i]的最小困难结果，即f[day][i]<br>因为f[day][i] = min{f[day - 1][j] + max{jobDifficulty[j + 1 : i]}}，假设jobDifficulty[j]是jobDifficulty[i]左边第一个更大的数，则max{jobDifficulty[j + 1 : i]} = jobDifficulty[i]<br>f[day][i] = min{f[day][j], min{f[day - 1][j + 1 : i - 1]} + jobDifficulty[i]}<br>因为jobDifficulty[j] &gt; jobDifficulty[i]，所以f[day][j]的最后一个区间一定也可以cover整个jobDifficulty[j + 1 : i]区间，且根据归纳法f[day][j]一定不会比f[day - 1][j] + jobDifficulty[i]更差<br>找jobDifficulty[j]左边第一个更大的jobDifficulty[i]可以用单调栈，求min{f[day - 1][j + 1 : i - 1]}可以利用单调栈顺便保存每个小区间的前一天的最小困难结果，具体而言，如果单调栈所存下标为 k<sub>1</sub>,k<sub>2</sub>,…,k<sub>n</sub>，则在 k<sub>1</sub>的位置上额外存储区间[0, k<sub>1</sub>)的最小值，在k<sub>2</sub>的位置上额外存储区间[k<sub>1</sub>, k<sub>2</sub>)的最小值，以此类推</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDifficulty</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; jobDifficulty, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(jobDifficulty);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">3e5</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = jobDifficulty[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i] = max(f[i - <span class="number">1</span>], jobDifficulty[i]); <span class="comment">// 先算出第一天后的结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> day = <span class="number">1</span>; day &lt; d; ++day) &#123; <span class="comment">// d是1-based改成0-based</span></span><br><span class="line">            swap(t, f);</span><br><span class="line">            <span class="built_in">stack</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; s; <span class="comment">// &lt;区间最小困难结果，下标&gt;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = day; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> p = t[i - <span class="number">1</span>]; <span class="comment">// 初始化为前一天截至jobDifficulty[i - 1]的最小困难结果</span></span><br><span class="line">                <span class="keyword">while</span> (!empty(s) &amp;&amp; jobDifficulty[s.top().second] &lt;= jobDifficulty[i]) &#123;</span><br><span class="line">                    p = min(p, s.top().first); <span class="comment">// 用前一天前一个区间的最小困难结果来更新</span></span><br><span class="line">                    s.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (empty(s)) &#123;</span><br><span class="line">                    f[i] = p + jobDifficulty[i]; <span class="comment">// min&#123;f[day - 1][0 : i - 1]&#125; + jobDifficulty[i]</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i] = min(p + jobDifficulty[i], f[s.top().second]); <span class="comment">// min&#123;f[day][j], min&#123;f[day - 1][j + 1 : i - 1]&#125; + jobDifficulty[i]&#125;</span></span><br><span class="line">                &#125;</span><br><span class="line">                s.emplace(p, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDifficulty</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; jobDifficulty, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(jobDifficulty);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">3e5</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = jobDifficulty[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i] = max(f[i - <span class="number">1</span>], jobDifficulty[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(f)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> day = <span class="number">1</span>; day &lt; d; ++day) &#123;</span><br><span class="line">            swap(t, f);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 3&gt;&gt; s&#123;&#123;M, M, M&#125;&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = day; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> p = t[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span> (s.back()[<span class="number">1</span>] &lt;= jobDifficulty[i]) &#123;</span><br><span class="line">                    p = min(p, s.back()[<span class="number">0</span>]);</span><br><span class="line">                    s.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                s.push_back(&#123;p, jobDifficulty[i], min(p + jobDifficulty[i], s.back()[<span class="number">2</span>])&#125;);</span><br><span class="line">                f[i] = s.back()[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDifficulty</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; jobDifficulty, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(jobDifficulty);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">3e5</span> + <span class="number">1</span>;</span><br><span class="line">        vector&lt;int&gt; f(n, M), t(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> day = <span class="number">0</span>; day &lt; d; ++day) &#123;</span><br><span class="line">            swap(t, f);</span><br><span class="line">            <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = day; i &lt; n; ++i) &#123;</span><br><span class="line">                f[i] = i &gt; <span class="number">0</span> ? t[i - <span class="number">1</span>] + jobDifficulty[i] : jobDifficulty[i];</span><br><span class="line">                <span class="keyword">while</span> (!empty(s) &amp;&amp; jobDifficulty[s.top()] &lt;= jobDifficulty[i]) &#123;</span><br><span class="line">                    f[i] = min(f[i], f[s.top()] - jobDifficulty[s.top()] + jobDifficulty[i]);</span><br><span class="line">                    s.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!empty(s)) &#123;</span><br><span class="line">                    f[i] = min(f[i], f[s.top()]);</span><br><span class="line">                &#125;</span><br><span class="line">                s.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>bottom-up dp O(nnd) time O(nd) space<br>f[day][i]表示到第day天安排前i个job的最小难度<br>转移方程为<br>f[day][i] = min{f[day - 1][j] + max{jobDifficulty[j : i - 1]}} where j ~ [day - 1, i - 1]<br>初始化<br>f[0][0] = 0表示到第0天安排前0个job的最小难度为0<br>其他都为inf，在之后的计算过程中凡是有f[day][i] where i &lt; day的理论上都应该为inf<br>最终结果<br>f[d][n]<br>计算顺序<br>从前往后扫每天day，对于每天day，从前往后遍历每个i，再对每个i从后往前尝试每个j</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDifficulty</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; jobDifficulty, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(jobDifficulty);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">3e5</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(d + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, M));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> day = <span class="number">1</span>; day &lt;= d; ++day) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = day; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> mx = INT_MIN;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= day - <span class="number">1</span>; --j) &#123; <span class="comment">// j &gt;= 0也可以但是实际上应该是j &gt;= day - 1因为不可能出现比day - 1更小的j</span></span><br><span class="line">                    mx = max(mx, jobDifficulty[j]);</span><br><span class="line">                    f[day][i] = min(f[day][i], f[day - <span class="number">1</span>][j] + mx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[d][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>rolling array优化<br>O(nnd) time O(n) space<br>需要注意的是计算每个f[day][i]之前必须要重置为inf</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDifficulty</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; jobDifficulty, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(jobDifficulty);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">3e5</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, M));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> day = <span class="number">1</span>; day &lt;= d; ++day) &#123;</span><br><span class="line">            <span class="keyword">int</span> dd = day &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = day; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> mx = INT_MIN;</span><br><span class="line">                f[dd][i] = M;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= day - <span class="number">1</span>; --j) &#123;</span><br><span class="line">                    mx = max(mx, jobDifficulty[j]);</span><br><span class="line">                    f[dd][i] = min(f[dd][i], f[dd ^ <span class="number">1</span>][j] + mx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[d &amp; <span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDifficulty</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; jobDifficulty, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(jobDifficulty);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">3e5</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, M));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> day = <span class="number">1</span>; day &lt;= d; ++day) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = day; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> mx = INT_MIN;</span><br><span class="line">                f[day &amp; <span class="number">1</span>][i] = M;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= day - <span class="number">1</span>; --j) &#123;</span><br><span class="line">                    mx = max(mx, jobDifficulty[j]);</span><br><span class="line">                    f[day &amp; <span class="number">1</span>][i] = min(f[day &amp; <span class="number">1</span>][i], f[(day - <span class="number">1</span>) &amp; <span class="number">1</span>][j] + mx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[d &amp; <span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一维数组优化<br>O(nnd) time O(n) space<br>注意到每一行只跟前一行有关，对于每天day，可以改成从后往前遍历每个i，再对每个i从后往前尝试每个j</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDifficulty</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; jobDifficulty, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = size(jobDifficulty);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">3e5</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, M)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> day = <span class="number">1</span>; day &lt;= d; ++day) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= day; --i) &#123;</span><br><span class="line">                f[i] = M;</span><br><span class="line">                <span class="keyword">int</span> mx = INT_MIN;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= day - <span class="number">1</span>; --j) &#123;</span><br><span class="line">                    mx = max(mx, jobDifficulty[j]);</span><br><span class="line">                    f[i] = min(f[i], f[j] + mx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic programming</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts</title>
    <url>/2021/01/27/1465-Maximum-Area-of-a-Piece-of-Cake-After-Horizontal-and-Vertical-Cuts/</url>
    <content><![CDATA[<p>O(mlogm + nlogn) time O(1) space</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; horizontalCuts, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; verticalCuts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(h, horizontalCuts) * f(w, verticalCuts) % <span class="keyword">int</span>(<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> sz, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">        A.push_back(sz);</span><br><span class="line">        A.push_back(<span class="number">0</span>);</span><br><span class="line">        sort(begin(A), end(A));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size(A); ++i) &#123;</span><br><span class="line">            res = max(res, A[i] - A[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Implementation</tag>
      </tags>
  </entry>
  <entry>
    <title>About me</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p>Chang is currently a senior software engineer at <a href="https://www.mathworks.com/">MathWorks</a>. Before joining <a href="https://www.mathworks.com/">MathWorks</a>, he did research in network and communication system verification at <a href="https://vt.edu/">Virginia Tech</a> and got his master degree in computer engineering. He used to study information security and got his bachelor degree at <a href="http://en.nankai.edu.cn/">Nankai University</a> in Tianjin, China.</p>
]]></content>
  </entry>
  <entry>
    <title>Categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/README.html</url>
    <content><![CDATA[<h1 align="center"><a href="https://github.com/HubSpot/pace">Progress bar</a> for <a href="https://github.com/theme-next">NexT</a></h1>

<h1 align="center">Installation</h1>

<h2>If you want to use the CDN instead of clone this repo, please jump to the Step 3.</h2>

<h2 align="center">Step 1 &rarr; Go to NexT dir</h2>

<p>Change dir to <strong>NexT</strong> directory. There must be <code>layout</code>, <code>source</code>, <code>languages</code> and other directories:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes/next</span><br><span class="line">$ ls</span><br><span class="line">_config.yml  crowdin.yml  docs  gulpfile.js  languages  layout  LICENSE.md  package.json  README.md  scripts  <span class="built_in">source</span></span><br></pre></td></tr></table></figure>
<h2 align="center">Step 2 &rarr; Get module</h2>

<p>Install module to <code>source/lib</code> directory:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pace <span class="built_in">source</span>/lib/pace</span><br></pre></td></tr></table></figure>
<h2 align="center">Step 3 &rarr; Set it up</h2>

<p>Enable module in <strong>NexT</strong> <code>_config.yml</code> file and select your theme:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Themes list:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class="line">  <span class="comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">minimal</span></span><br></pre></td></tr></table></figure>
<p><strong>And, if you wants to use the CDN, then need to set:</strong> (you also need to find your corresponding theme css link in <a href="https://www.jsdelivr.com/package/npm/pace-js?path=themes">jsdelivr</a>)</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">pace:</span> <span class="string">//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js</span></span><br><span class="line">  <span class="attr">pace_css:</span> <span class="string">//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css</span></span><br></pre></td></tr></table></figure>
<h1 align="center">Update</h1>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes/next/<span class="built_in">source</span>/lib/pace</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-barber-shop.min.css</url>
    <content><![CDATA[.pace,.pace .pace-progress{width:100%;overflow:hidden}.pace,.pace .pace-activity{position:fixed;top:0;left:0}.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;z-index:2000;height:12px;background:#fff}.pace-inactive{display:none}.pace .pace-progress{background-color:#29d;position:fixed;top:0;bottom:0;right:100%}.pace .pace-activity{right:-32px;bottom:0;-webkit-transform:translate3d(0,0,0);-moz-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);-o-transform:translate3d(0,0,0);transform:translate3d(0,0,0);background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(.25,rgba(255,255,255,.2)),color-stop(.25,transparent),color-stop(.5,transparent),color-stop(.5,rgba(255,255,255,.2)),color-stop(.75,rgba(255,255,255,.2)),color-stop(.75,transparent),to(transparent));background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.2) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.2) 50%,rgba(255,255,255,.2) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(45deg,rgba(255,255,255,.2) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.2) 50%,rgba(255,255,255,.2) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.2) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.2) 50%,rgba(255,255,255,.2) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.2) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.2) 50%,rgba(255,255,255,.2) 75%,transparent 75%,transparent);-webkit-background-size:32px 32px;-moz-background-size:32px 32px;-o-background-size:32px 32px;background-size:32px 32px;-webkit-animation:pace-theme-barber-shop-motion .5s linear infinite;-moz-animation:pace-theme-barber-shop-motion .5s linear infinite;-ms-animation:pace-theme-barber-shop-motion .5s linear infinite;-o-animation:pace-theme-barber-shop-motion .5s linear infinite;animation:pace-theme-barber-shop-motion .5s linear infinite}@-webkit-keyframes pace-theme-barber-shop-motion{0%{-webkit-transform:none;transform:none}100%{-webkit-transform:translate(-32px,0);transform:translate(-32px,0)}}@-moz-keyframes pace-theme-barber-shop-motion{0%{-moz-transform:none;transform:none}100%{-moz-transform:translate(-32px,0);transform:translate(-32px,0)}}@-o-keyframes pace-theme-barber-shop-motion{0%{-o-transform:none;transform:none}100%{-o-transform:translate(-32px,0);transform:translate(-32px,0)}}@-ms-keyframes pace-theme-barber-shop-motion{0%{-ms-transform:none;transform:none}100%{-ms-transform:translate(-32px,0);transform:translate(-32px,0)}}@keyframes pace-theme-barber-shop-motion{0%{transform:none}100%{transform:translate(-32px,0)}}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-big-counter.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace.pace-inactive .pace-progress{display:none}.pace .pace-progress{position:fixed;z-index:2000;top:0;right:0;height:5rem;width:5rem;-webkit-transform:translate3d(0,0,0)!important;-ms-transform:translate3d(0,0,0)!important;transform:translate3d(0,0,0)!important}.pace .pace-progress:after{display:block;position:absolute;top:0;right:.5rem;content:attr(data-progress-text);font-family:"Helvetica Neue",sans-serif;font-weight:100;font-size:5rem;line-height:1;text-align:right;color:rgba(34,153,221,.19999999999999996)}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-bounce.min.css</url>
    <content><![CDATA[.pace{width:140px;height:300px;position:fixed;top:-90px;right:-20px;z-index:2000;-webkit-transform:scale(0);-moz-transform:scale(0);-ms-transform:scale(0);-o-transform:scale(0);transform:scale(0);opacity:0;-webkit-transition:all 2s linear 0s;-moz-transition:all 2s linear 0s;transition:all 2s linear 0s}.pace.pace-active{-webkit-transform:scale(.25);-moz-transform:scale(.25);-ms-transform:scale(.25);-o-transform:scale(.25);transform:scale(.25);opacity:1}.pace .pace-activity{width:140px;height:140px;border-radius:70px;background:#29d;position:absolute;top:0;z-index:1911;-webkit-animation:pace-bounce 1s infinite;-moz-animation:pace-bounce 1s infinite;-o-animation:pace-bounce 1s infinite;-ms-animation:pace-bounce 1s infinite;animation:pace-bounce 1s infinite}.pace .pace-progress{position:absolute;display:block;left:50%;bottom:0;z-index:1910;margin-left:-30px;width:60px;height:75px;background:rgba(20,20,20,.1);box-shadow:0 0 20px 35px rgba(20,20,20,.1);border-radius:30px/40px;-webkit-transform:scaleY(.3)!important;-moz-transform:scaleY(.3)!important;-ms-transform:scaleY(.3)!important;-o-transform:scaleY(.3)!important;transform:scaleY(.3)!important;-webkit-animation:pace-compress .5s infinite alternate;-moz-animation:pace-compress .5s infinite alternate;-o-animation:pace-compress .5s infinite alternate;-ms-animation:pace-compress .5s infinite alternate;animation:pace-compress .5s infinite alternate}@-webkit-keyframes pace-bounce{0%,100%,95%{top:0;-webkit-animation-timing-function:ease-in}50%{top:140px;height:140px;-webkit-animation-timing-function:ease-out}55%{top:160px;height:120px;border-radius:70px/60px;-webkit-animation-timing-function:ease-in}65%{top:120px;height:140px;border-radius:70px;-webkit-animation-timing-function:ease-out}}@-moz-keyframes pace-bounce{0%,100%,95%{top:0;-moz-animation-timing-function:ease-in}50%{top:140px;height:140px;-moz-animation-timing-function:ease-out}55%{top:160px;height:120px;border-radius:70px/60px;-moz-animation-timing-function:ease-in}65%{top:120px;height:140px;border-radius:70px;-moz-animation-timing-function:ease-out}}@keyframes pace-bounce{0%,100%,95%{top:0;animation-timing-function:ease-in}50%{top:140px;height:140px;animation-timing-function:ease-out}55%{top:160px;height:120px;border-radius:70px/60px;animation-timing-function:ease-in}65%{top:120px;height:140px;border-radius:70px;animation-timing-function:ease-out}}@-webkit-keyframes pace-compress{0%{bottom:0;margin-left:-30px;width:60px;height:75px;background:rgba(20,20,20,.1);box-shadow:0 0 20px 35px rgba(20,20,20,.1);border-radius:30px/40px;-webkit-animation-timing-function:ease-in}100%{bottom:30px;margin-left:-10px;width:20px;height:5px;background:rgba(20,20,20,.3);box-shadow:0 0 20px 35px rgba(20,20,20,.3);border-radius:20px;-webkit-animation-timing-function:ease-out}}@-moz-keyframes pace-compress{0%{bottom:0;margin-left:-30px;width:60px;height:75px;background:rgba(20,20,20,.1);box-shadow:0 0 20px 35px rgba(20,20,20,.1);border-radius:30px/40px;-moz-animation-timing-function:ease-in}100%{bottom:30px;margin-left:-10px;width:20px;height:5px;background:rgba(20,20,20,.3);box-shadow:0 0 20px 35px rgba(20,20,20,.3);border-radius:20px;-moz-animation-timing-function:ease-out}}@keyframes pace-compress{0%{bottom:0;margin-left:-30px;width:60px;height:75px;background:rgba(20,20,20,.1);box-shadow:0 0 20px 35px rgba(20,20,20,.1);border-radius:30px/40px;animation-timing-function:ease-in}100%{bottom:30px;margin-left:-10px;width:20px;height:5px;background:rgba(20,20,20,.3);box-shadow:0 0 20px 35px rgba(20,20,20,.3);border-radius:20px;animation-timing-function:ease-out}}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-center-atom.min.css</url>
    <content><![CDATA[.pace,.pace .pace-progress{z-index:2000;height:60px;width:100px}.pace .pace-activity,.pace .pace-progress:before{border-radius:50%;display:block;position:absolute}.pace.pace-inactive{display:none}.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;position:fixed;margin:auto;top:0;left:0;right:0;bottom:0}.pace .pace-progress{position:absolute;-webkit-transform:translate3d(0,0,0)!important;-ms-transform:translate3d(0,0,0)!important;transform:translate3d(0,0,0)!important}.pace .pace-progress:before{content:attr(data-progress-text);text-align:center;color:#fff;background:#29d;font-family:"Helvetica Neue",sans-serif;font-size:14px;font-weight:100;line-height:1;padding:20% 0 7px;width:50%;height:40%;margin:10px 0 0 30px;z-index:999}.pace .pace-activity{font-size:15px;line-height:1;z-index:2000;-webkit-animation:pace-theme-center-atom-spin 2s linear infinite;-moz-animation:pace-theme-center-atom-spin 2s linear infinite;-o-animation:pace-theme-center-atom-spin 2s linear infinite;animation:pace-theme-center-atom-spin 2s linear infinite;border:5px solid #29d;content:' ';top:0;left:0;height:60px;width:100px}.pace .pace-activity:after,.pace .pace-activity:before{content:' ';display:block;position:absolute;top:-5px;left:-5px;height:60px;width:100px}.pace .pace-activity:after{border-radius:50%;border:5px solid #29d;-webkit-transform:rotate(60deg);-moz-transform:rotate(60deg);-o-transform:rotate(60deg);transform:rotate(60deg)}.pace .pace-activity:before{border-radius:50%;border:5px solid #29d;-webkit-transform:rotate(120deg);-moz-transform:rotate(120deg);-o-transform:rotate(120deg);transform:rotate(120deg)}@-webkit-keyframes pace-theme-center-atom-spin{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(359deg)}}@-moz-keyframes pace-theme-center-atom-spin{0%{-moz-transform:rotate(0)}100%{-moz-transform:rotate(359deg)}}@-o-keyframes pace-theme-center-atom-spin{0%{-o-transform:rotate(0)}100%{-o-transform:rotate(359deg)}}@keyframes pace-theme-center-atom-spin{0%{transform:rotate(0)}100%{transform:rotate(359deg)}}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-center-circle.min.css</url>
    <content><![CDATA[.pace,.pace .pace-progress{z-index:2000;left:0;top:0;height:6rem}.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;-webkit-perspective:12rem;-moz-perspective:12rem;-ms-perspective:12rem;-o-perspective:12rem;perspective:12rem;position:fixed;width:6rem;margin:auto;right:0;bottom:0}.pace.pace-inactive .pace-progress{display:none}.pace .pace-progress{display:block;position:absolute;width:6rem!important;line-height:6rem;font-size:2rem;border-radius:50%;background:rgba(34,153,221,.8);color:#fff;font-family:"Helvetica Neue",sans-serif;font-weight:100;text-align:center;-webkit-animation:pace-theme-center-circle-spin linear infinite 2s;-moz-animation:pace-theme-center-circle-spin linear infinite 2s;-ms-animation:pace-theme-center-circle-spin linear infinite 2s;-o-animation:pace-theme-center-circle-spin linear infinite 2s;animation:pace-theme-center-circle-spin linear infinite 2s;-webkit-transform-style:preserve-3d;-moz-transform-style:preserve-3d;-ms-transform-style:preserve-3d;-o-transform-style:preserve-3d;transform-style:preserve-3d}.pace .pace-progress:after{content:attr(data-progress-text);display:block}@-webkit-keyframes pace-theme-center-circle-spin{from{-webkit-transform:rotateY(0)}to{-webkit-transform:rotateY(360deg)}}@-moz-keyframes pace-theme-center-circle-spin{from{-moz-transform:rotateY(0)}to{-moz-transform:rotateY(360deg)}}@-ms-keyframes pace-theme-center-circle-spin{from{-ms-transform:rotateY(0)}to{-ms-transform:rotateY(360deg)}}@-o-keyframes pace-theme-center-circle-spin{from{-o-transform:rotateY(0)}to{-o-transform:rotateY(360deg)}}@keyframes pace-theme-center-circle-spin{from{transform:rotateY(0)}to{transform:rotateY(360deg)}}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-center-radar.min.css</url>
    <content><![CDATA[.pace,.pace .pace-activity{z-index:2000;height:90px;width:90px}.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;position:fixed;margin:auto;top:0;left:0;right:0;bottom:0}.pace.pace-inactive .pace-activity{display:none}.pace .pace-activity,.pace .pace-activity:before{position:absolute;display:block;border-color:#29d transparent transparent;border-radius:50%}.pace .pace-activity{left:-30px;top:-30px;border-width:30px;border-style:double;-webkit-animation:spin 1s linear infinite;-moz-animation:spin 1s linear infinite;-o-animation:spin 1s linear infinite;animation:spin 1s linear infinite}.pace .pace-activity:before{content:' ';top:10px;left:10px;height:50px;width:50px;border-width:10px;border-style:solid}@-webkit-keyframes spin{100%{-webkit-transform:rotate(359deg)}}@-moz-keyframes spin{100%{-moz-transform:rotate(359deg)}}@-o-keyframes spin{100%{-moz-transform:rotate(359deg)}}@keyframes spin{100%{transform:rotate(359deg)}}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-center-simple.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;z-index:2000;position:fixed;margin:auto;top:0;left:0;right:0;bottom:0;height:5px;width:200px;background:#fff;border:1px solid #29d;overflow:hidden}.pace .pace-progress{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;-o-box-sizing:border-box;box-sizing:border-box;-webkit-transform:translate3d(0,0,0);-moz-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);-o-transform:translate3d(0,0,0);transform:translate3d(0,0,0);max-width:200px;z-index:2000;display:block;position:absolute;top:0;right:100%;height:100%;width:100%;background:#29d}.pace.pace-inactive{display:none}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-corner-indicator.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace .pace-activity{display:block;position:fixed;z-index:2000;top:0;right:0;width:300px;height:300px;background:#29d;-webkit-transition:-webkit-transform .3s;transition:transform .3s;-webkit-transform:translateX(100%) translateY(-100%) rotate(45deg);transform:translateX(100%) translateY(-100%) rotate(45deg);pointer-events:none}.pace.pace-active .pace-activity{-webkit-transform:translateX(50%) translateY(-50%) rotate(45deg);transform:translateX(50%) translateY(-50%) rotate(45deg)}.pace .pace-activity::after,.pace .pace-activity::before{-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;bottom:30px;left:50%;display:block;border:5px solid #fff;border-radius:50%;content:''}.pace .pace-activity::before{margin-left:-40px;width:80px;height:80px;border-right-color:rgba(0,0,0,.2);border-left-color:rgba(0,0,0,.2);-webkit-animation:pace-theme-corner-indicator-spin 3s linear infinite;animation:pace-theme-corner-indicator-spin 3s linear infinite}.pace .pace-activity::after{bottom:50px;margin-left:-20px;width:40px;height:40px;border-top-color:rgba(0,0,0,.2);border-bottom-color:rgba(0,0,0,.2);-webkit-animation:pace-theme-corner-indicator-spin 1s linear infinite;animation:pace-theme-corner-indicator-spin 1s linear infinite}@-webkit-keyframes pace-theme-corner-indicator-spin{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(359deg)}}@keyframes pace-theme-corner-indicator-spin{0%{transform:rotate(0)}100%{transform:rotate(359deg)}}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-fill-left.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background-color:rgba(34,153,221,.19999999999999996);position:fixed;z-index:-1;top:0;right:100%;bottom:0;width:100%}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-flash.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#29d;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}.pace .pace-progress-inner{display:block;position:absolute;right:0;width:100px;height:100%;box-shadow:0 0 10px #29d,0 0 5px #29d;opacity:1;-webkit-transform:rotate(3deg) translate(0,-4px);-moz-transform:rotate(3deg) translate(0,-4px);-ms-transform:rotate(3deg) translate(0,-4px);-o-transform:rotate(3deg) translate(0,-4px);transform:rotate(3deg) translate(0,-4px)}.pace .pace-activity{display:block;position:fixed;z-index:2000;top:15px;right:15px;width:14px;height:14px;border:2px solid transparent;border-top-color:#29d;border-left-color:#29d;border-radius:10px;-webkit-animation:pace-spinner .4s linear infinite;-moz-animation:pace-spinner .4s linear infinite;-ms-animation:pace-spinner .4s linear infinite;-o-animation:pace-spinner .4s linear infinite;animation:pace-spinner .4s linear infinite}@-webkit-keyframes pace-spinner{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-moz-keyframes pace-spinner{0%{-moz-transform:rotate(0);transform:rotate(0)}100%{-moz-transform:rotate(360deg);transform:rotate(360deg)}}@-o-keyframes pace-spinner{0%{-o-transform:rotate(0);transform:rotate(0)}100%{-o-transform:rotate(360deg);transform:rotate(360deg)}}@-ms-keyframes pace-spinner{0%{-ms-transform:rotate(0);transform:rotate(0)}100%{-ms-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes pace-spinner{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-flat-top.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;position:fixed;top:0;left:0;width:100%;-webkit-transform:translate3d(0,-50px,0);-ms-transform:translate3d(0,-50px,0);transform:translate3d(0,-50px,0);-webkit-transition:-webkit-transform .5s ease-out;-ms-transition:-webkit-transform .5s ease-out;transition:transform .5s ease-out}.pace.pace-active{-webkit-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.pace .pace-progress{display:block;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:10px;background:#29d;pointer-events:none}
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-loading-bar.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;-o-box-sizing:border-box;box-sizing:border-box;-webkit-border-radius:10px;-moz-border-radius:10px;border-radius:10px;-webkit-background-clip:padding-box;-moz-background-clip:padding;background-clip:padding-box;z-index:2000;position:fixed;margin:auto;top:12px;left:0;right:0;bottom:0;width:200px;height:50px;overflow:hidden}.pace .pace-progress{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;-o-box-sizing:border-box;box-sizing:border-box;-webkit-border-radius:2px;-moz-border-radius:2px;border-radius:2px;-webkit-background-clip:padding-box;-moz-background-clip:padding;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);display:block;position:absolute;right:100%;margin-right:-7px;width:93%;top:7px;height:14px;font-size:12px;background:#29d;color:#29d;line-height:60px;font-weight:700;font-family:Helvetica,Arial,"Lucida Grande",sans-serif;-webkit-box-shadow:120px 0 #fff,240px 0 #fff;-ms-box-shadow:120px 0 #fff,240px 0 #fff;box-shadow:120px 0 #fff,240px 0 #fff}.pace .pace-progress:after{content:attr(data-progress-text);display:inline-block;position:fixed;width:45px;text-align:right;right:0;padding-right:16px;top:4px}.pace .pace-progress[data-progress-text="0%"]:after{right:-200px}.pace .pace-progress[data-progress-text="1%"]:after{right:-198.14px}.pace .pace-progress[data-progress-text="2%"]:after{right:-196.28px}.pace .pace-progress[data-progress-text="3%"]:after{right:-194.42px}.pace .pace-progress[data-progress-text="4%"]:after{right:-192.56px}.pace .pace-progress[data-progress-text="5%"]:after{right:-190.7px}.pace .pace-progress[data-progress-text="6%"]:after{right:-188.84px}.pace .pace-progress[data-progress-text="7%"]:after{right:-186.98px}.pace .pace-progress[data-progress-text="8%"]:after{right:-185.12px}.pace .pace-progress[data-progress-text="9%"]:after{right:-183.26px}.pace .pace-progress[data-progress-text="10%"]:after{right:-181.4px}.pace .pace-progress[data-progress-text="11%"]:after{right:-179.54px}.pace .pace-progress[data-progress-text="12%"]:after{right:-177.68px}.pace .pace-progress[data-progress-text="13%"]:after{right:-175.82px}.pace .pace-progress[data-progress-text="14%"]:after{right:-173.96px}.pace .pace-progress[data-progress-text="15%"]:after{right:-172.1px}.pace .pace-progress[data-progress-text="16%"]:after{right:-170.24px}.pace .pace-progress[data-progress-text="17%"]:after{right:-168.38px}.pace .pace-progress[data-progress-text="18%"]:after{right:-166.52px}.pace .pace-progress[data-progress-text="19%"]:after{right:-164.66px}.pace .pace-progress[data-progress-text="20%"]:after{right:-162.8px}.pace .pace-progress[data-progress-text="21%"]:after{right:-160.94px}.pace .pace-progress[data-progress-text="22%"]:after{right:-159.08px}.pace .pace-progress[data-progress-text="23%"]:after{right:-157.22px}.pace .pace-progress[data-progress-text="24%"]:after{right:-155.36px}.pace .pace-progress[data-progress-text="25%"]:after{right:-153.5px}.pace .pace-progress[data-progress-text="26%"]:after{right:-151.64px}.pace .pace-progress[data-progress-text="27%"]:after{right:-149.78px}.pace .pace-progress[data-progress-text="28%"]:after{right:-147.92px}.pace .pace-progress[data-progress-text="29%"]:after{right:-146.06px}.pace .pace-progress[data-progress-text="30%"]:after{right:-144.2px}.pace .pace-progress[data-progress-text="31%"]:after{right:-142.34px}.pace .pace-progress[data-progress-text="32%"]:after{right:-140.48px}.pace .pace-progress[data-progress-text="33%"]:after{right:-138.62px}.pace .pace-progress[data-progress-text="34%"]:after{right:-136.76px}.pace .pace-progress[data-progress-text="35%"]:after{right:-134.9px}.pace .pace-progress[data-progress-text="36%"]:after{right:-133.04px}.pace .pace-progress[data-progress-text="37%"]:after{right:-131.18px}.pace .pace-progress[data-progress-text="38%"]:after{right:-129.32px}.pace .pace-progress[data-progress-text="39%"]:after{right:-127.46px}.pace .pace-progress[data-progress-text="40%"]:after{right:-125.6px}.pace .pace-progress[data-progress-text="41%"]:after{right:-123.74px}.pace .pace-progress[data-progress-text="42%"]:after{right:-121.88px}.pace .pace-progress[data-progress-text="43%"]:after{right:-120.02px}.pace .pace-progress[data-progress-text="44%"]:after{right:-118.16px}.pace .pace-progress[data-progress-text="45%"]:after{right:-116.3px}.pace .pace-progress[data-progress-text="46%"]:after{right:-114.44px}.pace .pace-progress[data-progress-text="47%"]:after{right:-112.58px}.pace .pace-progress[data-progress-text="48%"]:after{right:-110.72px}.pace .pace-progress[data-progress-text="49%"]:after{right:-108.86px}.pace .pace-progress[data-progress-text="50%"]:after{right:-107px}.pace .pace-progress[data-progress-text="51%"]:after{right:-105.14px}.pace .pace-progress[data-progress-text="52%"]:after{right:-103.28px}.pace .pace-progress[data-progress-text="53%"]:after{right:-101.42px}.pace .pace-progress[data-progress-text="54%"]:after{right:-99.56px}.pace .pace-progress[data-progress-text="55%"]:after{right:-97.7px}.pace .pace-progress[data-progress-text="56%"]:after{right:-95.84px}.pace .pace-progress[data-progress-text="57%"]:after{right:-93.98px}.pace .pace-progress[data-progress-text="58%"]:after{right:-92.12px}.pace .pace-progress[data-progress-text="59%"]:after{right:-90.26px}.pace .pace-progress[data-progress-text="60%"]:after{right:-88.4px}.pace .pace-progress[data-progress-text="61%"]:after{right:-86.54px}.pace .pace-progress[data-progress-text="62%"]:after{right:-84.68px}.pace .pace-progress[data-progress-text="63%"]:after{right:-82.82px}.pace .pace-progress[data-progress-text="64%"]:after{right:-80.96px}.pace .pace-progress[data-progress-text="65%"]:after{right:-79.1px}.pace .pace-progress[data-progress-text="66%"]:after{right:-77.24px}.pace .pace-progress[data-progress-text="67%"]:after{right:-75.38px}.pace .pace-progress[data-progress-text="68%"]:after{right:-73.52px}.pace .pace-progress[data-progress-text="69%"]:after{right:-71.66px}.pace .pace-progress[data-progress-text="70%"]:after{right:-69.8px}.pace .pace-progress[data-progress-text="71%"]:after{right:-67.94px}.pace .pace-progress[data-progress-text="72%"]:after{right:-66.08px}.pace .pace-progress[data-progress-text="73%"]:after{right:-64.22px}.pace .pace-progress[data-progress-text="74%"]:after{right:-62.36px}.pace .pace-progress[data-progress-text="75%"]:after{right:-60.5px}.pace .pace-progress[data-progress-text="76%"]:after{right:-58.64px}.pace .pace-progress[data-progress-text="77%"]:after{right:-56.78px}.pace .pace-progress[data-progress-text="78%"]:after{right:-54.92px}.pace .pace-progress[data-progress-text="79%"]:after{right:-53.06px}.pace .pace-progress[data-progress-text="80%"]:after{right:-51.2px}.pace .pace-progress[data-progress-text="81%"]:after{right:-49.34px}.pace .pace-progress[data-progress-text="82%"]:after{right:-47.48px}.pace .pace-progress[data-progress-text="83%"]:after{right:-45.62px}.pace .pace-progress[data-progress-text="84%"]:after{right:-43.76px}.pace .pace-progress[data-progress-text="85%"]:after{right:-41.9px}.pace .pace-progress[data-progress-text="86%"]:after{right:-40.04px}.pace .pace-progress[data-progress-text="87%"]:after{right:-38.18px}.pace .pace-progress[data-progress-text="88%"]:after{right:-36.32px}.pace .pace-progress[data-progress-text="89%"]:after{right:-34.46px}.pace .pace-progress[data-progress-text="90%"]:after{right:-32.6px}.pace .pace-progress[data-progress-text="91%"]:after{right:-30.74px}.pace .pace-progress[data-progress-text="92%"]:after{right:-28.88px}.pace .pace-progress[data-progress-text="93%"]:after{right:-27.02px}.pace .pace-progress[data-progress-text="94%"]:after{right:-25.16px}.pace .pace-progress[data-progress-text="95%"]:after{right:-23.3px}.pace .pace-progress[data-progress-text="96%"]:after{right:-21.44px}.pace .pace-progress[data-progress-text="97%"]:after{right:-19.58px}.pace .pace-progress[data-progress-text="98%"]:after{right:-17.72px}.pace .pace-progress[data-progress-text="99%"]:after{right:-15.86px}.pace .pace-progress[data-progress-text="100%"]:after{right:-14px}.pace .pace-activity{position:absolute;width:100%;height:28px;z-index:2001;box-shadow:inset 0 0 0 2px #29d,inset 0 0 0 7px #FFF;border-radius:10px}.pace.pace-inactive{display:none}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-mac-osx.min.css</url>
    <content><![CDATA[.pace,.pace .pace-progress{width:100%;height:12px;overflow:hidden}.pace,.pace .pace-activity{position:fixed;top:0;left:0}.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;z-index:2000;background:#fff}.pace-inactive{display:none}.pace .pace-progress{background-color:#0087E1;position:fixed;top:0;right:100%;-webkit-border-radius:0 0 4px;-moz-border-radius:0 0 4px;-o-border-radius:0 0 4px;border-radius:0 0 4px;-webkit-box-shadow:inset -1px 0 #00558F,inset 0 -1px #00558F,inset 0 2px rgba(255,255,255,.5),inset 0 6px rgba(255,255,255,.3);-moz-box-shadow:inset -1px 0 #00558F,inset 0 -1px #00558F,inset 0 2px rgba(255,255,255,.5),inset 0 6px rgba(255,255,255,.3);-o-box-shadow:inset -1px 0 #00558F,inset 0 -1px #00558F,inset 0 2px rgba(255,255,255,.5),inset 0 6px rgba(255,255,255,.3);box-shadow:inset -1px 0 #00558F,inset 0 -1px #00558F,inset 0 2px rgba(255,255,255,.5),inset 0 6px rgba(255,255,255,.3)}.pace .pace-activity{right:-28px;bottom:0;-webkit-background-image:radial-gradient(rgba(255,255,255,.65) 0,rgba(255,255,255,.15) 100%);-moz-background-image:radial-gradient(rgba(255,255,255,.65) 0,rgba(255,255,255,.15) 100%);-o-background-image:radial-gradient(rgba(255,255,255,.65) 0,rgba(255,255,255,.15) 100%);background-image:radial-gradient(rgba(255,255,255,.65) 0,rgba(255,255,255,.15) 100%);-webkit-background-size:28px 100%;-moz-background-size:28px 100%;-o-background-size:28px 100%;background-size:28px 100%;-webkit-animation:pace-theme-mac-osx-motion .5s linear infinite;-moz-animation:pace-theme-mac-osx-motion .5s linear infinite;-ms-animation:pace-theme-mac-osx-motion .5s linear infinite;-o-animation:pace-theme-mac-osx-motion .5s linear infinite;animation:pace-theme-mac-osx-motion .5s linear infinite}@-webkit-keyframes pace-theme-mac-osx-motion{0%{-webkit-transform:none;transform:none}100%{-webkit-transform:translate(-28px,0);transform:translate(-28px,0)}}@-moz-keyframes pace-theme-mac-osx-motion{0%{-moz-transform:none;transform:none}100%{-moz-transform:translate(-28px,0);transform:translate(-28px,0)}}@-o-keyframes pace-theme-mac-osx-motion{0%{-o-transform:none;transform:none}100%{-o-transform:translate(-28px,0);transform:translate(-28px,0)}}@-ms-keyframes pace-theme-mac-osx-motion{0%{-ms-transform:none;transform:none}100%{-ms-transform:translate(-28px,0);transform:translate(-28px,0)}}@keyframes pace-theme-mac-osx-motion{0%{transform:none}100%{transform:translate(-28px,0)}}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-minimal.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#29d;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace.min.js</url>
    <content><![CDATA[/*! pace 1.0.2 */
(function(){var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X=[].slice,Y={}.hasOwnProperty,Z=function(a,b){function c(){this.constructor=a}for(var d in b)Y.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a},$=[].indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(b in this&&this[b]===a)return b;return-1};for(u={catchupTime:100,initialRate:.03,minTime:250,ghostTime:100,maxProgressPerFrame:20,easeFactor:1.25,startOnPageLoad:!0,restartOnPushState:!0,restartOnRequestAfter:500,target:"body",elements:{checkInterval:100,selectors:["body"]},eventLag:{minSamples:10,sampleCount:3,lagThreshold:3},ajax:{trackMethods:["GET"],trackWebSockets:!0,ignoreURLs:[]}},C=function(){var a;return null!=(a="undefined"!=typeof performance&&null!==performance&&"function"==typeof performance.now?performance.now():void 0)?a:+new Date},E=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame,t=window.cancelAnimationFrame||window.mozCancelAnimationFrame,null==E&&(E=function(a){return setTimeout(a,50)},t=function(a){return clearTimeout(a)}),G=function(a){var b,c;return b=C(),(c=function(){var d;return d=C()-b,d>=33?(b=C(),a(d,function(){return E(c)})):setTimeout(c,33-d)})()},F=function(){var a,b,c;return c=arguments[0],b=arguments[1],a=3<=arguments.length?X.call(arguments,2):[],"function"==typeof c[b]?c[b].apply(c,a):c[b]},v=function(){var a,b,c,d,e,f,g;for(b=arguments[0],d=2<=arguments.length?X.call(arguments,1):[],f=0,g=d.length;g>f;f++)if(c=d[f])for(a in c)Y.call(c,a)&&(e=c[a],null!=b[a]&&"object"==typeof b[a]&&null!=e&&"object"==typeof e?v(b[a],e):b[a]=e);return b},q=function(a){var b,c,d,e,f;for(c=b=0,e=0,f=a.length;f>e;e++)d=a[e],c+=Math.abs(d),b++;return c/b},x=function(a,b){var c,d,e;if(null==a&&(a="options"),null==b&&(b=!0),e=document.querySelector("[data-pace-"+a+"]")){if(c=e.getAttribute("data-pace-"+a),!b)return c;try{return JSON.parse(c)}catch(f){return d=f,"undefined"!=typeof console&&null!==console?console.error("Error parsing inline pace options",d):void 0}}},g=function(){function a(){}return a.prototype.on=function(a,b,c,d){var e;return null==d&&(d=!1),null==this.bindings&&(this.bindings={}),null==(e=this.bindings)[a]&&(e[a]=[]),this.bindings[a].push({handler:b,ctx:c,once:d})},a.prototype.once=function(a,b,c){return this.on(a,b,c,!0)},a.prototype.off=function(a,b){var c,d,e;if(null!=(null!=(d=this.bindings)?d[a]:void 0)){if(null==b)return delete this.bindings[a];for(c=0,e=[];c<this.bindings[a].length;)e.push(this.bindings[a][c].handler===b?this.bindings[a].splice(c,1):c++);return e}},a.prototype.trigger=function(){var a,b,c,d,e,f,g,h,i;if(c=arguments[0],a=2<=arguments.length?X.call(arguments,1):[],null!=(g=this.bindings)?g[c]:void 0){for(e=0,i=[];e<this.bindings[c].length;)h=this.bindings[c][e],d=h.handler,b=h.ctx,f=h.once,d.apply(null!=b?b:this,a),i.push(f?this.bindings[c].splice(e,1):e++);return i}},a}(),j=window.Pace||{},window.Pace=j,v(j,g.prototype),D=j.options=v({},u,window.paceOptions,x()),U=["ajax","document","eventLag","elements"],Q=0,S=U.length;S>Q;Q++)K=U[Q],D[K]===!0&&(D[K]=u[K]);i=function(a){function b(){return V=b.__super__.constructor.apply(this,arguments)}return Z(b,a),b}(Error),b=function(){function a(){this.progress=0}return a.prototype.getElement=function(){var a;if(null==this.el){if(a=document.querySelector(D.target),!a)throw new i;this.el=document.createElement("div"),this.el.className="pace pace-active",document.body.className=document.body.className.replace(/pace-done/g,""),document.body.className+=" pace-running",this.el.innerHTML='<div class="pace-progress">\n  <div class="pace-progress-inner"></div>\n</div>\n<div class="pace-activity"></div>',null!=a.firstChild?a.insertBefore(this.el,a.firstChild):a.appendChild(this.el)}return this.el},a.prototype.finish=function(){var a;return a=this.getElement(),a.className=a.className.replace("pace-active",""),a.className+=" pace-inactive",document.body.className=document.body.className.replace("pace-running",""),document.body.className+=" pace-done"},a.prototype.update=function(a){return this.progress=a,this.render()},a.prototype.destroy=function(){try{this.getElement().parentNode.removeChild(this.getElement())}catch(a){i=a}return this.el=void 0},a.prototype.render=function(){var a,b,c,d,e,f,g;if(null==document.querySelector(D.target))return!1;for(a=this.getElement(),d="translate3d("+this.progress+"%, 0, 0)",g=["webkitTransform","msTransform","transform"],e=0,f=g.length;f>e;e++)b=g[e],a.children[0].style[b]=d;return(!this.lastRenderedProgress||this.lastRenderedProgress|0!==this.progress|0)&&(a.children[0].setAttribute("data-progress-text",""+(0|this.progress)+"%"),this.progress>=100?c="99":(c=this.progress<10?"0":"",c+=0|this.progress),a.children[0].setAttribute("data-progress",""+c)),this.lastRenderedProgress=this.progress},a.prototype.done=function(){return this.progress>=100},a}(),h=function(){function a(){this.bindings={}}return a.prototype.trigger=function(a,b){var c,d,e,f,g;if(null!=this.bindings[a]){for(f=this.bindings[a],g=[],d=0,e=f.length;e>d;d++)c=f[d],g.push(c.call(this,b));return g}},a.prototype.on=function(a,b){var c;return null==(c=this.bindings)[a]&&(c[a]=[]),this.bindings[a].push(b)},a}(),P=window.XMLHttpRequest,O=window.XDomainRequest,N=window.WebSocket,w=function(a,b){var c,d,e;e=[];for(d in b.prototype)try{e.push(null==a[d]&&"function"!=typeof b[d]?"function"==typeof Object.defineProperty?Object.defineProperty(a,d,{get:function(){return b.prototype[d]},configurable:!0,enumerable:!0}):a[d]=b.prototype[d]:void 0)}catch(f){c=f}return e},A=[],j.ignore=function(){var a,b,c;return b=arguments[0],a=2<=arguments.length?X.call(arguments,1):[],A.unshift("ignore"),c=b.apply(null,a),A.shift(),c},j.track=function(){var a,b,c;return b=arguments[0],a=2<=arguments.length?X.call(arguments,1):[],A.unshift("track"),c=b.apply(null,a),A.shift(),c},J=function(a){var b;if(null==a&&(a="GET"),"track"===A[0])return"force";if(!A.length&&D.ajax){if("socket"===a&&D.ajax.trackWebSockets)return!0;if(b=a.toUpperCase(),$.call(D.ajax.trackMethods,b)>=0)return!0}return!1},k=function(a){function b(){var a,c=this;b.__super__.constructor.apply(this,arguments),a=function(a){var b;return b=a.open,a.open=function(d,e){return J(d)&&c.trigger("request",{type:d,url:e,request:a}),b.apply(a,arguments)}},window.XMLHttpRequest=function(b){var c;return c=new P(b),a(c),c};try{w(window.XMLHttpRequest,P)}catch(d){}if(null!=O){window.XDomainRequest=function(){var b;return b=new O,a(b),b};try{w(window.XDomainRequest,O)}catch(d){}}if(null!=N&&D.ajax.trackWebSockets){window.WebSocket=function(a,b){var d;return d=null!=b?new N(a,b):new N(a),J("socket")&&c.trigger("request",{type:"socket",url:a,protocols:b,request:d}),d};try{w(window.WebSocket,N)}catch(d){}}}return Z(b,a),b}(h),R=null,y=function(){return null==R&&(R=new k),R},I=function(a){var b,c,d,e;for(e=D.ajax.ignoreURLs,c=0,d=e.length;d>c;c++)if(b=e[c],"string"==typeof b){if(-1!==a.indexOf(b))return!0}else if(b.test(a))return!0;return!1},y().on("request",function(b){var c,d,e,f,g;return f=b.type,e=b.request,g=b.url,I(g)?void 0:j.running||D.restartOnRequestAfter===!1&&"force"!==J(f)?void 0:(d=arguments,c=D.restartOnRequestAfter||0,"boolean"==typeof c&&(c=0),setTimeout(function(){var b,c,g,h,i,k;if(b="socket"===f?e.readyState<2:0<(h=e.readyState)&&4>h){for(j.restart(),i=j.sources,k=[],c=0,g=i.length;g>c;c++){if(K=i[c],K instanceof a){K.watch.apply(K,d);break}k.push(void 0)}return k}},c))}),a=function(){function a(){var a=this;this.elements=[],y().on("request",function(){return a.watch.apply(a,arguments)})}return a.prototype.watch=function(a){var b,c,d,e;return d=a.type,b=a.request,e=a.url,I(e)?void 0:(c="socket"===d?new n(b):new o(b),this.elements.push(c))},a}(),o=function(){function a(a){var b,c,d,e,f,g,h=this;if(this.progress=0,null!=window.ProgressEvent)for(c=null,a.addEventListener("progress",function(a){return h.progress=a.lengthComputable?100*a.loaded/a.total:h.progress+(100-h.progress)/2},!1),g=["load","abort","timeout","error"],d=0,e=g.length;e>d;d++)b=g[d],a.addEventListener(b,function(){return h.progress=100},!1);else f=a.onreadystatechange,a.onreadystatechange=function(){var b;return 0===(b=a.readyState)||4===b?h.progress=100:3===a.readyState&&(h.progress=50),"function"==typeof f?f.apply(null,arguments):void 0}}return a}(),n=function(){function a(a){var b,c,d,e,f=this;for(this.progress=0,e=["error","open"],c=0,d=e.length;d>c;c++)b=e[c],a.addEventListener(b,function(){return f.progress=100},!1)}return a}(),d=function(){function a(a){var b,c,d,f;for(null==a&&(a={}),this.elements=[],null==a.selectors&&(a.selectors=[]),f=a.selectors,c=0,d=f.length;d>c;c++)b=f[c],this.elements.push(new e(b))}return a}(),e=function(){function a(a){this.selector=a,this.progress=0,this.check()}return a.prototype.check=function(){var a=this;return document.querySelector(this.selector)?this.done():setTimeout(function(){return a.check()},D.elements.checkInterval)},a.prototype.done=function(){return this.progress=100},a}(),c=function(){function a(){var a,b,c=this;this.progress=null!=(b=this.states[document.readyState])?b:100,a=document.onreadystatechange,document.onreadystatechange=function(){return null!=c.states[document.readyState]&&(c.progress=c.states[document.readyState]),"function"==typeof a?a.apply(null,arguments):void 0}}return a.prototype.states={loading:0,interactive:50,complete:100},a}(),f=function(){function a(){var a,b,c,d,e,f=this;this.progress=0,a=0,e=[],d=0,c=C(),b=setInterval(function(){var g;return g=C()-c-50,c=C(),e.push(g),e.length>D.eventLag.sampleCount&&e.shift(),a=q(e),++d>=D.eventLag.minSamples&&a<D.eventLag.lagThreshold?(f.progress=100,clearInterval(b)):f.progress=100*(3/(a+3))},50)}return a}(),m=function(){function a(a){this.source=a,this.last=this.sinceLastUpdate=0,this.rate=D.initialRate,this.catchup=0,this.progress=this.lastProgress=0,null!=this.source&&(this.progress=F(this.source,"progress"))}return a.prototype.tick=function(a,b){var c;return null==b&&(b=F(this.source,"progress")),b>=100&&(this.done=!0),b===this.last?this.sinceLastUpdate+=a:(this.sinceLastUpdate&&(this.rate=(b-this.last)/this.sinceLastUpdate),this.catchup=(b-this.progress)/D.catchupTime,this.sinceLastUpdate=0,this.last=b),b>this.progress&&(this.progress+=this.catchup*a),c=1-Math.pow(this.progress/100,D.easeFactor),this.progress+=c*this.rate*a,this.progress=Math.min(this.lastProgress+D.maxProgressPerFrame,this.progress),this.progress=Math.max(0,this.progress),this.progress=Math.min(100,this.progress),this.lastProgress=this.progress,this.progress},a}(),L=null,H=null,r=null,M=null,p=null,s=null,j.running=!1,z=function(){return D.restartOnPushState?j.restart():void 0},null!=window.history.pushState&&(T=window.history.pushState,window.history.pushState=function(){return z(),T.apply(window.history,arguments)}),null!=window.history.replaceState&&(W=window.history.replaceState,window.history.replaceState=function(){return z(),W.apply(window.history,arguments)}),l={ajax:a,elements:d,document:c,eventLag:f},(B=function(){var a,c,d,e,f,g,h,i;for(j.sources=L=[],g=["ajax","elements","document","eventLag"],c=0,e=g.length;e>c;c++)a=g[c],D[a]!==!1&&L.push(new l[a](D[a]));for(i=null!=(h=D.extraSources)?h:[],d=0,f=i.length;f>d;d++)K=i[d],L.push(new K(D));return j.bar=r=new b,H=[],M=new m})(),j.stop=function(){return j.trigger("stop"),j.running=!1,r.destroy(),s=!0,null!=p&&("function"==typeof t&&t(p),p=null),B()},j.restart=function(){return j.trigger("restart"),j.stop(),j.start()},j.go=function(){var a;return j.running=!0,r.render(),a=C(),s=!1,p=G(function(b,c){var d,e,f,g,h,i,k,l,n,o,p,q,t,u,v,w;for(l=100-r.progress,e=p=0,f=!0,i=q=0,u=L.length;u>q;i=++q)for(K=L[i],o=null!=H[i]?H[i]:H[i]=[],h=null!=(w=K.elements)?w:[K],k=t=0,v=h.length;v>t;k=++t)g=h[k],n=null!=o[k]?o[k]:o[k]=new m(g),f&=n.done,n.done||(e++,p+=n.tick(b));return d=p/e,r.update(M.tick(b,d)),r.done()||f||s?(r.update(100),j.trigger("done"),setTimeout(function(){return r.finish(),j.running=!1,j.trigger("hide")},Math.max(D.ghostTime,Math.max(D.minTime-(C()-a),0)))):c()})},j.start=function(a){v(D,a),j.running=!0;try{r.render()}catch(b){i=b}return document.querySelector(".pace")?(j.trigger("start"),j.go()):setTimeout(j.start,50)},"function"==typeof define&&define.amd?define(["pace"],function(){return j}):"object"==typeof exports?module.exports=j:D.startOnPageLoad&&j.start()}).call(this);]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/lib/pace/pace-theme-material.min.css</url>
    <content><![CDATA[.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;color:#29d}.pace-progress{position:fixed;z-index:2000;top:50%;left:50%;margin-left:-2.5rem;margin-top:-2.5rem;height:5rem;width:5rem;opacity:1;-webkit-transition:opacity .1s;transition:opacity .1s;-webkit-transform:translate3d(0,0,0)!important;-ms-transform:translate3d(0,0,0)!important;transform:translate3d(0,0,0)!important}.pace-inactive .pace-progress,.pace-progress[data-progress="00"]{opacity:0}.pace-progress:after{height:5rem;width:5rem;text-align:center;line-height:5rem;content:attr(data-progress);display:block;font-size:1.8rem;font-family:'Helvetica Neue',Helvetica,Arial,sans-serif;font-weight:300}.pace-progress .pace-progress-inner{overflow:hidden;position:absolute;width:2.5rem;height:5rem;-webkit-transform-origin:left center;-ms-transform-origin:left center;transform-origin:left center;-webkit-transition:-webkit-transform .1s;transition:transform .1s;left:2.5rem;top:0}.pace-progress .pace-progress-inner:after,.pace-progress .pace-progress-inner:before{position:absolute;width:5rem;height:5rem;content:' ';left:-2.5rem;top:0;box-sizing:border-box;border:1px solid;border-radius:5rem}.pace-progress .pace-progress-inner:before{border-right-color:transparent;border-bottom-color:transparent;-webkit-transform:rotate(135deg);-ms-transform:rotate(135deg);transform:rotate(135deg)}.pace-progress .pace-progress-inner:after{border-left-color:transparent;border-top-color:transparent;display:none;-webkit-transform:rotate(315deg);-ms-transform:rotate(315deg);transform:rotate(315deg)}.pace-progress[data-progress="00"] .pace-progress-inner:before{-webkit-transform:rotate(-45deg);-ms-transform:rotate(-45deg);transform:rotate(-45deg)}.pace-progress[data-progress="01"] .pace-progress-inner:before{-webkit-transform:rotate(-41deg);-ms-transform:rotate(-41deg);transform:rotate(-41deg)}.pace-progress[data-progress="02"] .pace-progress-inner:before{-webkit-transform:rotate(-38deg);-ms-transform:rotate(-38deg);transform:rotate(-38deg)}.pace-progress[data-progress="03"] .pace-progress-inner:before{-webkit-transform:rotate(-34deg);-ms-transform:rotate(-34deg);transform:rotate(-34deg)}.pace-progress[data-progress="04"] .pace-progress-inner:before{-webkit-transform:rotate(-31deg);-ms-transform:rotate(-31deg);transform:rotate(-31deg)}.pace-progress[data-progress="05"] .pace-progress-inner:before{-webkit-transform:rotate(-27deg);-ms-transform:rotate(-27deg);transform:rotate(-27deg)}.pace-progress[data-progress="06"] .pace-progress-inner:before{-webkit-transform:rotate(-23deg);-ms-transform:rotate(-23deg);transform:rotate(-23deg)}.pace-progress[data-progress="07"] .pace-progress-inner:before{-webkit-transform:rotate(-20deg);-ms-transform:rotate(-20deg);transform:rotate(-20deg)}.pace-progress[data-progress="08"] .pace-progress-inner:before{-webkit-transform:rotate(-16deg);-ms-transform:rotate(-16deg);transform:rotate(-16deg)}.pace-progress[data-progress="09"] .pace-progress-inner:before{-webkit-transform:rotate(-13deg);-ms-transform:rotate(-13deg);transform:rotate(-13deg)}.pace-progress[data-progress="10"] .pace-progress-inner:before{-webkit-transform:rotate(-9deg);-ms-transform:rotate(-9deg);transform:rotate(-9deg)}.pace-progress[data-progress="11"] .pace-progress-inner:before{-webkit-transform:rotate(-5deg);-ms-transform:rotate(-5deg);transform:rotate(-5deg)}.pace-progress[data-progress="12"] .pace-progress-inner:before{-webkit-transform:rotate(-2deg);-ms-transform:rotate(-2deg);transform:rotate(-2deg)}.pace-progress[data-progress="13"] .pace-progress-inner:before{-webkit-transform:rotate(2deg);-ms-transform:rotate(2deg);transform:rotate(2deg)}.pace-progress[data-progress="14"] .pace-progress-inner:before{-webkit-transform:rotate(5deg);-ms-transform:rotate(5deg);transform:rotate(5deg)}.pace-progress[data-progress="15"] .pace-progress-inner:before{-webkit-transform:rotate(9deg);-ms-transform:rotate(9deg);transform:rotate(9deg)}.pace-progress[data-progress="16"] .pace-progress-inner:before{-webkit-transform:rotate(13deg);-ms-transform:rotate(13deg);transform:rotate(13deg)}.pace-progress[data-progress="17"] .pace-progress-inner:before{-webkit-transform:rotate(16deg);-ms-transform:rotate(16deg);transform:rotate(16deg)}.pace-progress[data-progress="18"] .pace-progress-inner:before{-webkit-transform:rotate(20deg);-ms-transform:rotate(20deg);transform:rotate(20deg)}.pace-progress[data-progress="19"] .pace-progress-inner:before{-webkit-transform:rotate(23deg);-ms-transform:rotate(23deg);transform:rotate(23deg)}.pace-progress[data-progress="20"] .pace-progress-inner:before{-webkit-transform:rotate(27deg);-ms-transform:rotate(27deg);transform:rotate(27deg)}.pace-progress[data-progress="21"] .pace-progress-inner:before{-webkit-transform:rotate(31deg);-ms-transform:rotate(31deg);transform:rotate(31deg)}.pace-progress[data-progress="22"] .pace-progress-inner:before{-webkit-transform:rotate(34deg);-ms-transform:rotate(34deg);transform:rotate(34deg)}.pace-progress[data-progress="23"] .pace-progress-inner:before{-webkit-transform:rotate(38deg);-ms-transform:rotate(38deg);transform:rotate(38deg)}.pace-progress[data-progress="24"] .pace-progress-inner:before{-webkit-transform:rotate(41deg);-ms-transform:rotate(41deg);transform:rotate(41deg)}.pace-progress[data-progress="25"] .pace-progress-inner:before{-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);transform:rotate(45deg)}.pace-progress[data-progress="26"] .pace-progress-inner:before{-webkit-transform:rotate(49deg);-ms-transform:rotate(49deg);transform:rotate(49deg)}.pace-progress[data-progress="27"] .pace-progress-inner:before{-webkit-transform:rotate(52deg);-ms-transform:rotate(52deg);transform:rotate(52deg)}.pace-progress[data-progress="28"] .pace-progress-inner:before{-webkit-transform:rotate(56deg);-ms-transform:rotate(56deg);transform:rotate(56deg)}.pace-progress[data-progress="29"] .pace-progress-inner:before{-webkit-transform:rotate(59deg);-ms-transform:rotate(59deg);transform:rotate(59deg)}.pace-progress[data-progress="30"] .pace-progress-inner:before{-webkit-transform:rotate(63deg);-ms-transform:rotate(63deg);transform:rotate(63deg)}.pace-progress[data-progress="31"] .pace-progress-inner:before{-webkit-transform:rotate(67deg);-ms-transform:rotate(67deg);transform:rotate(67deg)}.pace-progress[data-progress="32"] .pace-progress-inner:before{-webkit-transform:rotate(70deg);-ms-transform:rotate(70deg);transform:rotate(70deg)}.pace-progress[data-progress="33"] .pace-progress-inner:before{-webkit-transform:rotate(74deg);-ms-transform:rotate(74deg);transform:rotate(74deg)}.pace-progress[data-progress="34"] .pace-progress-inner:before{-webkit-transform:rotate(77deg);-ms-transform:rotate(77deg);transform:rotate(77deg)}.pace-progress[data-progress="35"] .pace-progress-inner:before{-webkit-transform:rotate(81deg);-ms-transform:rotate(81deg);transform:rotate(81deg)}.pace-progress[data-progress="36"] .pace-progress-inner:before{-webkit-transform:rotate(85deg);-ms-transform:rotate(85deg);transform:rotate(85deg)}.pace-progress[data-progress="37"] .pace-progress-inner:before{-webkit-transform:rotate(88deg);-ms-transform:rotate(88deg);transform:rotate(88deg)}.pace-progress[data-progress="38"] .pace-progress-inner:before{-webkit-transform:rotate(92deg);-ms-transform:rotate(92deg);transform:rotate(92deg)}.pace-progress[data-progress="39"] .pace-progress-inner:before{-webkit-transform:rotate(95deg);-ms-transform:rotate(95deg);transform:rotate(95deg)}.pace-progress[data-progress="40"] .pace-progress-inner:before{-webkit-transform:rotate(99deg);-ms-transform:rotate(99deg);transform:rotate(99deg)}.pace-progress[data-progress="41"] .pace-progress-inner:before{-webkit-transform:rotate(103deg);-ms-transform:rotate(103deg);transform:rotate(103deg)}.pace-progress[data-progress="42"] .pace-progress-inner:before{-webkit-transform:rotate(106deg);-ms-transform:rotate(106deg);transform:rotate(106deg)}.pace-progress[data-progress="43"] .pace-progress-inner:before{-webkit-transform:rotate(110deg);-ms-transform:rotate(110deg);transform:rotate(110deg)}.pace-progress[data-progress="44"] .pace-progress-inner:before{-webkit-transform:rotate(113deg);-ms-transform:rotate(113deg);transform:rotate(113deg)}.pace-progress[data-progress="45"] .pace-progress-inner:before{-webkit-transform:rotate(117deg);-ms-transform:rotate(117deg);transform:rotate(117deg)}.pace-progress[data-progress="46"] .pace-progress-inner:before{-webkit-transform:rotate(121deg);-ms-transform:rotate(121deg);transform:rotate(121deg)}.pace-progress[data-progress="47"] .pace-progress-inner:before{-webkit-transform:rotate(124deg);-ms-transform:rotate(124deg);transform:rotate(124deg)}.pace-progress[data-progress="48"] .pace-progress-inner:before{-webkit-transform:rotate(128deg);-ms-transform:rotate(128deg);transform:rotate(128deg)}.pace-progress[data-progress="49"] .pace-progress-inner:before{-webkit-transform:rotate(131deg);-ms-transform:rotate(131deg);transform:rotate(131deg)}.pace-progress[data-progress="50"] .pace-progress-inner:before{-webkit-transform:rotate(135deg);-ms-transform:rotate(135deg);transform:rotate(135deg)}.pace-progress[data-progress="50"] .pace-progress-inner:after{-webkit-transform:rotate(315deg);-ms-transform:rotate(315deg);transform:rotate(315deg);display:block}.pace-progress[data-progress="51"] .pace-progress-inner:after{-webkit-transform:rotate(319deg);-ms-transform:rotate(319deg);transform:rotate(319deg);display:block}.pace-progress[data-progress="52"] .pace-progress-inner:after{-webkit-transform:rotate(322deg);-ms-transform:rotate(322deg);transform:rotate(322deg);display:block}.pace-progress[data-progress="53"] .pace-progress-inner:after{-webkit-transform:rotate(326deg);-ms-transform:rotate(326deg);transform:rotate(326deg);display:block}.pace-progress[data-progress="54"] .pace-progress-inner:after{-webkit-transform:rotate(329deg);-ms-transform:rotate(329deg);transform:rotate(329deg);display:block}.pace-progress[data-progress="55"] .pace-progress-inner:after{-webkit-transform:rotate(333deg);-ms-transform:rotate(333deg);transform:rotate(333deg);display:block}.pace-progress[data-progress="56"] .pace-progress-inner:after{-webkit-transform:rotate(337deg);-ms-transform:rotate(337deg);transform:rotate(337deg);display:block}.pace-progress[data-progress="57"] .pace-progress-inner:after{-webkit-transform:rotate(340deg);-ms-transform:rotate(340deg);transform:rotate(340deg);display:block}.pace-progress[data-progress="58"] .pace-progress-inner:after{-webkit-transform:rotate(344deg);-ms-transform:rotate(344deg);transform:rotate(344deg);display:block}.pace-progress[data-progress="59"] .pace-progress-inner:after{-webkit-transform:rotate(347deg);-ms-transform:rotate(347deg);transform:rotate(347deg);display:block}.pace-progress[data-progress="60"] .pace-progress-inner:after{-webkit-transform:rotate(351deg);-ms-transform:rotate(351deg);transform:rotate(351deg);display:block}.pace-progress[data-progress="61"] .pace-progress-inner:after{-webkit-transform:rotate(355deg);-ms-transform:rotate(355deg);transform:rotate(355deg);display:block}.pace-progress[data-progress="62"] .pace-progress-inner:after{-webkit-transform:rotate(358deg);-ms-transform:rotate(358deg);transform:rotate(358deg);display:block}.pace-progress[data-progress="63"] .pace-progress-inner:after{-webkit-transform:rotate(362deg);-ms-transform:rotate(362deg);transform:rotate(362deg);display:block}.pace-progress[data-progress="64"] .pace-progress-inner:after{-webkit-transform:rotate(365deg);-ms-transform:rotate(365deg);transform:rotate(365deg);display:block}.pace-progress[data-progress="65"] .pace-progress-inner:after{-webkit-transform:rotate(369deg);-ms-transform:rotate(369deg);transform:rotate(369deg);display:block}.pace-progress[data-progress="66"] .pace-progress-inner:after{-webkit-transform:rotate(373deg);-ms-transform:rotate(373deg);transform:rotate(373deg);display:block}.pace-progress[data-progress="67"] .pace-progress-inner:after{-webkit-transform:rotate(376deg);-ms-transform:rotate(376deg);transform:rotate(376deg);display:block}.pace-progress[data-progress="68"] .pace-progress-inner:after{-webkit-transform:rotate(380deg);-ms-transform:rotate(380deg);transform:rotate(380deg);display:block}.pace-progress[data-progress="69"] .pace-progress-inner:after{-webkit-transform:rotate(383deg);-ms-transform:rotate(383deg);transform:rotate(383deg);display:block}.pace-progress[data-progress="70"] .pace-progress-inner:after{-webkit-transform:rotate(387deg);-ms-transform:rotate(387deg);transform:rotate(387deg);display:block}.pace-progress[data-progress="71"] .pace-progress-inner:after{-webkit-transform:rotate(391deg);-ms-transform:rotate(391deg);transform:rotate(391deg);display:block}.pace-progress[data-progress="72"] .pace-progress-inner:after{-webkit-transform:rotate(394deg);-ms-transform:rotate(394deg);transform:rotate(394deg);display:block}.pace-progress[data-progress="73"] .pace-progress-inner:after{-webkit-transform:rotate(398deg);-ms-transform:rotate(398deg);transform:rotate(398deg);display:block}.pace-progress[data-progress="74"] .pace-progress-inner:after{-webkit-transform:rotate(401deg);-ms-transform:rotate(401deg);transform:rotate(401deg);display:block}.pace-progress[data-progress="75"] .pace-progress-inner:after{-webkit-transform:rotate(405deg);-ms-transform:rotate(405deg);transform:rotate(405deg);display:block}.pace-progress[data-progress="76"] .pace-progress-inner:after{-webkit-transform:rotate(409deg);-ms-transform:rotate(409deg);transform:rotate(409deg);display:block}.pace-progress[data-progress="77"] .pace-progress-inner:after{-webkit-transform:rotate(412deg);-ms-transform:rotate(412deg);transform:rotate(412deg);display:block}.pace-progress[data-progress="78"] .pace-progress-inner:after{-webkit-transform:rotate(416deg);-ms-transform:rotate(416deg);transform:rotate(416deg);display:block}.pace-progress[data-progress="79"] .pace-progress-inner:after{-webkit-transform:rotate(419deg);-ms-transform:rotate(419deg);transform:rotate(419deg);display:block}.pace-progress[data-progress="80"] .pace-progress-inner:after{-webkit-transform:rotate(423deg);-ms-transform:rotate(423deg);transform:rotate(423deg);display:block}.pace-progress[data-progress="81"] .pace-progress-inner:after{-webkit-transform:rotate(427deg);-ms-transform:rotate(427deg);transform:rotate(427deg);display:block}.pace-progress[data-progress="82"] .pace-progress-inner:after{-webkit-transform:rotate(430deg);-ms-transform:rotate(430deg);transform:rotate(430deg);display:block}.pace-progress[data-progress="83"] .pace-progress-inner:after{-webkit-transform:rotate(434deg);-ms-transform:rotate(434deg);transform:rotate(434deg);display:block}.pace-progress[data-progress="84"] .pace-progress-inner:after{-webkit-transform:rotate(437deg);-ms-transform:rotate(437deg);transform:rotate(437deg);display:block}.pace-progress[data-progress="85"] .pace-progress-inner:after{-webkit-transform:rotate(441deg);-ms-transform:rotate(441deg);transform:rotate(441deg);display:block}.pace-progress[data-progress="86"] .pace-progress-inner:after{-webkit-transform:rotate(445deg);-ms-transform:rotate(445deg);transform:rotate(445deg);display:block}.pace-progress[data-progress="87"] .pace-progress-inner:after{-webkit-transform:rotate(448deg);-ms-transform:rotate(448deg);transform:rotate(448deg);display:block}.pace-progress[data-progress="88"] .pace-progress-inner:after{-webkit-transform:rotate(452deg);-ms-transform:rotate(452deg);transform:rotate(452deg);display:block}.pace-progress[data-progress="89"] .pace-progress-inner:after{-webkit-transform:rotate(455deg);-ms-transform:rotate(455deg);transform:rotate(455deg);display:block}.pace-progress[data-progress="90"] .pace-progress-inner:after{-webkit-transform:rotate(459deg);-ms-transform:rotate(459deg);transform:rotate(459deg);display:block}.pace-progress[data-progress="91"] .pace-progress-inner:after{-webkit-transform:rotate(463deg);-ms-transform:rotate(463deg);transform:rotate(463deg);display:block}.pace-progress[data-progress="92"] .pace-progress-inner:after{-webkit-transform:rotate(466deg);-ms-transform:rotate(466deg);transform:rotate(466deg);display:block}.pace-progress[data-progress="93"] .pace-progress-inner:after{-webkit-transform:rotate(470deg);-ms-transform:rotate(470deg);transform:rotate(470deg);display:block}.pace-progress[data-progress="94"] .pace-progress-inner:after{-webkit-transform:rotate(473deg);-ms-transform:rotate(473deg);transform:rotate(473deg);display:block}.pace-progress[data-progress="95"] .pace-progress-inner:after{-webkit-transform:rotate(477deg);-ms-transform:rotate(477deg);transform:rotate(477deg);display:block}.pace-progress[data-progress="96"] .pace-progress-inner:after{-webkit-transform:rotate(481deg);-ms-transform:rotate(481deg);transform:rotate(481deg);display:block}.pace-progress[data-progress="97"] .pace-progress-inner:after{-webkit-transform:rotate(484deg);-ms-transform:rotate(484deg);transform:rotate(484deg);display:block}.pace-progress[data-progress="98"] .pace-progress-inner:after{-webkit-transform:rotate(488deg);-ms-transform:rotate(488deg);transform:rotate(488deg);display:block}.pace-progress[data-progress="99"] .pace-progress-inner:after{-webkit-transform:rotate(491deg);-ms-transform:rotate(491deg);transform:rotate(491deg);display:block}.pace-progress[data-progress="100"] .pace-progress-inner:after{-webkit-transform:rotate(495deg);-ms-transform:rotate(495deg);transform:rotate(495deg);display:block}.pace-progress[data-progress="00"] .pace-progress-inner{-webkit-transform:rotate(0);-ms-transform:rotate(0);transform:rotate(0)}.pace-progress[data-progress="01"] .pace-progress-inner{-webkit-transform:rotate(4deg);-ms-transform:rotate(4deg);transform:rotate(4deg)}.pace-progress[data-progress="02"] .pace-progress-inner{-webkit-transform:rotate(7deg);-ms-transform:rotate(7deg);transform:rotate(7deg)}.pace-progress[data-progress="03"] .pace-progress-inner{-webkit-transform:rotate(11deg);-ms-transform:rotate(11deg);transform:rotate(11deg)}.pace-progress[data-progress="04"] .pace-progress-inner{-webkit-transform:rotate(14deg);-ms-transform:rotate(14deg);transform:rotate(14deg)}.pace-progress[data-progress="05"] .pace-progress-inner{-webkit-transform:rotate(18deg);-ms-transform:rotate(18deg);transform:rotate(18deg)}.pace-progress[data-progress="06"] .pace-progress-inner{-webkit-transform:rotate(22deg);-ms-transform:rotate(22deg);transform:rotate(22deg)}.pace-progress[data-progress="07"] .pace-progress-inner{-webkit-transform:rotate(25deg);-ms-transform:rotate(25deg);transform:rotate(25deg)}.pace-progress[data-progress="08"] .pace-progress-inner{-webkit-transform:rotate(29deg);-ms-transform:rotate(29deg);transform:rotate(29deg)}.pace-progress[data-progress="09"] .pace-progress-inner{-webkit-transform:rotate(32deg);-ms-transform:rotate(32deg);transform:rotate(32deg)}.pace-progress[data-progress="10"] .pace-progress-inner{-webkit-transform:rotate(36deg);-ms-transform:rotate(36deg);transform:rotate(36deg)}.pace-progress[data-progress="11"] .pace-progress-inner{-webkit-transform:rotate(40deg);-ms-transform:rotate(40deg);transform:rotate(40deg)}.pace-progress[data-progress="12"] .pace-progress-inner{-webkit-transform:rotate(43deg);-ms-transform:rotate(43deg);transform:rotate(43deg)}.pace-progress[data-progress="13"] .pace-progress-inner{-webkit-transform:rotate(47deg);-ms-transform:rotate(47deg);transform:rotate(47deg)}.pace-progress[data-progress="14"] .pace-progress-inner{-webkit-transform:rotate(50deg);-ms-transform:rotate(50deg);transform:rotate(50deg)}.pace-progress[data-progress="15"] .pace-progress-inner{-webkit-transform:rotate(54deg);-ms-transform:rotate(54deg);transform:rotate(54deg)}.pace-progress[data-progress="16"] .pace-progress-inner{-webkit-transform:rotate(58deg);-ms-transform:rotate(58deg);transform:rotate(58deg)}.pace-progress[data-progress="17"] .pace-progress-inner{-webkit-transform:rotate(61deg);-ms-transform:rotate(61deg);transform:rotate(61deg)}.pace-progress[data-progress="18"] .pace-progress-inner{-webkit-transform:rotate(65deg);-ms-transform:rotate(65deg);transform:rotate(65deg)}.pace-progress[data-progress="19"] .pace-progress-inner{-webkit-transform:rotate(68deg);-ms-transform:rotate(68deg);transform:rotate(68deg)}.pace-progress[data-progress="20"] .pace-progress-inner{-webkit-transform:rotate(72deg);-ms-transform:rotate(72deg);transform:rotate(72deg)}.pace-progress[data-progress="21"] .pace-progress-inner{-webkit-transform:rotate(76deg);-ms-transform:rotate(76deg);transform:rotate(76deg)}.pace-progress[data-progress="22"] .pace-progress-inner{-webkit-transform:rotate(79deg);-ms-transform:rotate(79deg);transform:rotate(79deg)}.pace-progress[data-progress="23"] .pace-progress-inner{-webkit-transform:rotate(83deg);-ms-transform:rotate(83deg);transform:rotate(83deg)}.pace-progress[data-progress="24"] .pace-progress-inner{-webkit-transform:rotate(86deg);-ms-transform:rotate(86deg);transform:rotate(86deg)}.pace-progress[data-progress="25"] .pace-progress-inner{-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);transform:rotate(90deg)}.pace-progress[data-progress="26"] .pace-progress-inner{-webkit-transform:rotate(94deg);-ms-transform:rotate(94deg);transform:rotate(94deg)}.pace-progress[data-progress="27"] .pace-progress-inner{-webkit-transform:rotate(97deg);-ms-transform:rotate(97deg);transform:rotate(97deg)}.pace-progress[data-progress="28"] .pace-progress-inner{-webkit-transform:rotate(101deg);-ms-transform:rotate(101deg);transform:rotate(101deg)}.pace-progress[data-progress="29"] .pace-progress-inner{-webkit-transform:rotate(104deg);-ms-transform:rotate(104deg);transform:rotate(104deg)}.pace-progress[data-progress="30"] .pace-progress-inner{-webkit-transform:rotate(108deg);-ms-transform:rotate(108deg);transform:rotate(108deg)}.pace-progress[data-progress="31"] .pace-progress-inner{-webkit-transform:rotate(112deg);-ms-transform:rotate(112deg);transform:rotate(112deg)}.pace-progress[data-progress="32"] .pace-progress-inner{-webkit-transform:rotate(115deg);-ms-transform:rotate(115deg);transform:rotate(115deg)}.pace-progress[data-progress="33"] .pace-progress-inner{-webkit-transform:rotate(119deg);-ms-transform:rotate(119deg);transform:rotate(119deg)}.pace-progress[data-progress="34"] .pace-progress-inner{-webkit-transform:rotate(122deg);-ms-transform:rotate(122deg);transform:rotate(122deg)}.pace-progress[data-progress="35"] .pace-progress-inner{-webkit-transform:rotate(126deg);-ms-transform:rotate(126deg);transform:rotate(126deg)}.pace-progress[data-progress="36"] .pace-progress-inner{-webkit-transform:rotate(130deg);-ms-transform:rotate(130deg);transform:rotate(130deg)}.pace-progress[data-progress="37"] .pace-progress-inner{-webkit-transform:rotate(133deg);-ms-transform:rotate(133deg);transform:rotate(133deg)}.pace-progress[data-progress="38"] .pace-progress-inner{-webkit-transform:rotate(137deg);-ms-transform:rotate(137deg);transform:rotate(137deg)}.pace-progress[data-progress="39"] .pace-progress-inner{-webkit-transform:rotate(140deg);-ms-transform:rotate(140deg);transform:rotate(140deg)}.pace-progress[data-progress="40"] .pace-progress-inner{-webkit-transform:rotate(144deg);-ms-transform:rotate(144deg);transform:rotate(144deg)}.pace-progress[data-progress="41"] .pace-progress-inner{-webkit-transform:rotate(148deg);-ms-transform:rotate(148deg);transform:rotate(148deg)}.pace-progress[data-progress="42"] .pace-progress-inner{-webkit-transform:rotate(151deg);-ms-transform:rotate(151deg);transform:rotate(151deg)}.pace-progress[data-progress="43"] .pace-progress-inner{-webkit-transform:rotate(155deg);-ms-transform:rotate(155deg);transform:rotate(155deg)}.pace-progress[data-progress="44"] .pace-progress-inner{-webkit-transform:rotate(158deg);-ms-transform:rotate(158deg);transform:rotate(158deg)}.pace-progress[data-progress="45"] .pace-progress-inner{-webkit-transform:rotate(162deg);-ms-transform:rotate(162deg);transform:rotate(162deg)}.pace-progress[data-progress="46"] .pace-progress-inner{-webkit-transform:rotate(166deg);-ms-transform:rotate(166deg);transform:rotate(166deg)}.pace-progress[data-progress="47"] .pace-progress-inner{-webkit-transform:rotate(169deg);-ms-transform:rotate(169deg);transform:rotate(169deg)}.pace-progress[data-progress="48"] .pace-progress-inner{-webkit-transform:rotate(173deg);-ms-transform:rotate(173deg);transform:rotate(173deg)}.pace-progress[data-progress="49"] .pace-progress-inner{-webkit-transform:rotate(176deg);-ms-transform:rotate(176deg);transform:rotate(176deg)}.pace-progress[data-progress="50"] .pace-progress-inner{-webkit-transform:rotate(180deg);-ms-transform:rotate(180deg);transform:rotate(180deg)}.pace-progress[data-progress="51"] .pace-progress-inner{-webkit-transform:rotate(184deg);-ms-transform:rotate(184deg);transform:rotate(184deg);overflow:visible}.pace-progress[data-progress="52"] .pace-progress-inner{-webkit-transform:rotate(187deg);-ms-transform:rotate(187deg);transform:rotate(187deg);overflow:visible}.pace-progress[data-progress="53"] .pace-progress-inner{-webkit-transform:rotate(191deg);-ms-transform:rotate(191deg);transform:rotate(191deg);overflow:visible}.pace-progress[data-progress="54"] .pace-progress-inner{-webkit-transform:rotate(194deg);-ms-transform:rotate(194deg);transform:rotate(194deg);overflow:visible}.pace-progress[data-progress="55"] .pace-progress-inner{-webkit-transform:rotate(198deg);-ms-transform:rotate(198deg);transform:rotate(198deg);overflow:visible}.pace-progress[data-progress="56"] .pace-progress-inner{-webkit-transform:rotate(202deg);-ms-transform:rotate(202deg);transform:rotate(202deg);overflow:visible}.pace-progress[data-progress="57"] .pace-progress-inner{-webkit-transform:rotate(205deg);-ms-transform:rotate(205deg);transform:rotate(205deg);overflow:visible}.pace-progress[data-progress="58"] .pace-progress-inner{-webkit-transform:rotate(209deg);-ms-transform:rotate(209deg);transform:rotate(209deg);overflow:visible}.pace-progress[data-progress="59"] .pace-progress-inner{-webkit-transform:rotate(212deg);-ms-transform:rotate(212deg);transform:rotate(212deg);overflow:visible}.pace-progress[data-progress="60"] .pace-progress-inner{-webkit-transform:rotate(216deg);-ms-transform:rotate(216deg);transform:rotate(216deg);overflow:visible}.pace-progress[data-progress="61"] .pace-progress-inner{-webkit-transform:rotate(220deg);-ms-transform:rotate(220deg);transform:rotate(220deg);overflow:visible}.pace-progress[data-progress="62"] .pace-progress-inner{-webkit-transform:rotate(223deg);-ms-transform:rotate(223deg);transform:rotate(223deg);overflow:visible}.pace-progress[data-progress="63"] .pace-progress-inner{-webkit-transform:rotate(227deg);-ms-transform:rotate(227deg);transform:rotate(227deg);overflow:visible}.pace-progress[data-progress="64"] .pace-progress-inner{-webkit-transform:rotate(230deg);-ms-transform:rotate(230deg);transform:rotate(230deg);overflow:visible}.pace-progress[data-progress="65"] .pace-progress-inner{-webkit-transform:rotate(234deg);-ms-transform:rotate(234deg);transform:rotate(234deg);overflow:visible}.pace-progress[data-progress="66"] .pace-progress-inner{-webkit-transform:rotate(238deg);-ms-transform:rotate(238deg);transform:rotate(238deg);overflow:visible}.pace-progress[data-progress="67"] .pace-progress-inner{-webkit-transform:rotate(241deg);-ms-transform:rotate(241deg);transform:rotate(241deg);overflow:visible}.pace-progress[data-progress="68"] .pace-progress-inner{-webkit-transform:rotate(245deg);-ms-transform:rotate(245deg);transform:rotate(245deg);overflow:visible}.pace-progress[data-progress="69"] .pace-progress-inner{-webkit-transform:rotate(248deg);-ms-transform:rotate(248deg);transform:rotate(248deg);overflow:visible}.pace-progress[data-progress="70"] .pace-progress-inner{-webkit-transform:rotate(252deg);-ms-transform:rotate(252deg);transform:rotate(252deg);overflow:visible}.pace-progress[data-progress="71"] .pace-progress-inner{-webkit-transform:rotate(256deg);-ms-transform:rotate(256deg);transform:rotate(256deg);overflow:visible}.pace-progress[data-progress="72"] .pace-progress-inner{-webkit-transform:rotate(259deg);-ms-transform:rotate(259deg);transform:rotate(259deg);overflow:visible}.pace-progress[data-progress="73"] .pace-progress-inner{-webkit-transform:rotate(263deg);-ms-transform:rotate(263deg);transform:rotate(263deg);overflow:visible}.pace-progress[data-progress="74"] .pace-progress-inner{-webkit-transform:rotate(266deg);-ms-transform:rotate(266deg);transform:rotate(266deg);overflow:visible}.pace-progress[data-progress="75"] .pace-progress-inner{-webkit-transform:rotate(270deg);-ms-transform:rotate(270deg);transform:rotate(270deg);overflow:visible}.pace-progress[data-progress="76"] .pace-progress-inner{-webkit-transform:rotate(274deg);-ms-transform:rotate(274deg);transform:rotate(274deg);overflow:visible}.pace-progress[data-progress="77"] .pace-progress-inner{-webkit-transform:rotate(277deg);-ms-transform:rotate(277deg);transform:rotate(277deg);overflow:visible}.pace-progress[data-progress="78"] .pace-progress-inner{-webkit-transform:rotate(281deg);-ms-transform:rotate(281deg);transform:rotate(281deg);overflow:visible}.pace-progress[data-progress="79"] .pace-progress-inner{-webkit-transform:rotate(284deg);-ms-transform:rotate(284deg);transform:rotate(284deg);overflow:visible}.pace-progress[data-progress="80"] .pace-progress-inner{-webkit-transform:rotate(288deg);-ms-transform:rotate(288deg);transform:rotate(288deg);overflow:visible}.pace-progress[data-progress="81"] .pace-progress-inner{-webkit-transform:rotate(292deg);-ms-transform:rotate(292deg);transform:rotate(292deg);overflow:visible}.pace-progress[data-progress="82"] .pace-progress-inner{-webkit-transform:rotate(295deg);-ms-transform:rotate(295deg);transform:rotate(295deg);overflow:visible}.pace-progress[data-progress="83"] .pace-progress-inner{-webkit-transform:rotate(299deg);-ms-transform:rotate(299deg);transform:rotate(299deg);overflow:visible}.pace-progress[data-progress="84"] .pace-progress-inner{-webkit-transform:rotate(302deg);-ms-transform:rotate(302deg);transform:rotate(302deg);overflow:visible}.pace-progress[data-progress="85"] .pace-progress-inner{-webkit-transform:rotate(306deg);-ms-transform:rotate(306deg);transform:rotate(306deg);overflow:visible}.pace-progress[data-progress="86"] .pace-progress-inner{-webkit-transform:rotate(310deg);-ms-transform:rotate(310deg);transform:rotate(310deg);overflow:visible}.pace-progress[data-progress="87"] .pace-progress-inner{-webkit-transform:rotate(313deg);-ms-transform:rotate(313deg);transform:rotate(313deg);overflow:visible}.pace-progress[data-progress="88"] .pace-progress-inner{-webkit-transform:rotate(317deg);-ms-transform:rotate(317deg);transform:rotate(317deg);overflow:visible}.pace-progress[data-progress="89"] .pace-progress-inner{-webkit-transform:rotate(320deg);-ms-transform:rotate(320deg);transform:rotate(320deg);overflow:visible}.pace-progress[data-progress="90"] .pace-progress-inner{-webkit-transform:rotate(324deg);-ms-transform:rotate(324deg);transform:rotate(324deg);overflow:visible}.pace-progress[data-progress="91"] .pace-progress-inner{-webkit-transform:rotate(328deg);-ms-transform:rotate(328deg);transform:rotate(328deg);overflow:visible}.pace-progress[data-progress="92"] .pace-progress-inner{-webkit-transform:rotate(331deg);-ms-transform:rotate(331deg);transform:rotate(331deg);overflow:visible}.pace-progress[data-progress="93"] .pace-progress-inner{-webkit-transform:rotate(335deg);-ms-transform:rotate(335deg);transform:rotate(335deg);overflow:visible}.pace-progress[data-progress="94"] .pace-progress-inner{-webkit-transform:rotate(338deg);-ms-transform:rotate(338deg);transform:rotate(338deg);overflow:visible}.pace-progress[data-progress="95"] .pace-progress-inner{-webkit-transform:rotate(342deg);-ms-transform:rotate(342deg);transform:rotate(342deg);overflow:visible}.pace-progress[data-progress="96"] .pace-progress-inner{-webkit-transform:rotate(346deg);-ms-transform:rotate(346deg);transform:rotate(346deg);overflow:visible}.pace-progress[data-progress="97"] .pace-progress-inner{-webkit-transform:rotate(349deg);-ms-transform:rotate(349deg);transform:rotate(349deg);overflow:visible}.pace-progress[data-progress="98"] .pace-progress-inner{-webkit-transform:rotate(353deg);-ms-transform:rotate(353deg);transform:rotate(353deg);overflow:visible}.pace-progress[data-progress="99"] .pace-progress-inner{-webkit-transform:rotate(356deg);-ms-transform:rotate(356deg);transform:rotate(356deg);overflow:visible}.pace-progress[data-progress="100"] .pace-progress-inner{-webkit-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg);overflow:visible}
]]></content>
  </entry>
</search>
